{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"themes/icarus/source/css/back-to-top.css","path":"css/back-to-top.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/insight.css","path":"css/insight.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/progressbar.css","path":"css/progressbar.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/search.css","path":"css/search.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/favicon.svg","path":"images/favicon.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/og_image.png","path":"images/og_image.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/back-to-top.js","path":"js/back-to-top.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/head.jpeg","path":"images/head.jpeg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1575291969570},{"_id":"themes/icarus/_config.yml","hash":"a93f9fb7ed1c2267229a714c9d95a62a394d85af","modified":1577890588220},{"_id":"themes/icarus/LICENSE","hash":"41f72cd544612bc4589c924c776422b800a4eff7","modified":1575291969570},{"_id":"themes/icarus/README.md","hash":"c351bc76d3b4a138989c50f57bd3c52fa95eaa56","modified":1575291969570},{"_id":"themes/icarus/package.json","hash":"e9bcb9fcf69462d5b03c7870eb13ab28aa7933c7","modified":1575291969574},{"_id":"themes/icarus/_config.old.yml","hash":"3fa2be2cbaf058736b3149fc6b3ea877d1f1e559","modified":1575345454435},{"_id":"source/_posts/2018-09-18-LongestSubstringWithoutRepeatingCharacters.md","hash":"b23e0883db0d68bad94b84eeabbb93528c1c8e17","modified":1575469833319},{"_id":"source/_posts/2018-05-16-firstblog.md","hash":"92ef93aa2804ac1530012ae09138cba157192f8e","modified":1575469833035},{"_id":"source/_posts/2018-05-18-create-vpn.md","hash":"8f0f892668805addff87b0d3e30e4e49261c1e0e","modified":1575469833351},{"_id":"source/_posts/2018-09-17-ValidParentheses.md","hash":"498a98a3e7563a5b738a6677497e210846fa126f","modified":1575469833283},{"_id":"source/_posts/2018-09-20-MedianofTwoSortedArrays.md","hash":"a71ef5ce5164a36063511fed251b5eca41ffcc2f","modified":1575469833103},{"_id":"source/_posts/2018-09-21-sougoumianshi.md","hash":"1d53787f832fd4b56b35bc333ea8e5168a11c291","modified":1575469833419},{"_id":"source/_posts/2019-01-16-ThinkInJava.md","hash":"e534d6cef7debb9ffa8360f66c6076b265d6f497","modified":1575469833067},{"_id":"source/_posts/2018-09-22-ImplementQueueusinggStacks.md","hash":"23b5a52e4c8b2b0bf96b609ebbb14cba1b4b2158","modified":1575469833247},{"_id":"source/_posts/2019-01-26-DesignPattern.md","hash":"a457379bc2717b157cc44b90559a22a610f3876b","modified":1575469833135},{"_id":"source/_posts/2019-01-16-leetcode.md","hash":"8c1305c7ac828bf59dc81907d189ccf4c48733f6","modified":1575469832995},{"_id":"source/_posts/2018-11-14-springbootblog.md","hash":"74f0689926a828c84840fba9b4fa83195aa6a97b","modified":1575469833171},{"_id":"source/_posts/2018-09-22-toutiaomianshibuqu.md","hash":"7a02a9a244c83ad48e2b37c0df7a34496b5da6ed","modified":1575469939020},{"_id":"source/_posts/2019-11-26-iqiyi.md","hash":"112914ad309b5bb48fa96feafc979bc3696af2ca","modified":1575469832935},{"_id":"source/_posts/2020-2-28-淘系技术部一面.md","hash":"d0dd3d1deaee86dc33e64c846d61e026a0c7d23e","modified":1583827204517},{"_id":"source/_posts/TCP状态问题.md","hash":"54983641748e2c17e00a28998f7015a129551f91","modified":1577596992016},{"_id":"source/_posts/2019年终总结.md","hash":"7091dfd3e41882b73f05f9b54743f86e87bc450b","modified":1576909773640},{"_id":"source/_posts/Java容器.md","hash":"0eed079705df360873524e076e9b144894f29096","modified":1580440868888},{"_id":"source/_posts/准备找暑期实习，至此时大约一个月.md","hash":"763b32af51c9a19d375aa431ba658eca9ecca6f1","modified":1583827204605},{"_id":"source/_posts/java内存分配.md","hash":"bacd35a245b7a29dfee1518156b06d86d937f1f2","modified":1578316592044},{"_id":"source/_posts/Java数据类型.md","hash":"f1703ac2cc667977da7b1dea272f90a6906228b5","modified":1578316592144},{"_id":"source/_posts/双亲委派模型类加载器问题.md","hash":"dce8a1a792336a0ada0b5a4ec7c14415cf082e0f","modified":1579594522206},{"_id":"source/_posts/gc.md","hash":"af12756fe4522c74c99c17fb2714d2ed9ccc1afc","modified":1579594522266},{"_id":"source/_posts/2019-11-27-CommandPattern.md","hash":"31c49def343d204540b15bddcf808bc599128a8b","modified":1575099433949},{"_id":"source/_posts/暑期实习面试准备.md","hash":"e8c601dbbbbeb8f874b968e868483319a9a3f9c9","modified":1584342801283},{"_id":"source/_posts/美团到店saas业务面试.md","hash":"b41482696c4677c50be5bc80583ff87585a82463","modified":1584622785222},{"_id":"source/_posts/数据库行级锁.md","hash":"6d44b02823c6664c74f6d961a3b31cd65e492481","modified":1578316240899},{"_id":"source/_posts/用户增长部提前批面经.md","hash":"94d72d13033e9fa5e5409d6ab02eba3c3e27a881","modified":1583827204401},{"_id":"source/_posts/阿里巴巴ihome团队面试.md","hash":"319c5d145db1ec00d5ddc692971445769fc8e7dd","modified":1583827204677},{"_id":"source/_posts/数据库事务.md","hash":"48c7095579a62e9cb2b7719e19376f081427d370","modified":1581744682548},{"_id":"source/_posts/解决TIME-WAIT过多的问题.md","hash":"c81c106c0fc447910b89b3352b048f616a792934","modified":1581260184877},{"_id":"source/_posts/阿里巴巴淘宝互动平台实习生面试.md","hash":"ef0cf53716631bf57ca03e95f97802a509806ffd","modified":1584287589573},{"_id":"themes/icarus/.git/config","hash":"d29e0b80e29cd924161a73c63bac11af41d2631c","modified":1575291969546},{"_id":"themes/icarus/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1575291969546},{"_id":"source/_posts/阿里巴巴支付宝面试.md","hash":"8f8676bd57b8742428ade409cad0aa212daf0399","modified":1583827204569},{"_id":"source/_posts/腾讯pcg实习面试.md","hash":"87b22b5c8763dd3bf69b13134a63de1ebd79568b","modified":1584357231441},{"_id":"themes/icarus/.git/packed-refs","hash":"3c4071a8b2efb256a95fc4ef49c957b6f8e955c4","modified":1575291969546},{"_id":"themes/icarus/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1575291534040},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"6b17b84116938367757928087a09dcb8489d06f6","modified":1575291969570},{"_id":"source/_posts/阿里巴巴钉钉面试.md","hash":"6a2ac64143967f7e628d0ffebec555a3adc4a703","modified":1584170862082},{"_id":"source/about/index.md","hash":"5a0c43960eb62b44fc1775260eb235e2f9bd3c7f","modified":1576909040209},{"_id":"themes/icarus/.git/index","hash":"06625cc757b0522eb190d5c8845c799cb74aa3e0","modified":1576417359805},{"_id":"themes/icarus/languages/en.yml","hash":"66d873bbe04894610c2d28b0d03e10143997b51b","modified":1575291969570},{"_id":"themes/icarus/languages/es.yml","hash":"2e59e579d393c881dcbb885516d93eeaf469cec2","modified":1575291969570},{"_id":"themes/icarus/languages/fr.yml","hash":"0017f93a5d491a9c0e55911cdc35316762c5a94e","modified":1575291969570},{"_id":"themes/icarus/languages/id.yml","hash":"92d2d19a62a17b6e99f82a014309bbf6c13c9ae8","modified":1575291969570},{"_id":"themes/icarus/languages/ja.yml","hash":"6eed7771de2353d71b720c6e605cceb3f230b12e","modified":1575291969570},{"_id":"themes/icarus/languages/ko.yml","hash":"e7ac736b604429adedd67f3ca6043201eff7b23b","modified":1575291969570},{"_id":"themes/icarus/languages/pl.yml","hash":"43f5447c38c9be2e1f5ce6181a0f97eeb437b059","modified":1575291969570},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"bcf5bc81ca855d26bbc3b3bfabc7d84429e74b85","modified":1575291969570},{"_id":"themes/icarus/languages/ru.yml","hash":"ba8b4f7d77eb1d1e28aa1f9107bd0bbbdc4cba99","modified":1575291969570},{"_id":"themes/icarus/languages/tr.yml","hash":"eff1c0b3d5c4b328f6dd74a195ff378c898f4d29","modified":1575291969570},{"_id":"themes/icarus/languages/vn.yml","hash":"6d9f4fabca711a6cb0a0efd72aa75c3641beb4a6","modified":1575291969570},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"804f6a1edee49bb6a5ecb8e9d14d3e93eaca37c0","modified":1575291969570},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"6ff978a0c4c11e996925e1a912a1d805f4680a6c","modified":1575291969570},{"_id":"themes/icarus/layout/archive.ejs","hash":"2527527eaf3e757ab476325f691d2e2e0ff9c2d5","modified":1575291969570},{"_id":"themes/icarus/layout/categories.ejs","hash":"29d304f2b95a04fbc5e7529f9bdce9648e3545ef","modified":1575291969570},{"_id":"themes/icarus/layout/category.ejs","hash":"58aa84f75193b978b2072f29dbb84ed8279574b9","modified":1575291969570},{"_id":"themes/icarus/layout/index.ejs","hash":"8ab440868f721bb7256ab9f2be96996850b0cf44","modified":1575291969570},{"_id":"themes/icarus/layout/layout.ejs","hash":"c9ab786c4c4a95e403fc8ea7e536084f21a9ecc4","modified":1575291969570},{"_id":"themes/icarus/layout/page.ejs","hash":"ebf120d46074f67ea25a231d2f7a64fd1e751904","modified":1575291969570},{"_id":"themes/icarus/scripts/index.js","hash":"f97eb95812480cc3b07cc0ad44dc39f9a0032f24","modified":1575291969574},{"_id":"themes/icarus/layout/tag.ejs","hash":"45eb077f2ac86f5c8090cb1a2361eed56a368e95","modified":1575291969574},{"_id":"themes/icarus/layout/post.ejs","hash":"ebf120d46074f67ea25a231d2f7a64fd1e751904","modified":1575291969570},{"_id":"themes/icarus/layout/tags.ejs","hash":"0c527c6b72386f11c18e8aa5249be8c601e69906","modified":1575291969574},{"_id":"themes/icarus/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1575291534040},{"_id":"themes/icarus/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1575291534040},{"_id":"themes/icarus/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1575291534040},{"_id":"themes/icarus/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1575291534040},{"_id":"themes/icarus/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1575291534040},{"_id":"themes/icarus/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1575291534040},{"_id":"themes/icarus/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1575291534040},{"_id":"themes/icarus/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1575291534040},{"_id":"themes/icarus/includes/common/ConfigGenerator.js","hash":"451397efc7808787419fa3eb6b043c0bd8bbdf30","modified":1575291969570},{"_id":"themes/icarus/includes/common/ConfigValidator.js","hash":"48cff5402e93b11d5266370e9c4b78ee21369cb9","modified":1575291969570},{"_id":"themes/icarus/includes/common/utils.js","hash":"c0aeaeb57a42bcc71a92da2249762f91abd83ffe","modified":1575291969570},{"_id":"themes/icarus/includes/filters/highlight.js","hash":"19a4dcd2dee7388544b57e473cfb0fc9eea9623e","modified":1575291969570},{"_id":"themes/icarus/includes/generators/categories.js","hash":"7cb370ac53a05d6b1b9203579716c0ca83d35c36","modified":1575291969570},{"_id":"themes/icarus/includes/generators/category.js","hash":"313e170e55d74526c4e1be7181ef7a21439147c9","modified":1575291969570},{"_id":"themes/icarus/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1575291969570},{"_id":"themes/icarus/includes/generators/tags.js","hash":"8195322c208706427a1cf56361669dca4d86f6f1","modified":1575291969570},{"_id":"themes/icarus/includes/helpers/cdn.js","hash":"7d34ea6400cb3611c374c135304abcb65ef291b7","modified":1575291969570},{"_id":"themes/icarus/includes/helpers/config.js","hash":"173e02987e7a7d5df1e686f6ee4edd8cf494bdd3","modified":1575291969570},{"_id":"themes/icarus/includes/helpers/layout.js","hash":"afdf5e9704cfc087526b4a0403fe7eb04f22190e","modified":1575291969570},{"_id":"themes/icarus/includes/helpers/override.js","hash":"98f2c72c79de74bd01e3be10ef2f174c885d395a","modified":1575291969570},{"_id":"themes/icarus/includes/helpers/page.js","hash":"4ce98c781bcbc132672e6d16bf02df5bebcea7b3","modified":1575291969570},{"_id":"themes/icarus/includes/helpers/site.js","hash":"2f55818448fe83c73418dcf9751745c7918c10e3","modified":1575291969570},{"_id":"themes/icarus/includes/specs/article.spec.js","hash":"ce24279cd0cd39855216dab0cd5223c755757cdf","modified":1575291969570},{"_id":"themes/icarus/includes/specs/comment.spec.js","hash":"b0ef033e363b918134fb5a003143e9bd8fafa300","modified":1575291969570},{"_id":"themes/icarus/includes/specs/config.spec.js","hash":"7a9bac384a73cf9f39173fdb2dfc2813784d8891","modified":1575291969570},{"_id":"themes/icarus/includes/specs/donate.spec.js","hash":"722cb2662569957e8b1d1a467d9632b8cc6e69d6","modified":1575291969570},{"_id":"themes/icarus/includes/specs/footer.spec.js","hash":"8e6d7c5f9a13ce03241b6562259d210b389cb88e","modified":1575291969570},{"_id":"themes/icarus/includes/specs/icon_link.spec.js","hash":"f2a83ac5ccb74fc6f3dfbd25430e142297d8491c","modified":1575291969570},{"_id":"themes/icarus/includes/specs/meta.spec.js","hash":"ed1b818b929d71930608291514a72ef5a639efee","modified":1575291969570},{"_id":"themes/icarus/includes/specs/navbar.spec.js","hash":"7de29c0031738a4de4d31ed4f7b0c43447c7961c","modified":1575291969570},{"_id":"themes/icarus/includes/specs/plugins.spec.js","hash":"2fb7a28fdde9a46f576e69b9967f24d66adffb57","modified":1575291969570},{"_id":"themes/icarus/includes/specs/providers.spec.js","hash":"820cc6936ba75e3104cc2e8641716ed65ada8b6f","modified":1575291969570},{"_id":"themes/icarus/includes/specs/search.spec.js","hash":"1e3995cdc471e6a2817cd45e2b6f0fd39b4540ec","modified":1575291969570},{"_id":"themes/icarus/includes/specs/share.spec.js","hash":"5ec65409a17ead13974140fc5ddc19e526586d9f","modified":1575291969570},{"_id":"themes/icarus/includes/specs/sidebar.spec.js","hash":"630c9701affe2549abc61cd4d1e5153af2224fb6","modified":1575291969570},{"_id":"themes/icarus/includes/specs/widgets.spec.js","hash":"c5cedfe1074c0566baf8aca248f0392a501d9a74","modified":1575291969570},{"_id":"themes/icarus/includes/tasks/check_config.js","hash":"ce7626d643737c90dee6b75435ccdec26b89dacf","modified":1575291969570},{"_id":"themes/icarus/includes/tasks/check_deps.js","hash":"cfc357f27116d1b9285a3b0bec35c3e89ae73711","modified":1575291969570},{"_id":"themes/icarus/includes/tasks/welcome.js","hash":"00d1ef8c9609552b82e9a5140b838a9057c59508","modified":1575291969570},{"_id":"themes/icarus/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1575291534040},{"_id":"themes/icarus/.git/logs/HEAD","hash":"621958f34110b5f51808b89ebfc532f192c05e6d","modified":1575291969546},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"73038ac4fdfdfa71d92edaa98cc194b3446586a3","modified":1575291969570},{"_id":"themes/icarus/layout/comment/changyan.locals.js","hash":"49bce2ee742c7224bda97092d6e0a1a09184ef34","modified":1575291969570},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"7a8c656c8651d48e21ed24c469ea75898b2b12df","modified":1575291969570},{"_id":"themes/icarus/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1575291534040},{"_id":"themes/icarus/layout/comment/disqus.locals.js","hash":"a8d2cecaa82ec9e2e2e61cb73417d63d115335d6","modified":1575291969570},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"1c3751f36f737527e352c65bb1ca7172ff792979","modified":1575291969570},{"_id":"themes/icarus/layout/comment/facebook.locals.js","hash":"77e3ef1d933660d980b26d15968aa1a5c8a93a56","modified":1575291969570},{"_id":"themes/icarus/layout/comment/gitalk.ejs","hash":"eb1314badf793924b5786e92f8b3ebb0f21f3b58","modified":1575291969570},{"_id":"themes/icarus/layout/comment/gitalk.locals.js","hash":"f920f130598148b4d9f213c82f2d7f88a796012f","modified":1575291969570},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"d5e1a396e23df4e75e139d12846290bdb08ba01e","modified":1575291969570},{"_id":"themes/icarus/layout/comment/gitment.locals.js","hash":"f920f130598148b4d9f213c82f2d7f88a796012f","modified":1575291969570},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"cc6a43bd24be764086f88ad7c5c97ff04df87e0b","modified":1575291969570},{"_id":"themes/icarus/layout/comment/isso.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"12ff9a345f6bba2f732f592e39508c2afde89b00","modified":1575291969570},{"_id":"themes/icarus/layout/comment/livere.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"a29cf2e69f66a37ddcec8343c60af1e676dcb77d","modified":1575291969570},{"_id":"themes/icarus/layout/comment/valine.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/common/article.ejs","hash":"d2362964b2d9427067e1d7dfe100220b380b2f70","modified":1575291969570},{"_id":"themes/icarus/layout/common/article.locals.js","hash":"1f108fa96e61a681d7b1ee390b4f0ff60d042720","modified":1575291969570},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"4adfc361b780193bfc8ad73afb7079e550f37eb7","modified":1575291969570},{"_id":"themes/icarus/layout/common/footer.locals.js","hash":"504ed92dc76723f19777463d690acfbe1d89e2ba","modified":1575291969570},{"_id":"themes/icarus/layout/common/head.ejs","hash":"0998072c9ece90e26339f2503633c4ca08da62e9","modified":1575291969570},{"_id":"themes/icarus/layout/common/navbar.ejs","hash":"765d8ab516781d7157bb41d690a71b549e95e721","modified":1575291969570},{"_id":"themes/icarus/layout/common/navbar.locals.js","hash":"7e523ba80667038f2e58cf4f9cb073e9afbc70e6","modified":1575291969570},{"_id":"themes/icarus/layout/common/paginator.ejs","hash":"7837d80b27f166161b3deeffb571680025c7d723","modified":1575291969570},{"_id":"themes/icarus/layout/common/widget.ejs","hash":"02ffa7531d14b88e76bff5ff6d2b4482e7c5bbfd","modified":1575291969570},{"_id":"themes/icarus/layout/donate/alipay.ejs","hash":"3290058879973e403a05472a0fe2ac0219d5b961","modified":1575291969570},{"_id":"themes/icarus/layout/donate/alipay.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/donate/patreon.ejs","hash":"8e52a9c28ffaf4b0b786a20977b848c5f60f2274","modified":1575291969570},{"_id":"themes/icarus/layout/donate/patreon.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"52f54b4ba88253ad0ec13d3b40fa4232e691af57","modified":1575291969570},{"_id":"themes/icarus/layout/donate/paypal.ejs","hash":"3975dee39f9378975b9c10f37d118ad7cb6f5bf6","modified":1575291969570},{"_id":"themes/icarus/layout/donate/paypal.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/donate/wechat.ejs","hash":"051b873e1fc28c1d7c2d6443991b6a2f43813e6b","modified":1575291969570},{"_id":"themes/icarus/layout/donate/wechat.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/animejs.ejs","hash":"c17ea2cfe5cb239342166e2ba72cbfc663c8160f","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/animejs.locals.js","hash":"3bf911060a222f00b03be708c37f20e36cb66ba9","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/back-to-top.ejs","hash":"5936b5fd2f2444605a21c6c422623f07f02d5c9a","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/back-to-top.locals.js","hash":"3bf911060a222f00b03be708c37f20e36cb66ba9","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"7dbbea5722277e00a624c1796ec83d5f9c12d059","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/baidu-analytics.locals.js","hash":"c02eb152e6aff05833006e6edd32b74c1c4258c3","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/busuanzi.ejs","hash":"4285b0ae608c7c54e4ecbebb6d22d4cd1be28f70","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/busuanzi.locals.js","hash":"ec80bcfa4c1302c04130a746df4b1298d117de0b","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/gallery.ejs","hash":"7d19b7a5713d08a614578f079f1327a651c472ae","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/gallery.locals.js","hash":"037fb56dffc128d3a91c1cb8852998d9539d3fac","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"13b298b0026bfc7bcb6a47b6c795fe15cc4584fc","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/google-analytics.locals.js","hash":"c02eb152e6aff05833006e6edd32b74c1c4258c3","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/hotjar.ejs","hash":"6df0d8f77ed39e4d32c78177844115e31bf3a776","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/hotjar.locals.js","hash":"9258fc2af057d2545a43fae54790743b63450378","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/mathjax.ejs","hash":"dddb6f37487286fe2080118bcbb4a8d82dc84d5e","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/mathjax.locals.js","hash":"7faa26fa6da6a93dc3f7fdcf5a784d1f8825b031","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/outdated-browser.ejs","hash":"1437d1ac085a8110e61317254f6c0a034121bc39","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/outdated-browser.locals.js","hash":"037fb56dffc128d3a91c1cb8852998d9539d3fac","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/progressbar.ejs","hash":"34423f74787cc9d67b2598dd69b07c84d5bf2280","modified":1575291969570},{"_id":"themes/icarus/layout/plugin/progressbar.locals.js","hash":"ec80bcfa4c1302c04130a746df4b1298d117de0b","modified":1575291969570},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"850aa91778100d693a52b10eaa8586c8e3215ee6","modified":1575291969570},{"_id":"themes/icarus/layout/search/baidu.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/search/google-cse.ejs","hash":"4b881a99325a6a0cebf97ac53e09d8fc67f87d29","modified":1575291969570},{"_id":"themes/icarus/layout/search/google-cse.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"9a27db2a007582ceee7ca4b1eebddbd456893568","modified":1575291969570},{"_id":"themes/icarus/layout/search/insight.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969570},{"_id":"themes/icarus/layout/share/addthis.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969574},{"_id":"themes/icarus/layout/share/addthis.ejs","hash":"f1c5f337333009d5f00dfbac4864a16ef8f9cb8d","modified":1575291969574},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"95d3bc1a841bd934b1ae9209ad1af74e743ecb10","modified":1575291969574},{"_id":"themes/icarus/layout/share/addtoany.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969574},{"_id":"themes/icarus/layout/share/bdshare.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969574},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"f14c8084b7ee16a091f0bd2ae9039e3bfff7e7b7","modified":1575291969574},{"_id":"themes/icarus/layout/share/sharejs.ejs","hash":"65d08316cc479910ea4f526cd1c299d0104daf7f","modified":1575291969574},{"_id":"themes/icarus/layout/share/sharejs.locals.js","hash":"11976fd4cfed1044be29b476b34c33175c9b4308","modified":1575291969574},{"_id":"themes/icarus/layout/share/sharethis.ejs","hash":"4f2c40f790f3be0a4e79db04f02ea41ba2f4d4c0","modified":1575291969574},{"_id":"themes/icarus/layout/share/sharethis.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969574},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"eb738a2ac2935ce7a542964d90088613b281dd15","modified":1575291969574},{"_id":"themes/icarus/layout/widget/archive.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969574},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"17e58e537645c4434a1140377ae3e7f43cca4927","modified":1575291969574},{"_id":"themes/icarus/layout/widget/category.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969574},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"c18dab874af84147349a596d9e713f8e0ee5e17e","modified":1575291969574},{"_id":"themes/icarus/layout/widget/links.locals.js","hash":"872cf1a18e152361f5739c6d5fecc0bf46d59513","modified":1575291969574},{"_id":"themes/icarus/layout/widget/profile.ejs","hash":"14f024e8da3cbaaa55f9ae9706de664c3f9b7dd8","modified":1575291969574},{"_id":"themes/icarus/layout/widget/profile.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1575291969574},{"_id":"themes/icarus/layout/widget/recent_posts.locals.js","hash":"5065aca74ec2c98ec88994636fee8408f769c5f2","modified":1575291969574},{"_id":"themes/icarus/layout/widget/subscribe_email.ejs","hash":"391622e9c1d17bf79180faa617ed8c1ee1871a87","modified":1575291969574},{"_id":"themes/icarus/layout/widget/subscribe_email.locals.js","hash":"aae87fbdb7a1245a0fc0637225a935fc39836916","modified":1575291969574},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"e41aff420cc4ea1c454de49bd8af0e7a93f3db3f","modified":1575291969574},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"26fa17afaf0cb345a213816c44c39575a66759ba","modified":1575291969574},{"_id":"themes/icarus/layout/widget/tagcloud.locals.js","hash":"093f59d2f43e7ffa47bee79da15f98705300dfba","modified":1575291969574},{"_id":"themes/icarus/layout/widget/toc.ejs","hash":"e800b4b38eab716882389a09527e9f59a189dea6","modified":1575291969574},{"_id":"themes/icarus/layout/widget/toc.locals.js","hash":"e730a7fff2717f17741540e5ed77b89e289fdeab","modified":1575291969574},{"_id":"themes/icarus/source/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1575291969574},{"_id":"themes/icarus/source/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1575291969574},{"_id":"themes/icarus/source/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1575291969574},{"_id":"themes/icarus/source/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1575291969574},{"_id":"themes/icarus/source/css/style.styl","hash":"1c4fa31437c7e499f4bcf0b4fa7da9c2d16eeea7","modified":1575291969574},{"_id":"themes/icarus/source/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1575291969574},{"_id":"themes/icarus/source/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1575291969574},{"_id":"themes/icarus/source/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1575291969574},{"_id":"themes/icarus/source/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1575291969574},{"_id":"themes/icarus/source/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1575291969574},{"_id":"themes/icarus/source/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1575291969574},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"b778eb07c990898d4e5b3304ffe25cd9f98c03d3","modified":1577890718116},{"_id":"themes/icarus/source/js/gallery.js","hash":"bb74e694457dc23b83ac80cf5aadcd26b60469fd","modified":1575291969574},{"_id":"themes/icarus/source/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1575291969574},{"_id":"themes/icarus/source/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1575291969574},{"_id":"themes/icarus/source/js/main.js","hash":"faee41896e7bb3373ba5032b82d0b21a0321cea5","modified":1575291969574},{"_id":"themes/icarus/source/images/head.jpeg","hash":"cde129a4ffe9fcee8b1c161c7ee68cc811fd2dc3","modified":1568187606000},{"_id":"themes/icarus/.git/refs/heads/master","hash":"4fd3c8c3e2abce5ec41454edfe4fe95c4074ff9b","modified":1575291969546},{"_id":"themes/icarus/.git/objects/pack/pack-6fe94ac95223ad796d51f37f6033f5b4b7243782.idx","hash":"b1dc80095f1f7135ef92d597ce129dd58b7099f9","modified":1575291969466},{"_id":"themes/icarus/.git/logs/refs/heads/master","hash":"621958f34110b5f51808b89ebfc532f192c05e6d","modified":1575291969546},{"_id":"themes/icarus/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1575291969546},{"_id":"themes/icarus/.git/logs/refs/remotes/origin/HEAD","hash":"621958f34110b5f51808b89ebfc532f192c05e6d","modified":1575291969546},{"_id":"themes/icarus/.git/objects/pack/pack-6fe94ac95223ad796d51f37f6033f5b4b7243782.pack","hash":"685c7a4b6bc0054550ecd1dcbab3a5a86073c2af","modified":1575291969462},{"_id":"public/search.xml","hash":"a99eabeb139d1b9fb340dfebd8a5c6e9d22a3242","modified":1584622792461},{"_id":"public/content.json","hash":"802b13e7a8de7c11ab825dc9bc6ed0c4849f21e8","modified":1584622792461},{"_id":"public/about/index.html","hash":"5257b362c7462ef33e6c519104d46b0cda40feef","modified":1584622792461},{"_id":"public/2020/03/11/阿里巴巴淘宝互动平台实习生面试/index.html","hash":"403b7645872ccebba6e73ee6610caf683201ac5c","modified":1584622792461},{"_id":"public/2020/03/06/阿里巴巴支付宝面试/index.html","hash":"8b61a9552a6cd221c353354f7cbac8127352c3de","modified":1584622792461},{"_id":"public/2020/03/13/腾讯pcg实习面试/index.html","hash":"128c419c31084e33220bf0c5a3cf112b80cbac2e","modified":1584622792461},{"_id":"public/2020/03/10/准备找暑期实习，至此时大约一个月/index.html","hash":"492d9b5a7fcbdc908be9e471b03e26fb931060de","modified":1584622792461},{"_id":"public/2020/03/03/阿里巴巴ihome团队面试/index.html","hash":"a90981d6bef594a713ccf1e1b28a3eabaf9a5283","modified":1584622792461},{"_id":"public/2020/02/24/用户增长部提前批面经/index.html","hash":"59e0857dea80c1cd4cef8b43b8859cca4b6c912f","modified":1584622792461},{"_id":"public/2020/02/28/2020-2-28-淘系技术部一面/index.html","hash":"7fca779978cd0ee06bb63f638cde96ae803cb031","modified":1584622792461},{"_id":"public/2020/02/29/阿里巴巴钉钉面试/index.html","hash":"c9467be8edd557bdc18b8682cacb2ebddad47feb","modified":1584622792461},{"_id":"public/2020/01/30/Java容器/index.html","hash":"15002d264da51783614f91474ed52e3a30a746d6","modified":1584622792461},{"_id":"public/2020/02/09/解决TIME-WAIT过多的问题/index.html","hash":"968cf644348edd0ca0406d4812b7535c228b826e","modified":1584622792461},{"_id":"public/2020/01/06/数据库行级锁/index.html","hash":"8c479269f05eceea40a19da8755f4eb3e26f716f","modified":1584622792461},{"_id":"public/2019/12/27/TCP状态问题/index.html","hash":"75765b073e336a519153bd5d8ccbc9af1d9d2ebe","modified":1584622792461},{"_id":"public/2019/12/21/2019年终总结/index.html","hash":"8282ac3fdcb0ecbd4c0dbdce2cc88a37d1e08c79","modified":1584622792461},{"_id":"public/2019/12/05/gc/index.html","hash":"d9f568233e9aa2e2ed9314153b6df15650c47507","modified":1584622792461},{"_id":"public/2019/12/04/java内存分配/index.html","hash":"578182dd910b8604a12d643ee6e36f7ca8b63f73","modified":1584622792461},{"_id":"public/2019/12/02/双亲委派模型类加载器问题/index.html","hash":"8ec271b12982c51d8a4681cc945a0fbd991a9230","modified":1584622792461},{"_id":"public/2019/11/27/2019-11-27-CommandPattern/index.html","hash":"40cd31a13a900ceaf2017d850ab522a14bed3d17","modified":1584622792461},{"_id":"public/2019/11/26/2019-11-26-iqiyi/index.html","hash":"da08e190cf1e6cfbd43ab5d39f8e92122df52017","modified":1584622792461},{"_id":"public/2019/01/26/2019-01-26-DesignPattern/index.html","hash":"f2d06d1383f5b3c931d796a810f8fcb57a66fe45","modified":1584622792461},{"_id":"public/2019/01/16/2019-01-16-ThinkInJava/index.html","hash":"e162c6a4e6d806eeb89e6b97506974ca4e07963b","modified":1584622792461},{"_id":"public/2019/01/16/2019-01-16-leetcode/index.html","hash":"43116a4500e6ff105ac52bc5492d38d17e539562","modified":1584622792461},{"_id":"public/2018/11/14/2018-11-14-springbootblog/index.html","hash":"cdaedd49cf357a3922c2fb9d60151672d6d1c198","modified":1584622792461},{"_id":"public/2018/09/22/2018-09-22-ImplementQueueusinggStacks/index.html","hash":"056638649c1c2b95a6856e3b1a4e41dabbeb2f58","modified":1584622792461},{"_id":"public/2018/09/22/2018-09-22-toutiaomianshibuqu/index.html","hash":"922a0ab8f9f97773881850115fcd2a2a8fe2456e","modified":1584622792461},{"_id":"public/2018/09/21/2018-09-21-sougoumianshi/index.html","hash":"9aeec1bc186b3eabdbceaf71d05667b2e197f408","modified":1584622792461},{"_id":"public/2018/09/20/2018-09-20-MedianofTwoSortedArrays/index.html","hash":"6cba9f567f45ee9ca3c3147b8a9d5bf3d1ed72ee","modified":1584622792461},{"_id":"public/2018/09/18/2018-09-18-LongestSubstringWithoutRepeatingCharacters/index.html","hash":"629b0d5328c14e93a54fe28b8cf13e6ebb0d8263","modified":1584622792461},{"_id":"public/2018/09/17/2018-09-17-ValidParentheses/index.html","hash":"3d87efa2ad7cabc7305ebee082454713be020855","modified":1584622792461},{"_id":"public/2018/05/18/2018-05-18-create-vpn/index.html","hash":"eeaf4a0efea31c8244df21c9b90feff9f781498a","modified":1584622792461},{"_id":"public/2018/05/16/2018-05-16-firstblog/index.html","hash":"6b6763bbeb63d8db7fed0bbc4fedd51661955382","modified":1584622792461},{"_id":"public/index.html","hash":"b2fdb0f666fab2cc2f0a82ecd07f66d3e22825cf","modified":1584622792461},{"_id":"public/page/2/index.html","hash":"5efe74ef4f76f7e9691b834f15275ee4b74d738c","modified":1584622792461},{"_id":"public/2020/02/17/暑期实习面试准备/index.html","hash":"f9799d0a28192cba0978e49495221ca911645559","modified":1584622792461},{"_id":"public/2020/02/15/数据库事务/index.html","hash":"f3637c1900829f263ce3e37e5b6009982352116c","modified":1584622792461},{"_id":"public/archives/index.html","hash":"213d794fe03ef2d0eafa259d5eda0517be615dbe","modified":1584622792461},{"_id":"public/archives/page/2/index.html","hash":"bec62c20ceec5ceb73e9c17ec094732dc52648fd","modified":1584622792461},{"_id":"public/page/3/index.html","hash":"f1891d63a672f039560ef9e0c68b725210d21540","modified":1584622792461},{"_id":"public/archives/page/3/index.html","hash":"bebf0acc425123892c0a06b4a4cef7665abb7b5d","modified":1584622792461},{"_id":"public/archives/2018/index.html","hash":"c82c20bf94c31d376608b2ed3145098ecbdde404","modified":1584622792461},{"_id":"public/archives/2018/05/index.html","hash":"98e9c1809c1f308a79ef010d39618de7e18ba4cf","modified":1584622792461},{"_id":"public/archives/2018/09/index.html","hash":"f1bab088eee357284f8bfc9dcf0ae5ed9ad9d162","modified":1584622792461},{"_id":"public/archives/2018/11/index.html","hash":"d4ca4aaca9d4a6beb04a31fb710bd33d060bf777","modified":1584622792461},{"_id":"public/archives/2019/index.html","hash":"daec17193a8542f7eb7e306e1ca6da1aba4ce600","modified":1584622792461},{"_id":"public/2019/12/30/Java数据类型/index.html","hash":"4d6f147978b4627dda8a1b33547d3c840fbdab21","modified":1584622792461},{"_id":"public/archives/2019/01/index.html","hash":"813bbc16c88beb5ba198b634184c70832a66e604","modified":1584622792461},{"_id":"public/archives/2019/11/index.html","hash":"6a81af46f3a3931f2e4b5f2755a8f78dfe1a2467","modified":1584622792461},{"_id":"public/archives/2019/12/index.html","hash":"42bbf80c847900a3ccd7f68c0e46184ac69fc2b5","modified":1584622792461},{"_id":"public/page/4/index.html","hash":"a6ad873db0bb67afba1520eae520492cbea86270","modified":1584622792461},{"_id":"public/archives/page/4/index.html","hash":"70c6d6b945d1d21e261e4aea1692fa64f650ce7a","modified":1584622792461},{"_id":"public/archives/2019/page/2/index.html","hash":"a87cc48bf0d8fa5e9e1367dcfab07298358702fa","modified":1584622792461},{"_id":"public/archives/2020/index.html","hash":"1a13c30c9c823a21c8045fe4e795d88ffe5e1e1e","modified":1584622792461},{"_id":"public/archives/2020/01/index.html","hash":"fd27ca9eff85580f59396f7ff8fc9664ae1253f4","modified":1584622792461},{"_id":"public/tags/learning/index.html","hash":"548c4e963e522b69e67c4a0288b6455ac8389d74","modified":1584622792461},{"_id":"public/tags/learning-set/index.html","hash":"ee62be21fa5f13b06b6d50c7cc146b5779aebd9e","modified":1584622792461},{"_id":"public/tags/learning-Array/index.html","hash":"83ed343482fba926772c77281125a85be16e2ad3","modified":1584622792461},{"_id":"public/tags/interview/index.html","hash":"4c701c7f461813da8a505118de762429879672cb","modified":1584622792461},{"_id":"public/tags/stack/index.html","hash":"87736aa7a11561321bad18be9c19af95f9983f5e","modified":1584622792461},{"_id":"public/tags/springboot/index.html","hash":"9bd61676bec5e790cfe86ff78182e2b06bec06b4","modified":1584622792461},{"_id":"public/archives/2020/02/index.html","hash":"21a1b73bd783aaad92023182a9a6e6ccef103d78","modified":1584622792461},{"_id":"public/tags/TCP/index.html","hash":"1c76bdd98ff1c4eb0f5cd3a4973f8dfa2d58c852","modified":1584622792461},{"_id":"public/archives/2020/page/2/index.html","hash":"4a8aa6234e642cdcadd8b0d6dc2c67ef1d2953b5","modified":1584622792461},{"_id":"public/2020/03/19/美团到店saas业务面试/index.html","hash":"287735a512b2480973fbc6f9969b1d9d1ce5bf6d","modified":1584622792461},{"_id":"public/tags/alibaba/index.html","hash":"09f3c9bf6eebcf43d3e4e5b58ddde86a0cb1caa2","modified":1584622792461},{"_id":"public/tags/Java/index.html","hash":"4678b4b431a342599cb2457ef55c7396286d6408","modified":1584622792461},{"_id":"public/categories/learning/index.html","hash":"c2d296d132c0299e5f8ce6c409bd9ce9776adcae","modified":1584622792461},{"_id":"public/categories/leetcode/index.html","hash":"62f12cccf528a20cba8be2c49098f3ad36a8583c","modified":1584622792461},{"_id":"public/categories/note/index.html","hash":"dd14c665ff522f2280476d2204e52c9bb2be6de7","modified":1584622792461},{"_id":"public/tags/mysql/index.html","hash":"2c0b04aa3b8d45e094526a21c66cfa519f6397d1","modified":1584622792461},{"_id":"public/categories/读书/index.html","hash":"e30b6a166408748bdedb62367e79d39529fcc2c7","modified":1584622792461},{"_id":"public/categories/网络/index.html","hash":"43f69185538dbe3e4bf8fb5513f9316829a24eac","modified":1584622792461},{"_id":"public/categories/程序人生/index.html","hash":"0561432b41b93b558afe8a9001d6061d5476f9f3","modified":1584622792461},{"_id":"public/archives/2020/03/index.html","hash":"22253c934c6932e17d1d9afb462b9fb107869f24","modified":1584622792461},{"_id":"public/categories/设计模式/index.html","hash":"07a5b1cc5f28bf1ecebe7a6dc3ae85df1efa1036","modified":1584622792461},{"_id":"public/categories/数据库/index.html","hash":"160d00bbbeda3f0fecdd2e11bb7857983e5641a5","modified":1584622792461},{"_id":"public/categories/index.html","hash":"dfe269f9a8af489edc4de1c0d1ae820c93aa4a25","modified":1584622792461},{"_id":"public/tags/index.html","hash":"430642903585566a803c686fe4f76d436439622d","modified":1584622792461},{"_id":"public/categories/note/page/2/index.html","hash":"0fb50142c1a4cfdda9dae3260d1be49e508cf3b2","modified":1584622792461},{"_id":"public/tags/腾讯/index.html","hash":"2b315c689ef7041f70f170b4eca4ecc5fe4740f9","modified":1584622792461},{"_id":"public/categories/Java/index.html","hash":"0f4e6bb974f185191125f34a18ef7cdda442d0cd","modified":1584622792461},{"_id":"public/tags/美团/index.html","hash":"bc285cc0eaa43bcb3d63ded2656102db1318504c","modified":1584622792461},{"_id":"public/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1584622792461},{"_id":"public/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1584622792461},{"_id":"public/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1584622792461},{"_id":"public/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1584622792461},{"_id":"public/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1584622792461},{"_id":"public/live2dw/assets/exp/f02.exp.json","hash":"241b6afafa2e25c6d7a54692a8b5aa060a137ab1","modified":1584622792461},{"_id":"public/live2dw/assets/exp/f03.exp.json","hash":"fbf7729e504f14f83f976827fcf62301a6579a34","modified":1584622792461},{"_id":"public/live2dw/assets/exp/f01.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1584622792461},{"_id":"public/live2dw/assets/exp/f04.exp.json","hash":"35e746ede62e7090e7dfb08561d77772f58b4153","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/flickHead_00.mtn","hash":"f64c79c9171660db5c440bef229ac2e35a1597d5","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/flickHead_01.mtn","hash":"a1011d6bf397bcd3c3c968d9616f88fe1ffbc83c","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/idle_01.mtn","hash":"88c2494655dbb712b842f03232b619f381753d52","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/pinchIn_01.mtn","hash":"a5fefb45115695db72b9499e627a51b2b9394f2c","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/flickHead_02.mtn","hash":"d3c9c0acb4dc25a2274f3b9faa71e5ce60ad92e4","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/pinchOut_00.mtn","hash":"e07fe8fd8c2810e3c1d28b730bd49c8c25849bad","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/pinchIn_02.mtn","hash":"aa0d66ca9b06c374577fd7e64e89756de1e1f2ae","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/idle_02.mtn","hash":"7f5d2cf8706007c8659938eba132a68c470a4c26","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/pinchIn_00.mtn","hash":"70978b4c983f6a9fd6d3d9c24571586f7d6eac30","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/pinchOut_02.mtn","hash":"b323fd350d334b33bbdfb31194ae664089986c27","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/pinchOut_01.mtn","hash":"e05df948d08b17f34c993a9c1f901190509d5db0","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/shake_00.mtn","hash":"5185d02c7ab9f0bec3d4a890b54b2378e553373d","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/shake_01.mtn","hash":"e812985a56796e122018f9d57d1606a4866ff7d1","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/shake_02.mtn","hash":"2702970805e07777974c383613e631730982bcff","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/tapBody_00.mtn","hash":"835aa3d4a8fbd26c0bb66b164a19464fa3f17a99","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/tapBody_01.mtn","hash":"78fca17436ab5e065e27f419f135aa6c0a0b52ef","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/tapBody_02.mtn","hash":"a75acb51c1191ce5050d3ee1af6f2dcc787c7c5e","modified":1584622792461},{"_id":"public/live2dw/assets/shizuku.model.json","hash":"19a05bd41b806a935cea42c2000626fc82da2536","modified":1584622792461},{"_id":"public/live2dw/assets/shizuku.physics.json","hash":"6484d646e79a44c83784c6ae434cf7349746c5c8","modified":1584622792461},{"_id":"public/live2dw/assets/shizuku.pose.json","hash":"ac5505efbf80ba0a2e5783d67fe232bc5c6f1f80","modified":1584622792461},{"_id":"public/live2dw/assets/mtn/idle_00.mtn","hash":"378b4577217c604c9d28ab4edf8b707c8d8c2fbb","modified":1584622792461},{"_id":"public/live2dw/assets/snd/flickHead_00.mp3","hash":"356388d939006b03cf9e6158c603b58d4800bec1","modified":1584622792461},{"_id":"public/live2dw/assets/snd/flickHead_01.mp3","hash":"436d0bbccf6e7a2744447554947eee4563608970","modified":1584622792461},{"_id":"public/live2dw/assets/snd/pinchIn_01.mp3","hash":"d5c8cc6f61b56222a83a5174f75006f83c3b88da","modified":1584622792461},{"_id":"public/live2dw/assets/snd/flickHead_02.mp3","hash":"5f63477ce63f2073e24d68fea906fe136fe6349e","modified":1584622792461},{"_id":"public/live2dw/assets/snd/shake_00.mp3","hash":"f65dd58e7b44ec5c865d13c190316070b625b5fe","modified":1584622792461},{"_id":"public/live2dw/assets/snd/shake_01.mp3","hash":"c1e0e8a07ff268ee06c2b7825d1b645e193f21b9","modified":1584622792461},{"_id":"public/live2dw/assets/snd/shake_02.mp3","hash":"8882b94bce00f09232588b7301badb105fa8acab","modified":1584622792461},{"_id":"public/live2dw/assets/snd/tapBody_00.mp3","hash":"003e68a59a9c8392e230f34c91860efbd946277a","modified":1584622792461},{"_id":"public/live2dw/assets/snd/tapBody_01.mp3","hash":"5314b50f153df71559e51e2586581c006df00722","modified":1584622792461},{"_id":"public/live2dw/assets/snd/tapBody_02.mp3","hash":"15e7815ed0a0e5164e18e0c53b97aedc742a134d","modified":1584622792461},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1584622792461},{"_id":"public/live2dw/assets/snd/pinchIn_00.mp3","hash":"f9baa3b7cadec20b714135fc49cfab3ff6adeeb4","modified":1584622792461},{"_id":"public/images/head.jpeg","hash":"cde129a4ffe9fcee8b1c161c7ee68cc811fd2dc3","modified":1584622792461},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_00.png","hash":"21bdb28b31783e23b26b3aa061e90be4088665aa","modified":1584622792461},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_05.png","hash":"0cd00007fb8bff62a2eb08e1d7c43abab8722224","modified":1584622792461},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_03.png","hash":"07f568a2bb8045b6bdff7783fb4daf62c821f9ab","modified":1584622792461},{"_id":"public/live2dw/assets/snd/pinchOut_00.mp3","hash":"0654f38f6e9fd623eaf8be11b5d58c9d12991949","modified":1584622792461},{"_id":"public/live2dw/assets/snd/pinchIn_02.mp3","hash":"5b63e02607571ac601c500995e836e6c861b1c62","modified":1584622792461},{"_id":"public/live2dw/assets/snd/pinchOut_01.mp3","hash":"8a081030fd53c07bffe3edd48f87a371ca77296b","modified":1584622792461},{"_id":"public/live2dw/assets/snd/pinchOut_02.mp3","hash":"554edb2f3838cbdc27d1a9c6b8a9cb6eb465cbdd","modified":1584622792461},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1584622792461},{"_id":"public/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1584622792461},{"_id":"public/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1584622792461},{"_id":"public/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1584622792461},{"_id":"public/css/style.css","hash":"ce4b8320c2280b82e0d0c255cfbbe31fd8a0c264","modified":1584622792461},{"_id":"public/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1584622792461},{"_id":"public/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1584622792461},{"_id":"public/js/gallery.js","hash":"bb74e694457dc23b83ac80cf5aadcd26b60469fd","modified":1584622792461},{"_id":"public/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1584622792461},{"_id":"public/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1584622792461},{"_id":"public/js/main.js","hash":"faee41896e7bb3373ba5032b82d0b21a0321cea5","modified":1584622792461},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_01.png","hash":"3d0e745f3e560071ee08beeecde186e5ea35d99e","modified":1584622792461},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_04.png","hash":"f764d594841905db8b2998dd61c329866125ad97","modified":1584622792461},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1584622792461},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_02.png","hash":"055eb2da9c13e9116be93a1e60c0ea2b660af864","modified":1584622792461},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1584622792461},{"_id":"public/live2dw/assets/moc/shizuku.moc","hash":"c2670a0f75830edc89d7fe6d074de4ee67e8dc5d","modified":1584622792461}],"Category":[{"name":"learning","_id":"ck7yrhz6400039oet2wab4zdt"},{"name":"leetcode","_id":"ck7yrhz6c00089oete16y18ne"},{"name":"note","_id":"ck7yrhz7400119oetglorev8e"},{"name":"读书","_id":"ck7yrhz7a00199oet4qx8an7y"},{"name":"网络","_id":"ck7yrhz7w001z9oet2jhhfc6m"},{"name":"程序人生","_id":"ck7yrhz8200289oetbst4dk82"},{"name":"Java","_id":"ck7yrhz86002g9oetafkc770r"},{"name":"设计模式","_id":"ck7yrhz8n003h9oetculbgp8z"},{"name":"数据库","_id":"ck7yrhz8o003k9oetht1cbihh"}],"Data":[],"Page":[{"title":"刘云尚","layout":"page","_content":"\n## 联系方式\n\n- Email：970090853@qq.com\n\n## 个人信息\n\n- **刘云尚**/男/1996\n- Github：https://github.com/csxiaoshang\n- 目前在北京，北京邮电大学\n","source":"about/index.md","raw":"title: \"刘云尚\"\nlayout: \"page\"\n---\n\n## 联系方式\n\n- Email：970090853@qq.com\n\n## 个人信息\n\n- **刘云尚**/男/1996\n- Github：https://github.com/csxiaoshang\n- 目前在北京，北京邮电大学\n","date":"2019-12-21T06:17:20.269Z","updated":"2019-12-21T06:17:20.209Z","path":"about/index.html","comments":1,"_id":"ck7yrhz5z00019oet7itq25g2","content":"<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>Email：<a href=\"mailto:970090853@qq.com\" target=\"_blank\" rel=\"noopener\">970090853@qq.com</a></li>\n</ul>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li><strong>刘云尚</strong>/男/1996</li>\n<li>Github：<a href=\"https://github.com/csxiaoshang\" target=\"_blank\" rel=\"noopener\">https://github.com/csxiaoshang</a></li>\n<li>目前在北京，北京邮电大学</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>Email：<a href=\"mailto:970090853@qq.com\" target=\"_blank\" rel=\"noopener\">970090853@qq.com</a></li>\n</ul>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li><strong>刘云尚</strong>/男/1996</li>\n<li>Github：<a href=\"https://github.com/csxiaoshang\" target=\"_blank\" rel=\"noopener\">https://github.com/csxiaoshang</a></li>\n<li>目前在北京，北京邮电大学</li>\n</ul>\n"}],"Post":[{"layout":"post","title":"my first blog","date":"2018-05-16T07:52:30.000Z","_content":"\n\n> 上网学习了一上午怎么用github搭建个人博客，找到了xudailong先生的博客，fork项目，拿来做了一下更改，算是初步完成了，表示感谢！\n","source":"_posts/2018-05-16-firstblog.md","raw":"---\nlayout: post\ntitle:  \"my first blog\"\ndate:   2018-05-16 15:52:30\ncategories: learning\ntags: learning\n---\n\n\n> 上网学习了一上午怎么用github搭建个人博客，找到了xudailong先生的博客，fork项目，拿来做了一下更改，算是初步完成了，表示感谢！\n","slug":"2018-05-16-firstblog","published":1,"updated":"2019-12-04T14:30:33.035Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz5f00009oetgxh9cvjq","content":"<blockquote>\n<p>上网学习了一上午怎么用github搭建个人博客，找到了xudailong先生的博客，fork项目，拿来做了一下更改，算是初步完成了，表示感谢！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>上网学习了一上午怎么用github搭建个人博客，找到了xudailong先生的博客，fork项目，拿来做了一下更改，算是初步完成了，表示感谢！</p>\n</blockquote>\n"},{"layout":"post","title":"3.Longest Substring Without Repeating Characters","date":"2018-09-18T05:12:20.000Z","_content":"\n\n\n## Question: Given a string, find the length of the longest substring without repeating characters.\n\n这道题两个循环遍历找最大的子串也可以，但是那样会慢一些，这里借助set的性质处理的这道题，感觉还可以用KMP算法，等回头做了再贴上来\n\n<!--more-->\n\n```java\n\tclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \tint len=s.length();\n\t\tint ans=0;\n\t\tSet<Character> se=new HashSet<Character>();\n\t\tfor(int i=0,j=0;j<len;) {\n\t\t\tif(!se.contains(s.charAt(j))) {\n\t\t\t\tse.add(s.charAt(j));\n\t\t\t\tj++;\n\t\t\t\tans=Math.max(ans, j-i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tse.remove(s.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n    }\n\t}\n```","source":"_posts/2018-09-18-LongestSubstringWithoutRepeatingCharacters.md","raw":"---\nlayout: post\ntitle:  \"3.Longest Substring Without Repeating Characters\"\ndate:   2018-09-18 13:12:20\ncategories: leetcode\ntags: learning set\n---\n\n\n\n## Question: Given a string, find the length of the longest substring without repeating characters.\n\n这道题两个循环遍历找最大的子串也可以，但是那样会慢一些，这里借助set的性质处理的这道题，感觉还可以用KMP算法，等回头做了再贴上来\n\n<!--more-->\n\n```java\n\tclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \tint len=s.length();\n\t\tint ans=0;\n\t\tSet<Character> se=new HashSet<Character>();\n\t\tfor(int i=0,j=0;j<len;) {\n\t\t\tif(!se.contains(s.charAt(j))) {\n\t\t\t\tse.add(s.charAt(j));\n\t\t\t\tj++;\n\t\t\t\tans=Math.max(ans, j-i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tse.remove(s.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n    }\n\t}\n```","slug":"2018-09-18-LongestSubstringWithoutRepeatingCharacters","published":1,"updated":"2019-12-04T14:30:33.319Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6100029oetfu374bkr","content":"<h2 id=\"Question-Given-a-string-find-the-length-of-the-longest-substring-without-repeating-characters\"><a href=\"#Question-Given-a-string-find-the-length-of-the-longest-substring-without-repeating-characters\" class=\"headerlink\" title=\"Question: Given a string, find the length of the longest substring without repeating characters.\"></a>Question: Given a string, find the length of the longest substring without repeating characters.</h2><p>这道题两个循环遍历找最大的子串也可以，但是那样会慢一些，这里借助set的性质处理的这道题，感觉还可以用KMP算法，等回头做了再贴上来</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">lengthOfLongestSubstring</span><span class=\"hljs-params\">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">       \t<span class=\"hljs-keyword\">int</span> len=s.length();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-number\">0</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tSet&lt;Character&gt; se=<span class=\"hljs-keyword\">new</span> HashSet&lt;Character&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>,j=<span class=\"hljs-number\">0</span>;j&lt;len;) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span>(!se.contains(s.charAt(j))) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tse.add(s.charAt(j));</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tj++;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tans=Math.max(ans, j-i);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">else</span> &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tse.remove(s.charAt(i));</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\ti++;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> ans;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">   &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Question-Given-a-string-find-the-length-of-the-longest-substring-without-repeating-characters\"><a href=\"#Question-Given-a-string-find-the-length-of-the-longest-substring-without-repeating-characters\" class=\"headerlink\" title=\"Question: Given a string, find the length of the longest substring without repeating characters.\"></a>Question: Given a string, find the length of the longest substring without repeating characters.</h2><p>这道题两个循环遍历找最大的子串也可以，但是那样会慢一些，这里借助set的性质处理的这道题，感觉还可以用KMP算法，等回头做了再贴上来</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">       \t<span class=\"keyword\">int</span> len=s.length();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tSet&lt;Character&gt; se=<span class=\"keyword\">new</span> HashSet&lt;Character&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;j&lt;len;) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!se.contains(s.charAt(j))) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tse.add(s.charAt(j));</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tj++;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tans=Math.max(ans, j-i);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tse.remove(s.charAt(i));</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\ti++;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">   &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>"},{"layout":"post","title":"搭一个自己的vpn","date":"2018-05-18T02:31:20.000Z","_content":"\n\n> 寻思自己搭建一个VPN留着用来翻墙学习游戏，了解到可以使用shadowsocks，再租一个国外的服务器搭好环境基本就可以使用了\n\n<!--more-->\n\n[参考博客](https://www.yigeni.com/build-a-wall-ss-server/)\n\n[参考博客2脚本搭建ss](https://www.flyzy2005.com/fan-qiang/shadowsocks/install-shadowsocks-in-one-command/)\n\n[服务器网址](https://my.vultr.com)\n\n> 当然现在还没有搭 >_<！\n","source":"_posts/2018-05-18-create-vpn.md","raw":"---\nlayout: post\ntitle:  \"搭一个自己的vpn\"\ndate:   2018-05-18 10:31:20\ncategories: learning\ntags: learning\n---\n\n\n> 寻思自己搭建一个VPN留着用来翻墙学习游戏，了解到可以使用shadowsocks，再租一个国外的服务器搭好环境基本就可以使用了\n\n<!--more-->\n\n[参考博客](https://www.yigeni.com/build-a-wall-ss-server/)\n\n[参考博客2脚本搭建ss](https://www.flyzy2005.com/fan-qiang/shadowsocks/install-shadowsocks-in-one-command/)\n\n[服务器网址](https://my.vultr.com)\n\n> 当然现在还没有搭 >_<！\n","slug":"2018-05-18-create-vpn","published":1,"updated":"2019-12-04T14:30:33.351Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6800059oet8s1s7mst","content":"<blockquote>\n<p>寻思自己搭建一个VPN留着用来翻墙学习游戏，了解到可以使用shadowsocks，再租一个国外的服务器搭好环境基本就可以使用了</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p><a href=\"https://www.yigeni.com/build-a-wall-ss-server/\" target=\"_blank\" rel=\"noopener\">参考博客</a></p>\n<p><a href=\"https://www.flyzy2005.com/fan-qiang/shadowsocks/install-shadowsocks-in-one-command/\" target=\"_blank\" rel=\"noopener\">参考博客2脚本搭建ss</a></p>\n<p><a href=\"https://my.vultr.com\" target=\"_blank\" rel=\"noopener\">服务器网址</a></p>\n<blockquote>\n<p>当然现在还没有搭 &gt;_&lt;！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>寻思自己搭建一个VPN留着用来翻墙学习游戏，了解到可以使用shadowsocks，再租一个国外的服务器搭好环境基本就可以使用了</p>\n</blockquote>","more":"<p><a href=\"https://www.yigeni.com/build-a-wall-ss-server/\" target=\"_blank\" rel=\"noopener\">参考博客</a></p>\n<p><a href=\"https://www.flyzy2005.com/fan-qiang/shadowsocks/install-shadowsocks-in-one-command/\" target=\"_blank\" rel=\"noopener\">参考博客2脚本搭建ss</a></p>\n<p><a href=\"https://my.vultr.com\" target=\"_blank\" rel=\"noopener\">服务器网址</a></p>\n<blockquote>\n<p>当然现在还没有搭 &gt;_&lt;！</p>\n</blockquote>"},{"layout":"post","title":"20.Valid Parentheses","date":"2018-09-17T15:02:20.000Z","_content":"\n> 这是一道比较简单的堆栈题目，但是本人很少用java写程序做题，做题的过程中出了很多错误，也上网百度了下，算是完成了\n\n<!--more-->\n\n```java\nclass Solution {\n\tpublic boolean isValid(String s) {\n\t\tStack<Character> stack=new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tchar ch=s.charAt(i);\n\t\t\tswitch (ch) {\n\t\t\tcase '(':\n\t\t\tcase '[':\n\t\t\tcase '{':\n\t\t\t\tstack.push(ch);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tif((stack.isEmpty())||stack.peek()!='(')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\tstack.pop();\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tif((stack.isEmpty())||stack.peek()!='[')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\tstack.pop();\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tif((stack.isEmpty())||stack.peek()!='}')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\tstack.pop();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!stack.isEmpty())\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t}\n```","source":"_posts/2018-09-17-ValidParentheses.md","raw":"---\nlayout: post\ntitle:  \"20.Valid Parentheses\"\ndate:   2018-09-17 23:02:20\ncategories: leetcode\ntags: learning\n---\n\n> 这是一道比较简单的堆栈题目，但是本人很少用java写程序做题，做题的过程中出了很多错误，也上网百度了下，算是完成了\n\n<!--more-->\n\n```java\nclass Solution {\n\tpublic boolean isValid(String s) {\n\t\tStack<Character> stack=new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tchar ch=s.charAt(i);\n\t\t\tswitch (ch) {\n\t\t\tcase '(':\n\t\t\tcase '[':\n\t\t\tcase '{':\n\t\t\t\tstack.push(ch);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tif((stack.isEmpty())||stack.peek()!='(')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\tstack.pop();\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tif((stack.isEmpty())||stack.peek()!='[')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\tstack.pop();\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tif((stack.isEmpty())||stack.peek()!='}')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\tstack.pop();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!stack.isEmpty())\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t}\n```","slug":"2018-09-17-ValidParentheses","published":1,"updated":"2019-12-04T14:30:33.283Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6a00069oet0ps51e52","content":"<blockquote>\n<p>这是一道比较简单的堆栈题目，但是本人很少用java写程序做题，做题的过程中出了很多错误，也上网百度了下，算是完成了</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isValid</span><span class=\"hljs-params\">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tStack&lt;Character&gt; stack=<span class=\"hljs-keyword\">new</span> Stack&lt;Character&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.length();i++)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">char</span> ch=s.charAt(i);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">switch</span> (ch) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'('</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'['</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'&#123;'</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\tstack.push(ch);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">')'</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">if</span>((stack.isEmpty())||stack.peek()!=<span class=\"hljs-string\">'('</span>)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\tstack.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">']'</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">if</span>((stack.isEmpty())||stack.peek()!=<span class=\"hljs-string\">'['</span>)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\tstack.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'&#125;'</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">if</span>((stack.isEmpty())||stack.peek()!=<span class=\"hljs-string\">'&#125;'</span>)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">28</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\tstack.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">29</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">30</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">default</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">31</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">32</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">33</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">34</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span>(!stack.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">35</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">36</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">37</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">38</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>这是一道比较简单的堆栈题目，但是本人很少用java写程序做题，做题的过程中出了很多错误，也上网百度了下，算是完成了</p>\n</blockquote>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tStack&lt;Character&gt; stack=<span class=\"keyword\">new</span> Stack&lt;Character&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length();i++)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">char</span> ch=s.charAt(i);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (ch) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'('</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'['</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'&#123;'</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\tstack.push(ch);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">')'</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((stack.isEmpty())||stack.peek()!=<span class=\"string\">'('</span>)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\tstack.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">']'</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((stack.isEmpty())||stack.peek()!=<span class=\"string\">'['</span>)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\tstack.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'&#125;'</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((stack.isEmpty())||stack.peek()!=<span class=\"string\">'&#125;'</span>)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">28</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\tstack.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">29</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">30</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">31</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">32</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">33</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">34</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!stack.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">35</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">36</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">37</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">38</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr></table></figure>"},{"layout":"post","title":"4. Median of Two Sorted Arrays","date":"2018-09-20T02:04:36.000Z","_content":"\n\n\n## Question: There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.\n\n这道题比较简单，就是讲两个数组合并下然后排序，找中位数就可以了\n\n<!--more-->\n\n```java\nclass Solution {\n\tpublic static double findMedianSortedArrays(int[] nums1,int[] nums2) {\n\t\tint[] shuzu=Arrays.copyOf(nums1,nums1.length+nums2.length);\n\t\tSystem.arraycopy(nums2, 0, shuzu, nums1.length, nums2.length);\n\t\tArrays.sort(shuzu);\n\t\tint num=nums1.length+nums2.length;\n\t\tdouble count=0;\n\t\tif(num%2==0) {\n\t\t\t count=(double)(shuzu[num/2-1]+shuzu[num/2])/2;\n\t\t}else {\n\t\t\tcount=(double)shuzu[(num-1)/2];\n\t\t}\n\t\treturn count;\n\t}\n\t}\n```","source":"_posts/2018-09-20-MedianofTwoSortedArrays.md","raw":"---\nlayout: post\ntitle:  \"4. Median of Two Sorted Arrays\"\ndate:   2018-09-20 10:04:36\ncategories: leetcode\ntags: learning Array\n---\n\n\n\n## Question: There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.\n\n这道题比较简单，就是讲两个数组合并下然后排序，找中位数就可以了\n\n<!--more-->\n\n```java\nclass Solution {\n\tpublic static double findMedianSortedArrays(int[] nums1,int[] nums2) {\n\t\tint[] shuzu=Arrays.copyOf(nums1,nums1.length+nums2.length);\n\t\tSystem.arraycopy(nums2, 0, shuzu, nums1.length, nums2.length);\n\t\tArrays.sort(shuzu);\n\t\tint num=nums1.length+nums2.length;\n\t\tdouble count=0;\n\t\tif(num%2==0) {\n\t\t\t count=(double)(shuzu[num/2-1]+shuzu[num/2])/2;\n\t\t}else {\n\t\t\tcount=(double)shuzu[(num-1)/2];\n\t\t}\n\t\treturn count;\n\t}\n\t}\n```","slug":"2018-09-20-MedianofTwoSortedArrays","published":1,"updated":"2019-12-04T14:30:33.103Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6b00079oet5n5n9a1x","content":"<h2 id=\"Question-There-are-two-sorted-arrays-nums1-and-nums2-of-size-m-and-n-respectively-Find-the-median-of-the-two-sorted-arrays-The-overall-run-time-complexity-should-be-O-log-m-n-You-may-assume-nums1-and-nums2-cannot-be-both-empty\"><a href=\"#Question-There-are-two-sorted-arrays-nums1-and-nums2-of-size-m-and-n-respectively-Find-the-median-of-the-two-sorted-arrays-The-overall-run-time-complexity-should-be-O-log-m-n-You-may-assume-nums1-and-nums2-cannot-be-both-empty\" class=\"headerlink\" title=\"Question: There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.\"></a>Question: There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.</h2><p>这道题比较简单，就是讲两个数组合并下然后排序，找中位数就可以了</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">findMedianSortedArrays</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums1,<span class=\"hljs-keyword\">int</span>[] nums2)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">int</span>[] shuzu=Arrays.copyOf(nums1,nums1.length+nums2.length);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tSystem.arraycopy(nums2, <span class=\"hljs-number\">0</span>, shuzu, nums1.length, nums2.length);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tArrays.sort(shuzu);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">int</span> num=nums1.length+nums2.length;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">double</span> count=<span class=\"hljs-number\">0</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span>(num%<span class=\"hljs-number\">2</span>==<span class=\"hljs-number\">0</span>) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t count=(<span class=\"hljs-keyword\">double</span>)(shuzu[num/<span class=\"hljs-number\">2</span>-<span class=\"hljs-number\">1</span>]+shuzu[num/<span class=\"hljs-number\">2</span>])/<span class=\"hljs-number\">2</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;<span class=\"hljs-keyword\">else</span> &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tcount=(<span class=\"hljs-keyword\">double</span>)shuzu[(num-<span class=\"hljs-number\">1</span>)/<span class=\"hljs-number\">2</span>];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-keyword\">return</span> count;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Question-There-are-two-sorted-arrays-nums1-and-nums2-of-size-m-and-n-respectively-Find-the-median-of-the-two-sorted-arrays-The-overall-run-time-complexity-should-be-O-log-m-n-You-may-assume-nums1-and-nums2-cannot-be-both-empty\"><a href=\"#Question-There-are-two-sorted-arrays-nums1-and-nums2-of-size-m-and-n-respectively-Find-the-median-of-the-two-sorted-arrays-The-overall-run-time-complexity-should-be-O-log-m-n-You-may-assume-nums1-and-nums2-cannot-be-both-empty\" class=\"headerlink\" title=\"Question: There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.\"></a>Question: There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.</h2><p>这道题比较简单，就是讲两个数组合并下然后排序，找中位数就可以了</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1,<span class=\"keyword\">int</span>[] nums2)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] shuzu=Arrays.copyOf(nums1,nums1.length+nums2.length);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tSystem.arraycopy(nums2, <span class=\"number\">0</span>, shuzu, nums1.length, nums2.length);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tArrays.sort(shuzu);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">int</span> num=nums1.length+nums2.length;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">double</span> count=<span class=\"number\">0</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">if</span>(num%<span class=\"number\">2</span>==<span class=\"number\">0</span>) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t count=(<span class=\"keyword\">double</span>)(shuzu[num/<span class=\"number\">2</span>-<span class=\"number\">1</span>]+shuzu[num/<span class=\"number\">2</span>])/<span class=\"number\">2</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tcount=(<span class=\"keyword\">double</span>)shuzu[(num-<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"keyword\">return</span> count;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr></table></figure>"},{"layout":"post","title":"面试搜狗实习","date":"2018-09-21T09:34:36.000Z","_content":"\n\n\n### 面试搜狗的实习，估计凉了\n\n<!--more-->\n\n  之前没事投了几个简历，也记不清这次是 java 还是android的了，还有点不太想去。。\n  寻思了下还是过去吧，面试下还能增长下经验，了解下今后的学习方向。\n  过去后，先去了前台登记了下，等一会面试的人过来了，叫到一个屋子里面试。先给了我一份试题，一串代码关于继承和上转型的，有一些 activity的lanchmode啥的 sevice的生命周期啥的，不太会;后面是两道编程题，比较简单，一个是用链表实现堆栈的push pop peak，一个是查找字符串里第一个不重复的字符。自我介绍了下，聊了下项目，项目怎么实现的啥的，后来问了点java的多态啥的，有点忘了，面试中我想起来，这个投的应该是android，他说了一句话，看你做的东西应该是没有调用过一些android核心的api，应该是凉了。\n  \n  算是个经验，不会的东西还有很多，没事多刷刷leetcode，把java研究精通些。","source":"_posts/2018-09-21-sougoumianshi.md","raw":"---\nlayout: post\ntitle:  \"面试搜狗实习\"\ndate:   2018-09-21 17:34:36\ncategories: note\ntags: interview\n---\n\n\n\n### 面试搜狗的实习，估计凉了\n\n<!--more-->\n\n  之前没事投了几个简历，也记不清这次是 java 还是android的了，还有点不太想去。。\n  寻思了下还是过去吧，面试下还能增长下经验，了解下今后的学习方向。\n  过去后，先去了前台登记了下，等一会面试的人过来了，叫到一个屋子里面试。先给了我一份试题，一串代码关于继承和上转型的，有一些 activity的lanchmode啥的 sevice的生命周期啥的，不太会;后面是两道编程题，比较简单，一个是用链表实现堆栈的push pop peak，一个是查找字符串里第一个不重复的字符。自我介绍了下，聊了下项目，项目怎么实现的啥的，后来问了点java的多态啥的，有点忘了，面试中我想起来，这个投的应该是android，他说了一句话，看你做的东西应该是没有调用过一些android核心的api，应该是凉了。\n  \n  算是个经验，不会的东西还有很多，没事多刷刷leetcode，把java研究精通些。","slug":"2018-09-21-sougoumianshi","published":1,"updated":"2019-12-04T14:30:33.419Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6d000b9oet3gvo9x94","content":"<h3 id=\"面试搜狗的实习，估计凉了\"><a href=\"#面试搜狗的实习，估计凉了\" class=\"headerlink\" title=\"面试搜狗的实习，估计凉了\"></a>面试搜狗的实习，估计凉了</h3><a id=\"more\"></a>\n\n<p>  之前没事投了几个简历，也记不清这次是 java 还是android的了，还有点不太想去。。<br>  寻思了下还是过去吧，面试下还能增长下经验，了解下今后的学习方向。<br>  过去后，先去了前台登记了下，等一会面试的人过来了，叫到一个屋子里面试。先给了我一份试题，一串代码关于继承和上转型的，有一些 activity的lanchmode啥的 sevice的生命周期啥的，不太会;后面是两道编程题，比较简单，一个是用链表实现堆栈的push pop peak，一个是查找字符串里第一个不重复的字符。自我介绍了下，聊了下项目，项目怎么实现的啥的，后来问了点java的多态啥的，有点忘了，面试中我想起来，这个投的应该是android，他说了一句话，看你做的东西应该是没有调用过一些android核心的api，应该是凉了。</p>\n<p>  算是个经验，不会的东西还有很多，没事多刷刷leetcode，把java研究精通些。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"面试搜狗的实习，估计凉了\"><a href=\"#面试搜狗的实习，估计凉了\" class=\"headerlink\" title=\"面试搜狗的实习，估计凉了\"></a>面试搜狗的实习，估计凉了</h3>","more":"<p>  之前没事投了几个简历，也记不清这次是 java 还是android的了，还有点不太想去。。<br>  寻思了下还是过去吧，面试下还能增长下经验，了解下今后的学习方向。<br>  过去后，先去了前台登记了下，等一会面试的人过来了，叫到一个屋子里面试。先给了我一份试题，一串代码关于继承和上转型的，有一些 activity的lanchmode啥的 sevice的生命周期啥的，不太会;后面是两道编程题，比较简单，一个是用链表实现堆栈的push pop peak，一个是查找字符串里第一个不重复的字符。自我介绍了下，聊了下项目，项目怎么实现的啥的，后来问了点java的多态啥的，有点忘了，面试中我想起来，这个投的应该是android，他说了一句话，看你做的东西应该是没有调用过一些android核心的api，应该是凉了。</p>\n<p>  算是个经验，不会的东西还有很多，没事多刷刷leetcode，把java研究精通些。</p>"},{"layout":"post","title":"Java编程思想学习小结","date":"2019-01-16T02:47:30.000Z","_content":"\n\n# 这段时间学习了下Java编程思想\n> 之前做项目一些不懂的地方，通过这个看书找到很多答案，也知道不太会的问题应该去哪找了，感觉对自己很有帮助。\n<!--more-->\n> 这本书看的时候并没有完完全全详细的看完，看了一些重点章节 仍有很多不会的地方，后续还要通过博客学习完善，甚至得再看看书。最后，感觉这本书对于java学习的进阶很有帮助。\n","source":"_posts/2019-01-16-ThinkInJava.md","raw":"---\nlayout: post\ntitle:  \"Java编程思想学习小结\"\ndate:   2019-01-16 10:47:30\ncategories: 读书\ntags: learning\n---\n\n\n# 这段时间学习了下Java编程思想\n> 之前做项目一些不懂的地方，通过这个看书找到很多答案，也知道不太会的问题应该去哪找了，感觉对自己很有帮助。\n<!--more-->\n> 这本书看的时候并没有完完全全详细的看完，看了一些重点章节 仍有很多不会的地方，后续还要通过博客学习完善，甚至得再看看书。最后，感觉这本书对于java学习的进阶很有帮助。\n","slug":"2019-01-16-ThinkInJava","published":1,"updated":"2019-12-04T14:30:33.067Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6f000d9oetdghy3osg","content":"<h1 id=\"这段时间学习了下Java编程思想\"><a href=\"#这段时间学习了下Java编程思想\" class=\"headerlink\" title=\"这段时间学习了下Java编程思想\"></a>这段时间学习了下Java编程思想</h1><blockquote>\n<p>之前做项目一些不懂的地方，通过这个看书找到很多答案，也知道不太会的问题应该去哪找了，感觉对自己很有帮助。</p>\n</blockquote>\n<a id=\"more\"></a>\n<blockquote>\n<p>这本书看的时候并没有完完全全详细的看完，看了一些重点章节 仍有很多不会的地方，后续还要通过博客学习完善，甚至得再看看书。最后，感觉这本书对于java学习的进阶很有帮助。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"这段时间学习了下Java编程思想\"><a href=\"#这段时间学习了下Java编程思想\" class=\"headerlink\" title=\"这段时间学习了下Java编程思想\"></a>这段时间学习了下Java编程思想</h1><blockquote>\n<p>之前做项目一些不懂的地方，通过这个看书找到很多答案，也知道不太会的问题应该去哪找了，感觉对自己很有帮助。</p>\n</blockquote>","more":"<blockquote>\n<p>这本书看的时候并没有完完全全详细的看完，看了一些重点章节 仍有很多不会的地方，后续还要通过博客学习完善，甚至得再看看书。最后，感觉这本书对于java学习的进阶很有帮助。</p>\n</blockquote>"},{"layout":"post","title":"232. Implement Queue using Stacks","date":"2018-09-22T14:59:36.000Z","_content":"\n\n\n# Question: Implement the following operations of a queue using stacks.\n\n  用两个栈就可以实现一个队列的操作，注意判断栈是否为空\n  \n  <!--more-->\n  \n```java\n\tclass MyQueue {\n    /** Initialize your data structure here. */\n     Stack<Integer> stack1=new Stack<>();\n\tStack<Integer> stack2=new Stack<>();\n    public MyQueue() {\n       \n    }\n    \n    public void push(int x) {\n\t\t\twhile(!stack2.isEmpty())\n\t\t\t\tstack1.push(stack2.pop());\n\t\t\tstack1.push(x);\n\t\t}\n\t\tpublic int pop() {\n\t\t\twhile(!stack1.isEmpty())\n\t\t\t\tstack2.push(stack1.pop());\n\t\t\tint x=stack2.pop();\n\t\t\treturn x;\n\t\t}\n\t\tpublic int peek() {\n\t\t\twhile(!stack1.isEmpty())\n\t\t\t\tstack2.push(stack1.pop());\n\t\t\treturn stack2.peek();\n\t\t}\n\t\tpublic boolean empty() {\n\t\t\tif(stack1.isEmpty()&&stack2.isEmpty())\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n}\n```","source":"_posts/2018-09-22-ImplementQueueusinggStacks.md","raw":"---\nlayout: post\ntitle:  \"232. Implement Queue using Stacks\"\ndate:   2018-09-22 22:59:36\ncategories: leetcode\ntags: stack\n---\n\n\n\n# Question: Implement the following operations of a queue using stacks.\n\n  用两个栈就可以实现一个队列的操作，注意判断栈是否为空\n  \n  <!--more-->\n  \n```java\n\tclass MyQueue {\n    /** Initialize your data structure here. */\n     Stack<Integer> stack1=new Stack<>();\n\tStack<Integer> stack2=new Stack<>();\n    public MyQueue() {\n       \n    }\n    \n    public void push(int x) {\n\t\t\twhile(!stack2.isEmpty())\n\t\t\t\tstack1.push(stack2.pop());\n\t\t\tstack1.push(x);\n\t\t}\n\t\tpublic int pop() {\n\t\t\twhile(!stack1.isEmpty())\n\t\t\t\tstack2.push(stack1.pop());\n\t\t\tint x=stack2.pop();\n\t\t\treturn x;\n\t\t}\n\t\tpublic int peek() {\n\t\t\twhile(!stack1.isEmpty())\n\t\t\t\tstack2.push(stack1.pop());\n\t\t\treturn stack2.peek();\n\t\t}\n\t\tpublic boolean empty() {\n\t\t\tif(stack1.isEmpty()&&stack2.isEmpty())\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n}\n```","slug":"2018-09-22-ImplementQueueusinggStacks","published":1,"updated":"2019-12-04T14:30:33.247Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6j000h9oet0kj807ay","content":"<h1 id=\"Question-Implement-the-following-operations-of-a-queue-using-stacks\"><a href=\"#Question-Implement-the-following-operations-of-a-queue-using-stacks\" class=\"headerlink\" title=\"Question: Implement the following operations of a queue using stacks.\"></a>Question: Implement the following operations of a queue using stacks.</h1><p>  用两个栈就可以实现一个队列的操作，注意判断栈是否为空</p>\n  <a id=\"more\"></a>\n\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyQueue</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-comment\">/** Initialize your data structure here. */</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">     Stack&lt;Integer&gt; stack1=<span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tStack&lt;Integer&gt; stack2=<span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MyQueue</span><span class=\"hljs-params\">()</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">       </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">    </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">while</span>(!stack2.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\tstack1.push(stack2.pop());</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tstack1.push(x);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">while</span>(!stack1.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\tstack2.push(stack1.pop());</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">int</span> x=stack2.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">return</span> x;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">while</span>(!stack1.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\tstack2.push(stack1.pop());</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">return</span> stack2.peek();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">if</span>(stack1.isEmpty()&amp;&amp;stack2.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">28</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">29</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">30</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">31</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Question-Implement-the-following-operations-of-a-queue-using-stacks\"><a href=\"#Question-Implement-the-following-operations-of-a-queue-using-stacks\" class=\"headerlink\" title=\"Question: Implement the following operations of a queue using stacks.\"></a>Question: Implement the following operations of a queue using stacks.</h1><p>  用两个栈就可以实现一个队列的操作，注意判断栈是否为空</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">     Stack&lt;Integer&gt; stack1=<span class=\"keyword\">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tStack&lt;Integer&gt; stack2=<span class=\"keyword\">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">()</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">       </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">    </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(!stack2.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\tstack1.push(stack2.pop());</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\tstack1.push(x);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(!stack1.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\tstack2.push(stack1.pop());</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> x=stack2.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(!stack1.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\tstack2.push(stack1.pop());</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> stack2.peek();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stack1.isEmpty()&amp;&amp;stack2.isEmpty())</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">28</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">29</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">30</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">31</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>"},{"layout":"post","title":"大话设计模式学习小结","date":"2019-01-26T02:47:30.000Z","_content":"\n\n\n# 策略模式\n它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到算法的客户\n## 单一职责原则\n就一个类而言，应该只有一个引起它变化的原因\n## 开放封闭原则\n软件实体应该可以扩展，但是不可修改（增加新需求增加新代码）\n<!--more-->\n## 依赖倒转原则\n针对接口编程，不要对实现编程\n- 高层模块不应该依赖底层模块，两个都应该依赖抽象\n- 抽象不应该依赖细节，细节应该依赖抽象\n## 里氏代换原则\n一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。即在软件里面，把父类都替换成它的子类，程序的行为没有变化。\n*子类型必须能够替换掉它们的父类型*\n**通俗来讲，就是高层模块依赖接口，具体实现则是继承了此接口的实现类**\n\n# 装饰模式\n动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活\n\n# 代理模式\n为其他对象提供一种代理以控制对这个对象的访问\n# 工厂方法模式\n定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类\n# 原型模式\n用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象\n\n","source":"_posts/2019-01-26-DesignPattern.md","raw":"---\nlayout: post\ntitle:  \"大话设计模式学习小结\"\ndate:   2019-01-26 10:47:30\ncategories: 读书\ntags: learning\n---\n\n\n\n# 策略模式\n它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到算法的客户\n## 单一职责原则\n就一个类而言，应该只有一个引起它变化的原因\n## 开放封闭原则\n软件实体应该可以扩展，但是不可修改（增加新需求增加新代码）\n<!--more-->\n## 依赖倒转原则\n针对接口编程，不要对实现编程\n- 高层模块不应该依赖底层模块，两个都应该依赖抽象\n- 抽象不应该依赖细节，细节应该依赖抽象\n## 里氏代换原则\n一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。即在软件里面，把父类都替换成它的子类，程序的行为没有变化。\n*子类型必须能够替换掉它们的父类型*\n**通俗来讲，就是高层模块依赖接口，具体实现则是继承了此接口的实现类**\n\n# 装饰模式\n动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活\n\n# 代理模式\n为其他对象提供一种代理以控制对这个对象的访问\n# 工厂方法模式\n定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类\n# 原型模式\n用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象\n\n","slug":"2019-01-26-DesignPattern","published":1,"updated":"2019-12-04T14:30:33.135Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6l000j9oet37ca0zvs","content":"<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到算法的客户</p>\n<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><p>就一个类而言，应该只有一个引起它变化的原因</p>\n<h2 id=\"开放封闭原则\"><a href=\"#开放封闭原则\" class=\"headerlink\" title=\"开放封闭原则\"></a>开放封闭原则</h2><p>软件实体应该可以扩展，但是不可修改（增加新需求增加新代码）</p>\n<a id=\"more\"></a>\n<h2 id=\"依赖倒转原则\"><a href=\"#依赖倒转原则\" class=\"headerlink\" title=\"依赖倒转原则\"></a>依赖倒转原则</h2><p>针对接口编程，不要对实现编程</p>\n<ul>\n<li>高层模块不应该依赖底层模块，两个都应该依赖抽象</li>\n<li>抽象不应该依赖细节，细节应该依赖抽象<h2 id=\"里氏代换原则\"><a href=\"#里氏代换原则\" class=\"headerlink\" title=\"里氏代换原则\"></a>里氏代换原则</h2>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。即在软件里面，把父类都替换成它的子类，程序的行为没有变化。</li>\n</ul>\n<p><em>子类型必须能够替换掉它们的父类型</em><br><strong>通俗来讲，就是高层模块依赖接口，具体实现则是继承了此接口的实现类</strong></p>\n<h1 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h1><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>为其他对象提供一种代理以控制对这个对象的访问</p>\n<h1 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h1><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类</p>\n<h1 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h1><p>用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到算法的客户</p>\n<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><p>就一个类而言，应该只有一个引起它变化的原因</p>\n<h2 id=\"开放封闭原则\"><a href=\"#开放封闭原则\" class=\"headerlink\" title=\"开放封闭原则\"></a>开放封闭原则</h2><p>软件实体应该可以扩展，但是不可修改（增加新需求增加新代码）</p>","more":"<h2 id=\"依赖倒转原则\"><a href=\"#依赖倒转原则\" class=\"headerlink\" title=\"依赖倒转原则\"></a>依赖倒转原则</h2><p>针对接口编程，不要对实现编程</p>\n<ul>\n<li>高层模块不应该依赖底层模块，两个都应该依赖抽象</li>\n<li>抽象不应该依赖细节，细节应该依赖抽象<h2 id=\"里氏代换原则\"><a href=\"#里氏代换原则\" class=\"headerlink\" title=\"里氏代换原则\"></a>里氏代换原则</h2>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。即在软件里面，把父类都替换成它的子类，程序的行为没有变化。</li>\n</ul>\n<p><em>子类型必须能够替换掉它们的父类型</em><br><strong>通俗来讲，就是高层模块依赖接口，具体实现则是继承了此接口的实现类</strong></p>\n<h1 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h1><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>为其他对象提供一种代理以控制对这个对象的访问</p>\n<h1 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h1><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类</p>\n<h1 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h1><p>用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>"},{"layout":"post","title":"leetcode练习汇总（持续更新）","date":"2019-01-16T02:42:10.000Z","_content":"\n\n> 在个人github上新建了一个leetcode仓库，以后的练习将提交到此处\n\n\n[地址](https://github.com/csxiaoshang/leetcode)\n","source":"_posts/2019-01-16-leetcode.md","raw":"---\nlayout: post\ntitle:  \"leetcode练习汇总（持续更新）\"\ndate:   2019-01-16 10:42:10\ncategories: leetcode\ntags: learning \n---\n\n\n> 在个人github上新建了一个leetcode仓库，以后的练习将提交到此处\n\n\n[地址](https://github.com/csxiaoshang/leetcode)\n","slug":"2019-01-16-leetcode","published":1,"updated":"2019-12-04T14:30:32.995Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6q000o9oet3m0v8eqs","content":"<blockquote>\n<p>在个人github上新建了一个leetcode仓库，以后的练习将提交到此处</p>\n</blockquote>\n<p><a href=\"https://github.com/csxiaoshang/leetcode\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在个人github上新建了一个leetcode仓库，以后的练习将提交到此处</p>\n</blockquote>\n<p><a href=\"https://github.com/csxiaoshang/leetcode\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n"},{"layout":"post","title":"使用springboot+ajax+bootstrap搭建的一个前后端耦合的个人博客项目","date":"2018-11-14T06:47:13.000Z","_content":"\n\n> 搭建的比较简陋，只是完成了基本的用户和发表博客、展示博客等功能\n\n[项目地址](https://github.com/csxiaoshang/blog)\n\n之后会继续学习springboot，了解前后端分离的使用。","source":"_posts/2018-11-14-springbootblog.md","raw":"---\nlayout: post\ntitle:  \"使用springboot+ajax+bootstrap搭建的一个前后端耦合的个人博客项目\"\ndate:   2018-11-14 14:47:13\ncategories: learning\ntags: springboot\n---\n\n\n> 搭建的比较简陋，只是完成了基本的用户和发表博客、展示博客等功能\n\n[项目地址](https://github.com/csxiaoshang/blog)\n\n之后会继续学习springboot，了解前后端分离的使用。","slug":"2018-11-14-springbootblog","published":1,"updated":"2019-12-04T14:30:33.171Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6t000q9oetej0d90fq","content":"<blockquote>\n<p>搭建的比较简陋，只是完成了基本的用户和发表博客、展示博客等功能</p>\n</blockquote>\n<p><a href=\"https://github.com/csxiaoshang/blog\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<p>之后会继续学习springboot，了解前后端分离的使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>搭建的比较简陋，只是完成了基本的用户和发表博客、展示博客等功能</p>\n</blockquote>\n<p><a href=\"https://github.com/csxiaoshang/blog\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<p>之后会继续学习springboot，了解前后端分离的使用。</p>\n"},{"layout":"post","title":"考虑后不去参加头条实习面试","date":"2018-09-22T10:22:36.000Z","_content":"\n昨天下午收到了头条HR的电话，让过去参加面试，本来挺高兴的，寻思就算去不上，过去面试吸取下经验也是好的。\n<!--more-->\n\t\n今天正好大学同学一起聚餐，特别高兴聊了很多。也寻思去过去看看肯定是好的，回来后，打算看看头条JAVA后台的实习面经，看了几篇劝退了。\n\t\n您好，诚意邀请您参加字节跳动的面试。\n【面试时间】：2018-09-26 16:00:00\n【面试地点】：知春路甲48号盈都大厦B座10层\n【面试流程】：笔试/初试-复试-终面\n【乘车路线】：地铁10号线或13号线（知春路站B口出），西行约100米左转，前方左手边的写字楼即到。\n\t\n深深的感觉到自己水平能力还有很大欠缺，想要做好java后台开发还有很长的路要走。\n\t\n同时也很高兴自己来到了北京，这里机会真的是多。自己投了3份简历，两个让我去面试。在这种大环境下，真的是海阔凭鱼跃，天高任鸟飞。\n","source":"_posts/2018-09-22-toutiaomianshibuqu.md","raw":"---\nlayout: post\ntitle:  \"考虑后不去参加头条实习面试\"\ndate:   2018-09-22 18:22:36\ncategories: note\ntags: interview\n---\n\n昨天下午收到了头条HR的电话，让过去参加面试，本来挺高兴的，寻思就算去不上，过去面试吸取下经验也是好的。\n<!--more-->\n\t\n今天正好大学同学一起聚餐，特别高兴聊了很多。也寻思去过去看看肯定是好的，回来后，打算看看头条JAVA后台的实习面经，看了几篇劝退了。\n\t\n您好，诚意邀请您参加字节跳动的面试。\n【面试时间】：2018-09-26 16:00:00\n【面试地点】：知春路甲48号盈都大厦B座10层\n【面试流程】：笔试/初试-复试-终面\n【乘车路线】：地铁10号线或13号线（知春路站B口出），西行约100米左转，前方左手边的写字楼即到。\n\t\n深深的感觉到自己水平能力还有很大欠缺，想要做好java后台开发还有很长的路要走。\n\t\n同时也很高兴自己来到了北京，这里机会真的是多。自己投了3份简历，两个让我去面试。在这种大环境下，真的是海阔凭鱼跃，天高任鸟飞。\n","slug":"2018-09-22-toutiaomianshibuqu","published":1,"updated":"2019-12-04T14:32:19.020Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz6z000v9oet4xx8ec9f","content":"<p>昨天下午收到了头条HR的电话，让过去参加面试，本来挺高兴的，寻思就算去不上，过去面试吸取下经验也是好的。</p>\n<a id=\"more\"></a>\n\n<p>今天正好大学同学一起聚餐，特别高兴聊了很多。也寻思去过去看看肯定是好的，回来后，打算看看头条JAVA后台的实习面经，看了几篇劝退了。</p>\n<p>您好，诚意邀请您参加字节跳动的面试。<br>【面试时间】：2018-09-26 16:00:00<br>【面试地点】：知春路甲48号盈都大厦B座10层<br>【面试流程】：笔试/初试-复试-终面<br>【乘车路线】：地铁10号线或13号线（知春路站B口出），西行约100米左转，前方左手边的写字楼即到。</p>\n<p>深深的感觉到自己水平能力还有很大欠缺，想要做好java后台开发还有很长的路要走。</p>\n<p>同时也很高兴自己来到了北京，这里机会真的是多。自己投了3份简历，两个让我去面试。在这种大环境下，真的是海阔凭鱼跃，天高任鸟飞。</p>\n","site":{"data":{}},"excerpt":"<p>昨天下午收到了头条HR的电话，让过去参加面试，本来挺高兴的，寻思就算去不上，过去面试吸取下经验也是好的。</p>","more":"<p>今天正好大学同学一起聚餐，特别高兴聊了很多。也寻思去过去看看肯定是好的，回来后，打算看看头条JAVA后台的实习面经，看了几篇劝退了。</p>\n<p>您好，诚意邀请您参加字节跳动的面试。<br>【面试时间】：2018-09-26 16:00:00<br>【面试地点】：知春路甲48号盈都大厦B座10层<br>【面试流程】：笔试/初试-复试-终面<br>【乘车路线】：地铁10号线或13号线（知春路站B口出），西行约100米左转，前方左手边的写字楼即到。</p>\n<p>深深的感觉到自己水平能力还有很大欠缺，想要做好java后台开发还有很长的路要走。</p>\n<p>同时也很高兴自己来到了北京，这里机会真的是多。自己投了3份简历，两个让我去面试。在这种大环境下，真的是海阔凭鱼跃，天高任鸟飞。</p>"},{"layout":"post","title":"iqiyi实习总结","date":"2019-11-26T07:30:00.000Z","_content":"\n\n- 在爱奇艺实习的经验总结\n\n今年算是在7月到9月在爱奇艺实习了两个月，算是偷偷的跑了出去。说实话这两个月在爱奇艺学到的东西不多，接手的项目并不是一个线上使用的能够盈利的项目。\n而是一个公司内部使用的一个持续集成、持续部署的系统，给爱奇艺电视打包各种不同的软件。用的是ssh框架，比较老，给自己的活主要是一些curd，也包括修改前端页面jsp。\n唯一有点任务量的算是封装httpclient的api上传下载文件，另一个算是这个系统的核心业务了，编写使用jenkins api的通用工具类，自己写完后就将这个工具类开源了，还打包推到了maven中央仓库。。。\n<!--more-->\n<br>\n之前都是用springboot写项目，虽然大四的时候看了些javaweb的教程，学习了jsp、servlet，但是也不是太明白。通过做这个项目算是明白了spring项目的启动原理，ioc、aop的一些核心的东西，\n当时在公司里明白了一个http请求到tomcat处理后分发到spring再处理后，再到业务处理完返回的整个流程的时候，特别兴奋，也模仿github上的一个项目编写了一个小的tomcat demo.在公司的时候\n，同时看了些左潇龙大佬的设计模式博客，受益颇多。对java的继承 泛型理解多了些，尝试编写通用型的代码，注意编码时的解耦。jvm这本书读了内存那块，看了并发实战的一部分内容。\n<br>\n这两个月一下子就过去了，学到了挺多东西，但是又感觉没有多少，技术水平还得继续增强。\n<br>\n掌握好基础，多实践多学习！","source":"_posts/2019-11-26-iqiyi.md","raw":"---\nlayout: post\ntitle:  \"iqiyi实习总结\"\ndate:   2019-11-26 15:30:00\ncategories: note\ntags: interview\n---\n\n\n- 在爱奇艺实习的经验总结\n\n今年算是在7月到9月在爱奇艺实习了两个月，算是偷偷的跑了出去。说实话这两个月在爱奇艺学到的东西不多，接手的项目并不是一个线上使用的能够盈利的项目。\n而是一个公司内部使用的一个持续集成、持续部署的系统，给爱奇艺电视打包各种不同的软件。用的是ssh框架，比较老，给自己的活主要是一些curd，也包括修改前端页面jsp。\n唯一有点任务量的算是封装httpclient的api上传下载文件，另一个算是这个系统的核心业务了，编写使用jenkins api的通用工具类，自己写完后就将这个工具类开源了，还打包推到了maven中央仓库。。。\n<!--more-->\n<br>\n之前都是用springboot写项目，虽然大四的时候看了些javaweb的教程，学习了jsp、servlet，但是也不是太明白。通过做这个项目算是明白了spring项目的启动原理，ioc、aop的一些核心的东西，\n当时在公司里明白了一个http请求到tomcat处理后分发到spring再处理后，再到业务处理完返回的整个流程的时候，特别兴奋，也模仿github上的一个项目编写了一个小的tomcat demo.在公司的时候\n，同时看了些左潇龙大佬的设计模式博客，受益颇多。对java的继承 泛型理解多了些，尝试编写通用型的代码，注意编码时的解耦。jvm这本书读了内存那块，看了并发实战的一部分内容。\n<br>\n这两个月一下子就过去了，学到了挺多东西，但是又感觉没有多少，技术水平还得继续增强。\n<br>\n掌握好基础，多实践多学习！","slug":"2019-11-26-iqiyi","published":1,"updated":"2019-12-04T14:30:32.935Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz71000y9oet5ko9d3zm","content":"<ul>\n<li>在爱奇艺实习的经验总结</li>\n</ul>\n<p>今年算是在7月到9月在爱奇艺实习了两个月，算是偷偷的跑了出去。说实话这两个月在爱奇艺学到的东西不多，接手的项目并不是一个线上使用的能够盈利的项目。<br>而是一个公司内部使用的一个持续集成、持续部署的系统，给爱奇艺电视打包各种不同的软件。用的是ssh框架，比较老，给自己的活主要是一些curd，也包括修改前端页面jsp。<br>唯一有点任务量的算是封装httpclient的api上传下载文件，另一个算是这个系统的核心业务了，编写使用jenkins api的通用工具类，自己写完后就将这个工具类开源了，还打包推到了maven中央仓库。。。</p>\n<a id=\"more\"></a>\n<br>\n之前都是用springboot写项目，虽然大四的时候看了些javaweb的教程，学习了jsp、servlet，但是也不是太明白。通过做这个项目算是明白了spring项目的启动原理，ioc、aop的一些核心的东西，\n当时在公司里明白了一个http请求到tomcat处理后分发到spring再处理后，再到业务处理完返回的整个流程的时候，特别兴奋，也模仿github上的一个项目编写了一个小的tomcat demo.在公司的时候\n，同时看了些左潇龙大佬的设计模式博客，受益颇多。对java的继承 泛型理解多了些，尝试编写通用型的代码，注意编码时的解耦。jvm这本书读了内存那块，看了并发实战的一部分内容。\n<br>\n这两个月一下子就过去了，学到了挺多东西，但是又感觉没有多少，技术水平还得继续增强。\n<br>\n掌握好基础，多实践多学习！","site":{"data":{}},"excerpt":"<ul>\n<li>在爱奇艺实习的经验总结</li>\n</ul>\n<p>今年算是在7月到9月在爱奇艺实习了两个月，算是偷偷的跑了出去。说实话这两个月在爱奇艺学到的东西不多，接手的项目并不是一个线上使用的能够盈利的项目。<br>而是一个公司内部使用的一个持续集成、持续部署的系统，给爱奇艺电视打包各种不同的软件。用的是ssh框架，比较老，给自己的活主要是一些curd，也包括修改前端页面jsp。<br>唯一有点任务量的算是封装httpclient的api上传下载文件，另一个算是这个系统的核心业务了，编写使用jenkins api的通用工具类，自己写完后就将这个工具类开源了，还打包推到了maven中央仓库。。。</p>","more":"<br>\n之前都是用springboot写项目，虽然大四的时候看了些javaweb的教程，学习了jsp、servlet，但是也不是太明白。通过做这个项目算是明白了spring项目的启动原理，ioc、aop的一些核心的东西，\n当时在公司里明白了一个http请求到tomcat处理后分发到spring再处理后，再到业务处理完返回的整个流程的时候，特别兴奋，也模仿github上的一个项目编写了一个小的tomcat demo.在公司的时候\n，同时看了些左潇龙大佬的设计模式博客，受益颇多。对java的继承 泛型理解多了些，尝试编写通用型的代码，注意编码时的解耦。jvm这本书读了内存那块，看了并发实战的一部分内容。\n<br>\n这两个月一下子就过去了，学到了挺多东西，但是又感觉没有多少，技术水平还得继续增强。\n<br>\n掌握好基础，多实践多学习！"},{"title":"2020/2/28　淘系技术部一面","date":"2020-02-28T07:36:08.000Z","_content":"\n- 个人介绍\n- 自己遇到的项目中比较有挑战的点\n- 项目问题 负载均衡\n- HTTP1 HTTP2优缺点<!--more-->\n    http2增加了多路复用、头部压缩\n- 场景：长url到短url\n- ThreadLocal使用场景\n- young gc full gc时机\n- 年轻代对象转入到老年代的方式\n- 两个线程串行执行方式\n- TCP如何保证可靠连接\n- 乐观锁　悲观锁\n- 数据库实现乐观锁　悲观锁\n- 数据库分库分表\n- 现有的最新的服务端架构　微服务等\n- 个人对服务端架构的探索\n- HashMap 数据结构\n- hash冲突解决办法\n- 个人职业规划\n- Http协议组成\n- cookie如何实现\n- 浏览器如何实现重定向\n- close_wait time_wait何时出现\n- 常见oom异常类型，什么情况下出现\n- mysql 优化方式\n- 了解的设计模式　单例模式\n- 对称加密和非对称加密有哪些 优缺点\n    对称加密有　aes des　加密快　安全性低\n    非对称加密　rsa 加密慢　安全性高\n    对称加密用来加密内容，非对称机密一般还是用公钥加密对称加密密钥，私钥解密\n- linux 查看ｃｐｕ　内存的命令\n- linux统计日志的命令　根据日志字段统计信息等\n- linux机器间传输文件命令","source":"_posts/2020-2-28-淘系技术部一面.md","raw":"---\ntitle: 2020/2/28　淘系技术部一面\ndate: 2020-02-28 15:36:08\ncategories: note\ntags: alibaba\n---\n\n- 个人介绍\n- 自己遇到的项目中比较有挑战的点\n- 项目问题 负载均衡\n- HTTP1 HTTP2优缺点<!--more-->\n    http2增加了多路复用、头部压缩\n- 场景：长url到短url\n- ThreadLocal使用场景\n- young gc full gc时机\n- 年轻代对象转入到老年代的方式\n- 两个线程串行执行方式\n- TCP如何保证可靠连接\n- 乐观锁　悲观锁\n- 数据库实现乐观锁　悲观锁\n- 数据库分库分表\n- 现有的最新的服务端架构　微服务等\n- 个人对服务端架构的探索\n- HashMap 数据结构\n- hash冲突解决办法\n- 个人职业规划\n- Http协议组成\n- cookie如何实现\n- 浏览器如何实现重定向\n- close_wait time_wait何时出现\n- 常见oom异常类型，什么情况下出现\n- mysql 优化方式\n- 了解的设计模式　单例模式\n- 对称加密和非对称加密有哪些 优缺点\n    对称加密有　aes des　加密快　安全性低\n    非对称加密　rsa 加密慢　安全性高\n    对称加密用来加密内容，非对称机密一般还是用公钥加密对称加密密钥，私钥解密\n- linux 查看ｃｐｕ　内存的命令\n- linux统计日志的命令　根据日志字段统计信息等\n- linux机器间传输文件命令","slug":"2020-2-28-淘系技术部一面","published":1,"updated":"2020-03-10T08:00:04.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7600139oet9tuu5urf","content":"<ul>\n<li>个人介绍</li>\n<li>自己遇到的项目中比较有挑战的点</li>\n<li>项目问题 负载均衡</li>\n<li>HTTP1 HTTP2优缺点<a id=\"more\"></a><br>  http2增加了多路复用、头部压缩</li>\n<li>场景：长url到短url</li>\n<li>ThreadLocal使用场景</li>\n<li>young gc full gc时机</li>\n<li>年轻代对象转入到老年代的方式</li>\n<li>两个线程串行执行方式</li>\n<li>TCP如何保证可靠连接</li>\n<li>乐观锁　悲观锁</li>\n<li>数据库实现乐观锁　悲观锁</li>\n<li>数据库分库分表</li>\n<li>现有的最新的服务端架构　微服务等</li>\n<li>个人对服务端架构的探索</li>\n<li>HashMap 数据结构</li>\n<li>hash冲突解决办法</li>\n<li>个人职业规划</li>\n<li>Http协议组成</li>\n<li>cookie如何实现</li>\n<li>浏览器如何实现重定向</li>\n<li>close_wait time_wait何时出现</li>\n<li>常见oom异常类型，什么情况下出现</li>\n<li>mysql 优化方式</li>\n<li>了解的设计模式　单例模式</li>\n<li>对称加密和非对称加密有哪些 优缺点<br>  对称加密有　aes des　加密快　安全性低<br>  非对称加密　rsa 加密慢　安全性高<br>  对称加密用来加密内容，非对称机密一般还是用公钥加密对称加密密钥，私钥解密</li>\n<li>linux 查看ｃｐｕ　内存的命令</li>\n<li>linux统计日志的命令　根据日志字段统计信息等</li>\n<li>linux机器间传输文件命令</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>个人介绍</li>\n<li>自己遇到的项目中比较有挑战的点</li>\n<li>项目问题 负载均衡</li>\n<li>HTTP1 HTTP2优缺点</li></ul>","more":"<br>  http2增加了多路复用、头部压缩</li>\n<li>场景：长url到短url</li>\n<li>ThreadLocal使用场景</li>\n<li>young gc full gc时机</li>\n<li>年轻代对象转入到老年代的方式</li>\n<li>两个线程串行执行方式</li>\n<li>TCP如何保证可靠连接</li>\n<li>乐观锁　悲观锁</li>\n<li>数据库实现乐观锁　悲观锁</li>\n<li>数据库分库分表</li>\n<li>现有的最新的服务端架构　微服务等</li>\n<li>个人对服务端架构的探索</li>\n<li>HashMap 数据结构</li>\n<li>hash冲突解决办法</li>\n<li>个人职业规划</li>\n<li>Http协议组成</li>\n<li>cookie如何实现</li>\n<li>浏览器如何实现重定向</li>\n<li>close_wait time_wait何时出现</li>\n<li>常见oom异常类型，什么情况下出现</li>\n<li>mysql 优化方式</li>\n<li>了解的设计模式　单例模式</li>\n<li>对称加密和非对称加密有哪些 优缺点<br>  对称加密有　aes des　加密快　安全性低<br>  非对称加密　rsa 加密慢　安全性高<br>  对称加密用来加密内容，非对称机密一般还是用公钥加密对称加密密钥，私钥解密</li>\n<li>linux 查看ｃｐｕ　内存的命令</li>\n<li>linux统计日志的命令　根据日志字段统计信息等</li>\n<li>linux机器间传输文件命令</li>\n</ul>"},{"title":"TCP状态问题","date":"2019-12-27T03:10:46.000Z","_content":"\n#### TCP三次握手建立连接\n\n- Client发送带有SYN和seq = x的包到Server;Client转为SYN_SENT\n- Server返回SYN、ACK、ack = x +1和seq = y的包，Server从LISTEN切换到SYN_RCVD\n- Client发送ACK、 ack = y +1和seq = x+1 的包，都转为ESTABLISHED\n\n<!--more-->\n\n三次握手的主要目的是：**信息对等和防止超时**。防止超时导致脏连接。\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。\n此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n                  \n\n\n\n#### TCP四次挥手释放连接\n\n- Client发送带有FIN和seq = x的包到Server，Client从ESTABLISHED转为FIN_WAIT_1\n- Server发送带有Ack 、ack= x+1和seq = y的包到Client，Server进入到CLOSE_WAIT状态\n- Client收到确认请求后，进入FIN_WAIT_2，等待服务器发送释放报文\n- Server最后的数据发送完毕后，便发送释放报文，FIN = 1,ack = x+1 和 seq = w ,Server进入到LAST_ACK状态\n- Client收到释放报文后，发出ACK、ack = w+1和seq = x+1，进入到TIME_WAIT状态。这是TCP连接还没有释放，必须等待2\nMSL（最长报文段寿命）时间后，当Client撤销相应的TCB后，才进入CLOSED状态\n- Server只要收到了客户端发出的确认，立即进入CLOSED状态。Server结束TCP连接的时间要比客户端早一些。\n","source":"_posts/TCP状态问题.md","raw":"---\ntitle: TCP状态问题\ndate: 2019-12-27 11:10:46\ncategories: 网络\ntags: TCP\n---\n\n#### TCP三次握手建立连接\n\n- Client发送带有SYN和seq = x的包到Server;Client转为SYN_SENT\n- Server返回SYN、ACK、ack = x +1和seq = y的包，Server从LISTEN切换到SYN_RCVD\n- Client发送ACK、 ack = y +1和seq = x+1 的包，都转为ESTABLISHED\n\n<!--more-->\n\n三次握手的主要目的是：**信息对等和防止超时**。防止超时导致脏连接。\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。\n此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n                  \n\n\n\n#### TCP四次挥手释放连接\n\n- Client发送带有FIN和seq = x的包到Server，Client从ESTABLISHED转为FIN_WAIT_1\n- Server发送带有Ack 、ack= x+1和seq = y的包到Client，Server进入到CLOSE_WAIT状态\n- Client收到确认请求后，进入FIN_WAIT_2，等待服务器发送释放报文\n- Server最后的数据发送完毕后，便发送释放报文，FIN = 1,ack = x+1 和 seq = w ,Server进入到LAST_ACK状态\n- Client收到释放报文后，发出ACK、ack = w+1和seq = x+1，进入到TIME_WAIT状态。这是TCP连接还没有释放，必须等待2\nMSL（最长报文段寿命）时间后，当Client撤销相应的TCB后，才进入CLOSED状态\n- Server只要收到了客户端发出的确认，立即进入CLOSED状态。Server结束TCP连接的时间要比客户端早一些。\n","slug":"TCP状态问题","published":1,"updated":"2019-12-29T05:23:12.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7800169oetadcrefnj","content":"<h4 id=\"TCP三次握手建立连接\"><a href=\"#TCP三次握手建立连接\" class=\"headerlink\" title=\"TCP三次握手建立连接\"></a>TCP三次握手建立连接</h4><ul>\n<li>Client发送带有SYN和seq = x的包到Server;Client转为SYN_SENT</li>\n<li>Server返回SYN、ACK、ack = x +1和seq = y的包，Server从LISTEN切换到SYN_RCVD</li>\n<li>Client发送ACK、 ack = y +1和seq = x+1 的包，都转为ESTABLISHED</li>\n</ul>\n<a id=\"more\"></a>\n\n<p>三次握手的主要目的是：<strong>信息对等和防止超时</strong>。防止超时导致脏连接。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。<br>此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>\n<h4 id=\"TCP四次挥手释放连接\"><a href=\"#TCP四次挥手释放连接\" class=\"headerlink\" title=\"TCP四次挥手释放连接\"></a>TCP四次挥手释放连接</h4><ul>\n<li>Client发送带有FIN和seq = x的包到Server，Client从ESTABLISHED转为FIN_WAIT_1</li>\n<li>Server发送带有Ack 、ack= x+1和seq = y的包到Client，Server进入到CLOSE_WAIT状态</li>\n<li>Client收到确认请求后，进入FIN_WAIT_2，等待服务器发送释放报文</li>\n<li>Server最后的数据发送完毕后，便发送释放报文，FIN = 1,ack = x+1 和 seq = w ,Server进入到LAST_ACK状态</li>\n<li>Client收到释放报文后，发出ACK、ack = w+1和seq = x+1，进入到TIME_WAIT状态。这是TCP连接还没有释放，必须等待2<br>MSL（最长报文段寿命）时间后，当Client撤销相应的TCB后，才进入CLOSED状态</li>\n<li>Server只要收到了客户端发出的确认，立即进入CLOSED状态。Server结束TCP连接的时间要比客户端早一些。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"TCP三次握手建立连接\"><a href=\"#TCP三次握手建立连接\" class=\"headerlink\" title=\"TCP三次握手建立连接\"></a>TCP三次握手建立连接</h4><ul>\n<li>Client发送带有SYN和seq = x的包到Server;Client转为SYN_SENT</li>\n<li>Server返回SYN、ACK、ack = x +1和seq = y的包，Server从LISTEN切换到SYN_RCVD</li>\n<li>Client发送ACK、 ack = y +1和seq = x+1 的包，都转为ESTABLISHED</li>\n</ul>","more":"<p>三次握手的主要目的是：<strong>信息对等和防止超时</strong>。防止超时导致脏连接。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。<br>此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>\n<h4 id=\"TCP四次挥手释放连接\"><a href=\"#TCP四次挥手释放连接\" class=\"headerlink\" title=\"TCP四次挥手释放连接\"></a>TCP四次挥手释放连接</h4><ul>\n<li>Client发送带有FIN和seq = x的包到Server，Client从ESTABLISHED转为FIN_WAIT_1</li>\n<li>Server发送带有Ack 、ack= x+1和seq = y的包到Client，Server进入到CLOSE_WAIT状态</li>\n<li>Client收到确认请求后，进入FIN_WAIT_2，等待服务器发送释放报文</li>\n<li>Server最后的数据发送完毕后，便发送释放报文，FIN = 1,ack = x+1 和 seq = w ,Server进入到LAST_ACK状态</li>\n<li>Client收到释放报文后，发出ACK、ack = w+1和seq = x+1，进入到TIME_WAIT状态。这是TCP连接还没有释放，必须等待2<br>MSL（最长报文段寿命）时间后，当Client撤销相应的TCB后，才进入CLOSED状态</li>\n<li>Server只要收到了客户端发出的确认，立即进入CLOSED状态。Server结束TCP连接的时间要比客户端早一些。</li>\n</ul>"},{"title":"2019年终总结","date":"2019-12-21T04:33:05.000Z","_content":"\n 2019年还剩下10天，马上就要2020年了<br>\n 回想过去的这一年里，有收获、也有失落、五味杂陈。\n <br>\n 感觉人成长变化都是由一件件事情驱动的，如果没有经过经历我还是我，很难有实质性的变化。\n \n <!--more-->\n \n如果说过去的2018年是由毕业到读研的一个过渡，让我重新体会到那种高中步入到大学的那种感觉；\n这2019年感觉便是对新阶段人生的加深、熟悉、进步。\n\n - 学习工作\n \n    1. spring实战\n    2. java编程思想\n    3. redis设计与实现\n    4. 图解http\n    5. 深入理解JVM\n    6. 大型网站技术架构\n    7. 程序员修炼之道\n    8. effect java\n    9. maven实战\n    10. java8实战\n    11. 阿里巴巴Java开发手册\n    12. netty实战（未看完）\n    13. spring cloud微服务实战（未看完）\n    14. 高效能人士的七个习惯（未看完）\n    15. 亲密关系（未看完）\n    16. 球状闪电\n    17. 数不清的技术博客（自我感觉多数未消化）\n    \n这样一一列出来，发现也是读了不少书，其中以技术书籍为主。去年读研半年，课余时间算是刚刚入门，过年回来后，\n便开始疯狂补充知识，其中有个致命的问题就是理论走在了前面 实践没有跟上。这个问题在开了新项目路边停车、在实习后\n得到了一定程度的解决。\n\n这一年编码能力、阅读代码的能力都得到了一定程度的提高，从最开始阅读java源码都有问题、速度慢、不是特别理解等，到现在阅读速度上、理解上都有很大的提高。\n\n刷题： \n\n    刷题刷的有些敷衍，在牛客上刷完了剑指offer、程序员面试金典的题，暗示自我感觉效果不好。在碰到不太会的问题时就去看了解答，但是也没有回过头来\n    认真思考。接下来到到寒假结束有一个半月时间，承诺自己最少在leetcode刷100题。\n\n比赛： \n    \n    1.参加了腾讯的微信小程序比赛，最后进了复赛但是也没有拿到名次，\n    2.阿里第五届中间件比赛，一开始直接懵逼了，各种不会。使劲搞了一番 616/4095,意料之内\n    等赛事结束后，又进行了一波复盘 照着大佬的代码思考一番，敲出一个版本，在自适应负载均衡比赛中 45/498，还算满意\n    还有一个消息队列的题目一直没吃透，抽时间再搞一稿\n    \n参加比赛确实能学到很多东西，这次参加中间件比赛，接触到了很多之前不懂的东西，很有收获\n\n实习：\n\n    在七月份的时候，偷偷出去实习了两个月。在爱奇艺做的是一个内部使用的系统，用的技术也比较老 ssh这一套技术框架。自己对待的比较认真，老大给的任务都\n    非常认真的完成，只不过有时候，完成了也不提交代码，磨一点时间自己学习。写些CURD、封装接口、OSS使用、jenkins使用、将设计模式用到代码中 也学到了很多东西，感觉最重要的是\n    通过做这个中老的框架的东西，让我对spring、tomcat有了更好的理解，梳理了从请求发出到返回的整个过程、细节。仿照开源项目，写demo tomcat、spring等，也给\n    开源项目贡献了一次代码，虽然只是文本翻译... 这次实习过程对自己很重要，也很感谢老大\n    \n    \n- 生活\n\n生活上还是自己一个人，孤单倒不孤独，可能是真的单身习惯了；有时候去参加联谊、想要找个女朋友，但是感觉找不找得到也无所谓。并不是多放在心上，宁愿\n更多一点时间待着实验室里...<br>\n实习时候碰到一个女生，做了件好蠢的事情...<br>\n最近 感情上有碰到些问题，有点不知道自己该不该接受，有点想逃避、有点想接受...不愿多想、感觉自己又会犯错误\n\n深深的感觉到 父母因为文化问题有些愚昧，自己也成年好多年了，家里有些事情应该帮他们做主意；一转眼弟弟也上初中了，马上该上高中了，\n感觉跟当初的我一样，知道好好学习，但是也会特别想玩。有时想将自己遗憾没有做的事情，嘱咐他 想让他不要错过，但是往往事与愿违。<br>\n姨姐今年也结婚了，最开始还考虑要不要回家...看到她结婚真好<br>\n生活有条不紊，注意作息 健康饮食\n\n- 方法论\n\n这一年加深了对理论联系实践、从实践中来到实践中去的认知\n\n在学习生活中，光学习理论知识不实践、光实践不增强理论知识都不行，只有两者不同程度的并进才能达到较好的效果。\n比如，实践碰到问题了，回过头来学习理论知识，而后再实践；从实践中学习，实践中验证学到的东西，不断重复这个过程\n\n- 明年承诺\n\n1. leetcode刷300题\n2. 拿到alibaba的offer\n3. 竹笛最少两首拿手曲子\n4. 英语达到能够听明白歌曲的程度\n5. 日语学习完新标准第一册\n6. 象棋稳定业二\n","source":"_posts/2019年终总结.md","raw":"---\ntitle: 2019年终总结\ndate: 2019-12-21 12:33:05\ncategories: 程序人生\n---\n\n 2019年还剩下10天，马上就要2020年了<br>\n 回想过去的这一年里，有收获、也有失落、五味杂陈。\n <br>\n 感觉人成长变化都是由一件件事情驱动的，如果没有经过经历我还是我，很难有实质性的变化。\n \n <!--more-->\n \n如果说过去的2018年是由毕业到读研的一个过渡，让我重新体会到那种高中步入到大学的那种感觉；\n这2019年感觉便是对新阶段人生的加深、熟悉、进步。\n\n - 学习工作\n \n    1. spring实战\n    2. java编程思想\n    3. redis设计与实现\n    4. 图解http\n    5. 深入理解JVM\n    6. 大型网站技术架构\n    7. 程序员修炼之道\n    8. effect java\n    9. maven实战\n    10. java8实战\n    11. 阿里巴巴Java开发手册\n    12. netty实战（未看完）\n    13. spring cloud微服务实战（未看完）\n    14. 高效能人士的七个习惯（未看完）\n    15. 亲密关系（未看完）\n    16. 球状闪电\n    17. 数不清的技术博客（自我感觉多数未消化）\n    \n这样一一列出来，发现也是读了不少书，其中以技术书籍为主。去年读研半年，课余时间算是刚刚入门，过年回来后，\n便开始疯狂补充知识，其中有个致命的问题就是理论走在了前面 实践没有跟上。这个问题在开了新项目路边停车、在实习后\n得到了一定程度的解决。\n\n这一年编码能力、阅读代码的能力都得到了一定程度的提高，从最开始阅读java源码都有问题、速度慢、不是特别理解等，到现在阅读速度上、理解上都有很大的提高。\n\n刷题： \n\n    刷题刷的有些敷衍，在牛客上刷完了剑指offer、程序员面试金典的题，暗示自我感觉效果不好。在碰到不太会的问题时就去看了解答，但是也没有回过头来\n    认真思考。接下来到到寒假结束有一个半月时间，承诺自己最少在leetcode刷100题。\n\n比赛： \n    \n    1.参加了腾讯的微信小程序比赛，最后进了复赛但是也没有拿到名次，\n    2.阿里第五届中间件比赛，一开始直接懵逼了，各种不会。使劲搞了一番 616/4095,意料之内\n    等赛事结束后，又进行了一波复盘 照着大佬的代码思考一番，敲出一个版本，在自适应负载均衡比赛中 45/498，还算满意\n    还有一个消息队列的题目一直没吃透，抽时间再搞一稿\n    \n参加比赛确实能学到很多东西，这次参加中间件比赛，接触到了很多之前不懂的东西，很有收获\n\n实习：\n\n    在七月份的时候，偷偷出去实习了两个月。在爱奇艺做的是一个内部使用的系统，用的技术也比较老 ssh这一套技术框架。自己对待的比较认真，老大给的任务都\n    非常认真的完成，只不过有时候，完成了也不提交代码，磨一点时间自己学习。写些CURD、封装接口、OSS使用、jenkins使用、将设计模式用到代码中 也学到了很多东西，感觉最重要的是\n    通过做这个中老的框架的东西，让我对spring、tomcat有了更好的理解，梳理了从请求发出到返回的整个过程、细节。仿照开源项目，写demo tomcat、spring等，也给\n    开源项目贡献了一次代码，虽然只是文本翻译... 这次实习过程对自己很重要，也很感谢老大\n    \n    \n- 生活\n\n生活上还是自己一个人，孤单倒不孤独，可能是真的单身习惯了；有时候去参加联谊、想要找个女朋友，但是感觉找不找得到也无所谓。并不是多放在心上，宁愿\n更多一点时间待着实验室里...<br>\n实习时候碰到一个女生，做了件好蠢的事情...<br>\n最近 感情上有碰到些问题，有点不知道自己该不该接受，有点想逃避、有点想接受...不愿多想、感觉自己又会犯错误\n\n深深的感觉到 父母因为文化问题有些愚昧，自己也成年好多年了，家里有些事情应该帮他们做主意；一转眼弟弟也上初中了，马上该上高中了，\n感觉跟当初的我一样，知道好好学习，但是也会特别想玩。有时想将自己遗憾没有做的事情，嘱咐他 想让他不要错过，但是往往事与愿违。<br>\n姨姐今年也结婚了，最开始还考虑要不要回家...看到她结婚真好<br>\n生活有条不紊，注意作息 健康饮食\n\n- 方法论\n\n这一年加深了对理论联系实践、从实践中来到实践中去的认知\n\n在学习生活中，光学习理论知识不实践、光实践不增强理论知识都不行，只有两者不同程度的并进才能达到较好的效果。\n比如，实践碰到问题了，回过头来学习理论知识，而后再实践；从实践中学习，实践中验证学到的东西，不断重复这个过程\n\n- 明年承诺\n\n1. leetcode刷300题\n2. 拿到alibaba的offer\n3. 竹笛最少两首拿手曲子\n4. 英语达到能够听明白歌曲的程度\n5. 日语学习完新标准第一册\n6. 象棋稳定业二\n","slug":"2019年终总结","published":1,"updated":"2019-12-21T06:29:33.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7b001a9oetfese6stl","content":"<p> 2019年还剩下10天，马上就要2020年了<br><br> 回想过去的这一年里，有收获、也有失落、五味杂陈。<br> <br><br> 感觉人成长变化都是由一件件事情驱动的，如果没有经过经历我还是我，很难有实质性的变化。</p>\n <a id=\"more\"></a>\n\n<p>如果说过去的2018年是由毕业到读研的一个过渡，让我重新体会到那种高中步入到大学的那种感觉；<br>这2019年感觉便是对新阶段人生的加深、熟悉、进步。</p>\n<ul>\n<li><p>学习工作</p>\n<ol>\n<li>spring实战</li>\n<li>java编程思想</li>\n<li>redis设计与实现</li>\n<li>图解http</li>\n<li>深入理解JVM</li>\n<li>大型网站技术架构</li>\n<li>程序员修炼之道</li>\n<li>effect java</li>\n<li>maven实战</li>\n<li>java8实战</li>\n<li>阿里巴巴Java开发手册</li>\n<li>netty实战（未看完）</li>\n<li>spring cloud微服务实战（未看完）</li>\n<li>高效能人士的七个习惯（未看完）</li>\n<li>亲密关系（未看完）</li>\n<li>球状闪电</li>\n<li>数不清的技术博客（自我感觉多数未消化）</li>\n</ol>\n</li>\n</ul>\n<p>这样一一列出来，发现也是读了不少书，其中以技术书籍为主。去年读研半年，课余时间算是刚刚入门，过年回来后，<br>便开始疯狂补充知识，其中有个致命的问题就是理论走在了前面 实践没有跟上。这个问题在开了新项目路边停车、在实习后<br>得到了一定程度的解决。</p>\n<p>这一年编码能力、阅读代码的能力都得到了一定程度的提高，从最开始阅读java源码都有问题、速度慢、不是特别理解等，到现在阅读速度上、理解上都有很大的提高。</p>\n<p>刷题： </p>\n<pre><code>刷题刷的有些敷衍，在牛客上刷完了剑指offer、程序员面试金典的题，暗示自我感觉效果不好。在碰到不太会的问题时就去看了解答，但是也没有回过头来\n认真思考。接下来到到寒假结束有一个半月时间，承诺自己最少在leetcode刷100题。</code></pre><p>比赛： </p>\n<pre><code>1.参加了腾讯的微信小程序比赛，最后进了复赛但是也没有拿到名次，\n2.阿里第五届中间件比赛，一开始直接懵逼了，各种不会。使劲搞了一番 616/4095,意料之内\n等赛事结束后，又进行了一波复盘 照着大佬的代码思考一番，敲出一个版本，在自适应负载均衡比赛中 45/498，还算满意\n还有一个消息队列的题目一直没吃透，抽时间再搞一稿</code></pre><p>参加比赛确实能学到很多东西，这次参加中间件比赛，接触到了很多之前不懂的东西，很有收获</p>\n<p>实习：</p>\n<pre><code>在七月份的时候，偷偷出去实习了两个月。在爱奇艺做的是一个内部使用的系统，用的技术也比较老 ssh这一套技术框架。自己对待的比较认真，老大给的任务都\n非常认真的完成，只不过有时候，完成了也不提交代码，磨一点时间自己学习。写些CURD、封装接口、OSS使用、jenkins使用、将设计模式用到代码中 也学到了很多东西，感觉最重要的是\n通过做这个中老的框架的东西，让我对spring、tomcat有了更好的理解，梳理了从请求发出到返回的整个过程、细节。仿照开源项目，写demo tomcat、spring等，也给\n开源项目贡献了一次代码，虽然只是文本翻译... 这次实习过程对自己很重要，也很感谢老大</code></pre><ul>\n<li>生活</li>\n</ul>\n<p>生活上还是自己一个人，孤单倒不孤独，可能是真的单身习惯了；有时候去参加联谊、想要找个女朋友，但是感觉找不找得到也无所谓。并不是多放在心上，宁愿<br>更多一点时间待着实验室里…<br><br>实习时候碰到一个女生，做了件好蠢的事情…<br><br>最近 感情上有碰到些问题，有点不知道自己该不该接受，有点想逃避、有点想接受…不愿多想、感觉自己又会犯错误</p>\n<p>深深的感觉到 父母因为文化问题有些愚昧，自己也成年好多年了，家里有些事情应该帮他们做主意；一转眼弟弟也上初中了，马上该上高中了，<br>感觉跟当初的我一样，知道好好学习，但是也会特别想玩。有时想将自己遗憾没有做的事情，嘱咐他 想让他不要错过，但是往往事与愿违。<br><br>姨姐今年也结婚了，最开始还考虑要不要回家…看到她结婚真好<br><br>生活有条不紊，注意作息 健康饮食</p>\n<ul>\n<li>方法论</li>\n</ul>\n<p>这一年加深了对理论联系实践、从实践中来到实践中去的认知</p>\n<p>在学习生活中，光学习理论知识不实践、光实践不增强理论知识都不行，只有两者不同程度的并进才能达到较好的效果。<br>比如，实践碰到问题了，回过头来学习理论知识，而后再实践；从实践中学习，实践中验证学到的东西，不断重复这个过程</p>\n<ul>\n<li>明年承诺</li>\n</ul>\n<ol>\n<li>leetcode刷300题</li>\n<li>拿到alibaba的offer</li>\n<li>竹笛最少两首拿手曲子</li>\n<li>英语达到能够听明白歌曲的程度</li>\n<li>日语学习完新标准第一册</li>\n<li>象棋稳定业二</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p> 2019年还剩下10天，马上就要2020年了<br><br> 回想过去的这一年里，有收获、也有失落、五味杂陈。<br> <br><br> 感觉人成长变化都是由一件件事情驱动的，如果没有经过经历我还是我，很难有实质性的变化。</p>","more":"<p>如果说过去的2018年是由毕业到读研的一个过渡，让我重新体会到那种高中步入到大学的那种感觉；<br>这2019年感觉便是对新阶段人生的加深、熟悉、进步。</p>\n<ul>\n<li><p>学习工作</p>\n<ol>\n<li>spring实战</li>\n<li>java编程思想</li>\n<li>redis设计与实现</li>\n<li>图解http</li>\n<li>深入理解JVM</li>\n<li>大型网站技术架构</li>\n<li>程序员修炼之道</li>\n<li>effect java</li>\n<li>maven实战</li>\n<li>java8实战</li>\n<li>阿里巴巴Java开发手册</li>\n<li>netty实战（未看完）</li>\n<li>spring cloud微服务实战（未看完）</li>\n<li>高效能人士的七个习惯（未看完）</li>\n<li>亲密关系（未看完）</li>\n<li>球状闪电</li>\n<li>数不清的技术博客（自我感觉多数未消化）</li>\n</ol>\n</li>\n</ul>\n<p>这样一一列出来，发现也是读了不少书，其中以技术书籍为主。去年读研半年，课余时间算是刚刚入门，过年回来后，<br>便开始疯狂补充知识，其中有个致命的问题就是理论走在了前面 实践没有跟上。这个问题在开了新项目路边停车、在实习后<br>得到了一定程度的解决。</p>\n<p>这一年编码能力、阅读代码的能力都得到了一定程度的提高，从最开始阅读java源码都有问题、速度慢、不是特别理解等，到现在阅读速度上、理解上都有很大的提高。</p>\n<p>刷题： </p>\n<pre><code>刷题刷的有些敷衍，在牛客上刷完了剑指offer、程序员面试金典的题，暗示自我感觉效果不好。在碰到不太会的问题时就去看了解答，但是也没有回过头来\n认真思考。接下来到到寒假结束有一个半月时间，承诺自己最少在leetcode刷100题。</code></pre><p>比赛： </p>\n<pre><code>1.参加了腾讯的微信小程序比赛，最后进了复赛但是也没有拿到名次，\n2.阿里第五届中间件比赛，一开始直接懵逼了，各种不会。使劲搞了一番 616/4095,意料之内\n等赛事结束后，又进行了一波复盘 照着大佬的代码思考一番，敲出一个版本，在自适应负载均衡比赛中 45/498，还算满意\n还有一个消息队列的题目一直没吃透，抽时间再搞一稿</code></pre><p>参加比赛确实能学到很多东西，这次参加中间件比赛，接触到了很多之前不懂的东西，很有收获</p>\n<p>实习：</p>\n<pre><code>在七月份的时候，偷偷出去实习了两个月。在爱奇艺做的是一个内部使用的系统，用的技术也比较老 ssh这一套技术框架。自己对待的比较认真，老大给的任务都\n非常认真的完成，只不过有时候，完成了也不提交代码，磨一点时间自己学习。写些CURD、封装接口、OSS使用、jenkins使用、将设计模式用到代码中 也学到了很多东西，感觉最重要的是\n通过做这个中老的框架的东西，让我对spring、tomcat有了更好的理解，梳理了从请求发出到返回的整个过程、细节。仿照开源项目，写demo tomcat、spring等，也给\n开源项目贡献了一次代码，虽然只是文本翻译... 这次实习过程对自己很重要，也很感谢老大</code></pre><ul>\n<li>生活</li>\n</ul>\n<p>生活上还是自己一个人，孤单倒不孤独，可能是真的单身习惯了；有时候去参加联谊、想要找个女朋友，但是感觉找不找得到也无所谓。并不是多放在心上，宁愿<br>更多一点时间待着实验室里…<br><br>实习时候碰到一个女生，做了件好蠢的事情…<br><br>最近 感情上有碰到些问题，有点不知道自己该不该接受，有点想逃避、有点想接受…不愿多想、感觉自己又会犯错误</p>\n<p>深深的感觉到 父母因为文化问题有些愚昧，自己也成年好多年了，家里有些事情应该帮他们做主意；一转眼弟弟也上初中了，马上该上高中了，<br>感觉跟当初的我一样，知道好好学习，但是也会特别想玩。有时想将自己遗憾没有做的事情，嘱咐他 想让他不要错过，但是往往事与愿违。<br><br>姨姐今年也结婚了，最开始还考虑要不要回家…看到她结婚真好<br><br>生活有条不紊，注意作息 健康饮食</p>\n<ul>\n<li>方法论</li>\n</ul>\n<p>这一年加深了对理论联系实践、从实践中来到实践中去的认知</p>\n<p>在学习生活中，光学习理论知识不实践、光实践不增强理论知识都不行，只有两者不同程度的并进才能达到较好的效果。<br>比如，实践碰到问题了，回过头来学习理论知识，而后再实践；从实践中学习，实践中验证学到的东西，不断重复这个过程</p>\n<ul>\n<li>明年承诺</li>\n</ul>\n<ol>\n<li>leetcode刷300题</li>\n<li>拿到alibaba的offer</li>\n<li>竹笛最少两首拿手曲子</li>\n<li>英语达到能够听明白歌曲的程度</li>\n<li>日语学习完新标准第一册</li>\n<li>象棋稳定业二</li>\n</ol>"},{"title":"Java容器","date":"2020-01-30T13:12:39.000Z","_content":"\n## 一、概览\n\n容器主要包括Collection和Map两种，Collection存储着对象的集合，Map存储着键值对(两个对象)的映射表\n\n### Collection\n\n#### 1.Set\n\n- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作\n- HashSet：基于哈希表实现，不支持有序性操作\n- LinkedHashSet：具有HashSet的查找效率，内部使用双向链表维护元素的插入顺序\n\n#### 2.List\n\n- ArrayList：基于动态数组实现，支持随机访问\n- Vector：和ArrayList相似，但它是线程安全的\n- LinkedList：基于双向链表实现，只能顺序访问。LinkedList还可以用作栈、队列和双向队列。\n<!--more-->\n\n#### 3.Queue\n\n- LinkedList ： 可用作双向队列\n- PriorityQueue：基于堆实现，可用作优先队列\n\n### Map\n\n- TreeMap：基于红黑树实现\n- HashMap：基于哈希表实现\n- HashTable：和HashMap相似，但它是线程安全的，但是一般不使用它，使用ConcurrentHashMap效率更高，因为引入了分段锁\n- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序\n\n## 二、容器中的设计模式\n\n### 迭代器模式\n\nCollection继承了Iterable接口，其中的iterator()方法能够产生一个Iterator对象，通过这个对象可以遍历Collection中的元素。\n\n### 适配器模式\n\njava.util.Arrays#asList()可以把数组类型转换为List类型。\n\n## 三、源码分析\n\n### ArrayList\n\n#### 1.概览\n\nArrayList基于数组实现，所以支持快速随机访问，RandomAccess接口标志该类支持快速随机访问。\n数组默认大小为10。\n\n#### 2.扩容\n\n添加元素时使用ensureCapacityInternal()来保证容量足够，如果不够，扩容。\n新容量大小为旧容量大小的1.5倍。\n<br>\n扩容操作需调用Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。\n\n#### 3.Fail-fast\n\nmodCount用来记录ArrayList结构发生变化的次数，在进行序列化或者迭代的时候，需要\n比较前后modCount是否改变，若改变了需要抛出ConcurrentModificationException异常.\n\n### Vector\n\n#### 1.同步\n\n使用synchronized进行同步\n\n#### 2.比较\n\n因为使用synchronized同步，所以开销要比ArrayList大一些\n\n\n在使用方面，可使用Collections.synchronizedList()和CopyOnWriteArrayList代替\n\n### CopyOnWriteArrayList\n\n#### 1.读写分离\n\nCopyOnWriteArrayList写操作时，加锁，将原有数组元素拷贝到一个新的数组中，写入元素，将原有数组指向新的数组，释放锁\n读操作在原有数组中，读写分离，互不影响\n\nCopyOnWriteArrayList 存在内存占用和数据不一致性问题\n所以它不适合内存敏感以及对实时性要求高的场景\n\n### LinkedList\n\n基于双向链表实现\n\n和ArrayList的区别可以归结为数组和链表的区别\n\n### HashMap\n\n#### 1.存储结构\n\n内部维护一个Node类型的数组，作为hash表；Node数据结构包含4个字段，有key、value、next指针、int型hash值\n\n数组的每一个位置被当做一个桶，一个桶存放一个链表。\n\n#### 2.拉链法的工作原理\n\n哈希表为解决hash冲突有开放地址法和链地址法。比较来说，链地址法更适合于大规模数据和不确定性数据的存储，处理冲突简单且不易出现堆积问题，节省空间\n- 确定hash桶数组索引位置\nkey值取哈希值时采用高位运算使得hash值的高位通常也能参与到计算hash表值中，使用与运算代替取模提高一定的效率。\n- HashMap的put方法\nJDK 1.7 之前使用头插法、JDK 1.8 使用尾插法\n![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png)\n- 扩容机制\n在hash表容量扩大为两倍时，在rehash时有了一定的优化，在数组位置上只有一个元素时，rehash赋值到新的hash表；有多个元素时，根据扩容的位为1或0，进行优化\n\n#### 3.参看链接\n[Java 8系列之重新认识HashMap](https://tech.meituan.com/2016/06/24/java-hashmap.html)\n[HashMap 相关面试题及其解答](https://www.jianshu.com/p/75adf47958a7)\n#### 注意\n(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。\n\n(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。\n\n(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。\n\n(4) JDK1.8引入红黑树大程度优化了HashMap的性能。\n\n(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。\n\n    Q：HashMap，LinkedHashMap，TreeMap 有什么区别？\n    \n    A：HashMap 参考其他问题；\n    LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；\n    TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）\n    \n    Q：HashMap 和 HashTable 有什么区别？\n    \n    A：①、HashMap 是线程不安全的，HashTable 是线程安全的；\n    ②、由于线程安全，所以 HashTable 的效率比不上 HashMap；\n    ③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable 不允许；\n    ④、HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；\n    ⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode\n    \n\n### ConcurrentHashMap\n\n[jdk1.7版本的ConcurrentHashMap解析](https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/)\n[HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！](https://blog.csdn.net/weixin_44460333/article/details/86770169)\n","source":"_posts/Java容器.md","raw":"---\ntitle: Java容器\ndate: 2020-01-30 21:12:39\ncategories: Java\ntags: Java\n---\n\n## 一、概览\n\n容器主要包括Collection和Map两种，Collection存储着对象的集合，Map存储着键值对(两个对象)的映射表\n\n### Collection\n\n#### 1.Set\n\n- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作\n- HashSet：基于哈希表实现，不支持有序性操作\n- LinkedHashSet：具有HashSet的查找效率，内部使用双向链表维护元素的插入顺序\n\n#### 2.List\n\n- ArrayList：基于动态数组实现，支持随机访问\n- Vector：和ArrayList相似，但它是线程安全的\n- LinkedList：基于双向链表实现，只能顺序访问。LinkedList还可以用作栈、队列和双向队列。\n<!--more-->\n\n#### 3.Queue\n\n- LinkedList ： 可用作双向队列\n- PriorityQueue：基于堆实现，可用作优先队列\n\n### Map\n\n- TreeMap：基于红黑树实现\n- HashMap：基于哈希表实现\n- HashTable：和HashMap相似，但它是线程安全的，但是一般不使用它，使用ConcurrentHashMap效率更高，因为引入了分段锁\n- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序\n\n## 二、容器中的设计模式\n\n### 迭代器模式\n\nCollection继承了Iterable接口，其中的iterator()方法能够产生一个Iterator对象，通过这个对象可以遍历Collection中的元素。\n\n### 适配器模式\n\njava.util.Arrays#asList()可以把数组类型转换为List类型。\n\n## 三、源码分析\n\n### ArrayList\n\n#### 1.概览\n\nArrayList基于数组实现，所以支持快速随机访问，RandomAccess接口标志该类支持快速随机访问。\n数组默认大小为10。\n\n#### 2.扩容\n\n添加元素时使用ensureCapacityInternal()来保证容量足够，如果不够，扩容。\n新容量大小为旧容量大小的1.5倍。\n<br>\n扩容操作需调用Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。\n\n#### 3.Fail-fast\n\nmodCount用来记录ArrayList结构发生变化的次数，在进行序列化或者迭代的时候，需要\n比较前后modCount是否改变，若改变了需要抛出ConcurrentModificationException异常.\n\n### Vector\n\n#### 1.同步\n\n使用synchronized进行同步\n\n#### 2.比较\n\n因为使用synchronized同步，所以开销要比ArrayList大一些\n\n\n在使用方面，可使用Collections.synchronizedList()和CopyOnWriteArrayList代替\n\n### CopyOnWriteArrayList\n\n#### 1.读写分离\n\nCopyOnWriteArrayList写操作时，加锁，将原有数组元素拷贝到一个新的数组中，写入元素，将原有数组指向新的数组，释放锁\n读操作在原有数组中，读写分离，互不影响\n\nCopyOnWriteArrayList 存在内存占用和数据不一致性问题\n所以它不适合内存敏感以及对实时性要求高的场景\n\n### LinkedList\n\n基于双向链表实现\n\n和ArrayList的区别可以归结为数组和链表的区别\n\n### HashMap\n\n#### 1.存储结构\n\n内部维护一个Node类型的数组，作为hash表；Node数据结构包含4个字段，有key、value、next指针、int型hash值\n\n数组的每一个位置被当做一个桶，一个桶存放一个链表。\n\n#### 2.拉链法的工作原理\n\n哈希表为解决hash冲突有开放地址法和链地址法。比较来说，链地址法更适合于大规模数据和不确定性数据的存储，处理冲突简单且不易出现堆积问题，节省空间\n- 确定hash桶数组索引位置\nkey值取哈希值时采用高位运算使得hash值的高位通常也能参与到计算hash表值中，使用与运算代替取模提高一定的效率。\n- HashMap的put方法\nJDK 1.7 之前使用头插法、JDK 1.8 使用尾插法\n![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png)\n- 扩容机制\n在hash表容量扩大为两倍时，在rehash时有了一定的优化，在数组位置上只有一个元素时，rehash赋值到新的hash表；有多个元素时，根据扩容的位为1或0，进行优化\n\n#### 3.参看链接\n[Java 8系列之重新认识HashMap](https://tech.meituan.com/2016/06/24/java-hashmap.html)\n[HashMap 相关面试题及其解答](https://www.jianshu.com/p/75adf47958a7)\n#### 注意\n(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。\n\n(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。\n\n(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。\n\n(4) JDK1.8引入红黑树大程度优化了HashMap的性能。\n\n(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。\n\n    Q：HashMap，LinkedHashMap，TreeMap 有什么区别？\n    \n    A：HashMap 参考其他问题；\n    LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；\n    TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）\n    \n    Q：HashMap 和 HashTable 有什么区别？\n    \n    A：①、HashMap 是线程不安全的，HashTable 是线程安全的；\n    ②、由于线程安全，所以 HashTable 的效率比不上 HashMap；\n    ③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable 不允许；\n    ④、HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；\n    ⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode\n    \n\n### ConcurrentHashMap\n\n[jdk1.7版本的ConcurrentHashMap解析](https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/)\n[HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！](https://blog.csdn.net/weixin_44460333/article/details/86770169)\n","slug":"Java容器","published":1,"updated":"2020-01-31T03:21:08.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7d001e9oet7arlhpmn","content":"<h2 id=\"一、概览\"><a href=\"#一、概览\" class=\"headerlink\" title=\"一、概览\"></a>一、概览</h2><p>容器主要包括Collection和Map两种，Collection存储着对象的集合，Map存储着键值对(两个对象)的映射表</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h3><h4 id=\"1-Set\"><a href=\"#1-Set\" class=\"headerlink\" title=\"1.Set\"></a>1.Set</h4><ul>\n<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作</li>\n<li>HashSet：基于哈希表实现，不支持有序性操作</li>\n<li>LinkedHashSet：具有HashSet的查找效率，内部使用双向链表维护元素的插入顺序</li>\n</ul>\n<h4 id=\"2-List\"><a href=\"#2-List\" class=\"headerlink\" title=\"2.List\"></a>2.List</h4><ul>\n<li>ArrayList：基于动态数组实现，支持随机访问</li>\n<li>Vector：和ArrayList相似，但它是线程安全的</li>\n<li>LinkedList：基于双向链表实现，只能顺序访问。LinkedList还可以用作栈、队列和双向队列。<a id=\"more\"></a>\n\n</li>\n</ul>\n<h4 id=\"3-Queue\"><a href=\"#3-Queue\" class=\"headerlink\" title=\"3.Queue\"></a>3.Queue</h4><ul>\n<li>LinkedList ： 可用作双向队列</li>\n<li>PriorityQueue：基于堆实现，可用作优先队列</li>\n</ul>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><ul>\n<li>TreeMap：基于红黑树实现</li>\n<li>HashMap：基于哈希表实现</li>\n<li>HashTable：和HashMap相似，但它是线程安全的，但是一般不使用它，使用ConcurrentHashMap效率更高，因为引入了分段锁</li>\n<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序</li>\n</ul>\n<h2 id=\"二、容器中的设计模式\"><a href=\"#二、容器中的设计模式\" class=\"headerlink\" title=\"二、容器中的设计模式\"></a>二、容器中的设计模式</h2><h3 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h3><p>Collection继承了Iterable接口，其中的iterator()方法能够产生一个Iterator对象，通过这个对象可以遍历Collection中的元素。</p>\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p>java.util.Arrays#asList()可以把数组类型转换为List类型。</p>\n<h2 id=\"三、源码分析\"><a href=\"#三、源码分析\" class=\"headerlink\" title=\"三、源码分析\"></a>三、源码分析</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><h4 id=\"1-概览\"><a href=\"#1-概览\" class=\"headerlink\" title=\"1.概览\"></a>1.概览</h4><p>ArrayList基于数组实现，所以支持快速随机访问，RandomAccess接口标志该类支持快速随机访问。<br>数组默认大小为10。</p>\n<h4 id=\"2-扩容\"><a href=\"#2-扩容\" class=\"headerlink\" title=\"2.扩容\"></a>2.扩容</h4><p>添加元素时使用ensureCapacityInternal()来保证容量足够，如果不够，扩容。<br>新容量大小为旧容量大小的1.5倍。<br><br><br>扩容操作需调用Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>\n<h4 id=\"3-Fail-fast\"><a href=\"#3-Fail-fast\" class=\"headerlink\" title=\"3.Fail-fast\"></a>3.Fail-fast</h4><p>modCount用来记录ArrayList结构发生变化的次数，在进行序列化或者迭代的时候，需要<br>比较前后modCount是否改变，若改变了需要抛出ConcurrentModificationException异常.</p>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><h4 id=\"1-同步\"><a href=\"#1-同步\" class=\"headerlink\" title=\"1.同步\"></a>1.同步</h4><p>使用synchronized进行同步</p>\n<h4 id=\"2-比较\"><a href=\"#2-比较\" class=\"headerlink\" title=\"2.比较\"></a>2.比较</h4><p>因为使用synchronized同步，所以开销要比ArrayList大一些</p>\n<p>在使用方面，可使用Collections.synchronizedList()和CopyOnWriteArrayList代替</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><h4 id=\"1-读写分离\"><a href=\"#1-读写分离\" class=\"headerlink\" title=\"1.读写分离\"></a>1.读写分离</h4><p>CopyOnWriteArrayList写操作时，加锁，将原有数组元素拷贝到一个新的数组中，写入元素，将原有数组指向新的数组，释放锁<br>读操作在原有数组中，读写分离，互不影响</p>\n<p>CopyOnWriteArrayList 存在内存占用和数据不一致性问题<br>所以它不适合内存敏感以及对实时性要求高的场景</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>基于双向链表实现</p>\n<p>和ArrayList的区别可以归结为数组和链表的区别</p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><h4 id=\"1-存储结构\"><a href=\"#1-存储结构\" class=\"headerlink\" title=\"1.存储结构\"></a>1.存储结构</h4><p>内部维护一个Node类型的数组，作为hash表；Node数据结构包含4个字段，有key、value、next指针、int型hash值</p>\n<p>数组的每一个位置被当做一个桶，一个桶存放一个链表。</p>\n<h4 id=\"2-拉链法的工作原理\"><a href=\"#2-拉链法的工作原理\" class=\"headerlink\" title=\"2.拉链法的工作原理\"></a>2.拉链法的工作原理</h4><p>哈希表为解决hash冲突有开放地址法和链地址法。比较来说，链地址法更适合于大规模数据和不确定性数据的存储，处理冲突简单且不易出现堆积问题，节省空间</p>\n<ul>\n<li>确定hash桶数组索引位置<br>key值取哈希值时采用高位运算使得hash值的高位通常也能参与到计算hash表值中，使用与运算代替取模提高一定的效率。</li>\n<li>HashMap的put方法<br>JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法<br><img src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png\" alt></li>\n<li>扩容机制<br>在hash表容量扩大为两倍时，在rehash时有了一定的优化，在数组位置上只有一个元素时，rehash赋值到新的hash表；有多个元素时，根据扩容的位为1或0，进行优化</li>\n</ul>\n<h4 id=\"3-参看链接\"><a href=\"#3-参看链接\" class=\"headerlink\" title=\"3.参看链接\"></a>3.参看链接</h4><p><a href=\"https://tech.meituan.com/2016/06/24/java-hashmap.html\" target=\"_blank\" rel=\"noopener\">Java 8系列之重新认识HashMap</a><br><a href=\"https://www.jianshu.com/p/75adf47958a7\" target=\"_blank\" rel=\"noopener\">HashMap 相关面试题及其解答</a></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>\n<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>\n<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>\n<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>\n<p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>\n<pre><code>Q：HashMap，LinkedHashMap，TreeMap 有什么区别？\n\nA：HashMap 参考其他问题；\nLinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；\nTreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）\n\nQ：HashMap 和 HashTable 有什么区别？\n\nA：①、HashMap 是线程不安全的，HashTable 是线程安全的；\n②、由于线程安全，所以 HashTable 的效率比不上 HashMap；\n③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable 不允许；\n④、HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；\n⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</code></pre><h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><p><a href=\"https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/\" target=\"_blank\" rel=\"noopener\">jdk1.7版本的ConcurrentHashMap解析</a><br><a href=\"https://blog.csdn.net/weixin_44460333/article/details/86770169\" target=\"_blank\" rel=\"noopener\">HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、概览\"><a href=\"#一、概览\" class=\"headerlink\" title=\"一、概览\"></a>一、概览</h2><p>容器主要包括Collection和Map两种，Collection存储着对象的集合，Map存储着键值对(两个对象)的映射表</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h3><h4 id=\"1-Set\"><a href=\"#1-Set\" class=\"headerlink\" title=\"1.Set\"></a>1.Set</h4><ul>\n<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作</li>\n<li>HashSet：基于哈希表实现，不支持有序性操作</li>\n<li>LinkedHashSet：具有HashSet的查找效率，内部使用双向链表维护元素的插入顺序</li>\n</ul>\n<h4 id=\"2-List\"><a href=\"#2-List\" class=\"headerlink\" title=\"2.List\"></a>2.List</h4><ul>\n<li>ArrayList：基于动态数组实现，支持随机访问</li>\n<li>Vector：和ArrayList相似，但它是线程安全的</li>\n<li>LinkedList：基于双向链表实现，只能顺序访问。LinkedList还可以用作栈、队列和双向队列。</li></ul>","more":"</li>\n</ul>\n<h4 id=\"3-Queue\"><a href=\"#3-Queue\" class=\"headerlink\" title=\"3.Queue\"></a>3.Queue</h4><ul>\n<li>LinkedList ： 可用作双向队列</li>\n<li>PriorityQueue：基于堆实现，可用作优先队列</li>\n</ul>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><ul>\n<li>TreeMap：基于红黑树实现</li>\n<li>HashMap：基于哈希表实现</li>\n<li>HashTable：和HashMap相似，但它是线程安全的，但是一般不使用它，使用ConcurrentHashMap效率更高，因为引入了分段锁</li>\n<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序</li>\n</ul>\n<h2 id=\"二、容器中的设计模式\"><a href=\"#二、容器中的设计模式\" class=\"headerlink\" title=\"二、容器中的设计模式\"></a>二、容器中的设计模式</h2><h3 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h3><p>Collection继承了Iterable接口，其中的iterator()方法能够产生一个Iterator对象，通过这个对象可以遍历Collection中的元素。</p>\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p>java.util.Arrays#asList()可以把数组类型转换为List类型。</p>\n<h2 id=\"三、源码分析\"><a href=\"#三、源码分析\" class=\"headerlink\" title=\"三、源码分析\"></a>三、源码分析</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><h4 id=\"1-概览\"><a href=\"#1-概览\" class=\"headerlink\" title=\"1.概览\"></a>1.概览</h4><p>ArrayList基于数组实现，所以支持快速随机访问，RandomAccess接口标志该类支持快速随机访问。<br>数组默认大小为10。</p>\n<h4 id=\"2-扩容\"><a href=\"#2-扩容\" class=\"headerlink\" title=\"2.扩容\"></a>2.扩容</h4><p>添加元素时使用ensureCapacityInternal()来保证容量足够，如果不够，扩容。<br>新容量大小为旧容量大小的1.5倍。<br><br><br>扩容操作需调用Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>\n<h4 id=\"3-Fail-fast\"><a href=\"#3-Fail-fast\" class=\"headerlink\" title=\"3.Fail-fast\"></a>3.Fail-fast</h4><p>modCount用来记录ArrayList结构发生变化的次数，在进行序列化或者迭代的时候，需要<br>比较前后modCount是否改变，若改变了需要抛出ConcurrentModificationException异常.</p>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><h4 id=\"1-同步\"><a href=\"#1-同步\" class=\"headerlink\" title=\"1.同步\"></a>1.同步</h4><p>使用synchronized进行同步</p>\n<h4 id=\"2-比较\"><a href=\"#2-比较\" class=\"headerlink\" title=\"2.比较\"></a>2.比较</h4><p>因为使用synchronized同步，所以开销要比ArrayList大一些</p>\n<p>在使用方面，可使用Collections.synchronizedList()和CopyOnWriteArrayList代替</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><h4 id=\"1-读写分离\"><a href=\"#1-读写分离\" class=\"headerlink\" title=\"1.读写分离\"></a>1.读写分离</h4><p>CopyOnWriteArrayList写操作时，加锁，将原有数组元素拷贝到一个新的数组中，写入元素，将原有数组指向新的数组，释放锁<br>读操作在原有数组中，读写分离，互不影响</p>\n<p>CopyOnWriteArrayList 存在内存占用和数据不一致性问题<br>所以它不适合内存敏感以及对实时性要求高的场景</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>基于双向链表实现</p>\n<p>和ArrayList的区别可以归结为数组和链表的区别</p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><h4 id=\"1-存储结构\"><a href=\"#1-存储结构\" class=\"headerlink\" title=\"1.存储结构\"></a>1.存储结构</h4><p>内部维护一个Node类型的数组，作为hash表；Node数据结构包含4个字段，有key、value、next指针、int型hash值</p>\n<p>数组的每一个位置被当做一个桶，一个桶存放一个链表。</p>\n<h4 id=\"2-拉链法的工作原理\"><a href=\"#2-拉链法的工作原理\" class=\"headerlink\" title=\"2.拉链法的工作原理\"></a>2.拉链法的工作原理</h4><p>哈希表为解决hash冲突有开放地址法和链地址法。比较来说，链地址法更适合于大规模数据和不确定性数据的存储，处理冲突简单且不易出现堆积问题，节省空间</p>\n<ul>\n<li>确定hash桶数组索引位置<br>key值取哈希值时采用高位运算使得hash值的高位通常也能参与到计算hash表值中，使用与运算代替取模提高一定的效率。</li>\n<li>HashMap的put方法<br>JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法<br><img src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png\" alt=\"\"></li>\n<li>扩容机制<br>在hash表容量扩大为两倍时，在rehash时有了一定的优化，在数组位置上只有一个元素时，rehash赋值到新的hash表；有多个元素时，根据扩容的位为1或0，进行优化</li>\n</ul>\n<h4 id=\"3-参看链接\"><a href=\"#3-参看链接\" class=\"headerlink\" title=\"3.参看链接\"></a>3.参看链接</h4><p><a href=\"https://tech.meituan.com/2016/06/24/java-hashmap.html\" target=\"_blank\" rel=\"noopener\">Java 8系列之重新认识HashMap</a><br><a href=\"https://www.jianshu.com/p/75adf47958a7\" target=\"_blank\" rel=\"noopener\">HashMap 相关面试题及其解答</a></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>\n<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>\n<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>\n<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>\n<p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>\n<pre><code>Q：HashMap，LinkedHashMap，TreeMap 有什么区别？\n\nA：HashMap 参考其他问题；\nLinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；\nTreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）\n\nQ：HashMap 和 HashTable 有什么区别？\n\nA：①、HashMap 是线程不安全的，HashTable 是线程安全的；\n②、由于线程安全，所以 HashTable 的效率比不上 HashMap；\n③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable 不允许；\n④、HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；\n⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</code></pre><h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><p><a href=\"https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/\" target=\"_blank\" rel=\"noopener\">jdk1.7版本的ConcurrentHashMap解析</a><br><a href=\"https://blog.csdn.net/weixin_44460333/article/details/86770169\" target=\"_blank\" rel=\"noopener\">HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！</a></p>"},{"title":"准备找暑期实习，至此时大约一个月","date":"2020-03-10T06:22:06.000Z","_content":"\n- 恍恍惚惚　\n从2.13号开始询问宇神如何制作简历，慌慌张张地制作完成简历，开始疯狂复习基础、刷面经。\n感觉自己啥都不会，看着面经都有点不知道该怎么说。\n经过一周多不到两周的准备，大约有点知识储备了，开始投阿里的提前批。第一次面试，面的十分僵硬，\ntcp　http 没怎么准备，好多问题不清楚。<br><!--more-->\n开始查漏补缺，看基础、源码。\n\n- 底气不足\n现在，面了阿里的几个部门都是一面没有问题，钉钉在等hr面，互动平台明天二面。还没有投其他公司，打算今明两天开始投其他大厂。\n感觉面试的几个组成部分，java spring jvm　并发　数据库　网络　分布式。\n这几块中，数据库是我最薄弱的部分，同时分布式以及中间件也掌握的不行，接下来重点准备这一部分，同时深入学习下netty\n\n- 阶段总结\n这一个月以来，学习效率不是很高，有时候压力有点大，总是忍不住出去喘口气。\n投简历这一块，还是要多投，多找机会。之前投了３个部门就感觉很多了，想集中精力学习，不再投递。\n后面才明白，多投递一次简历就多一次机会，可能再等这个部门的同时，另一个部门已经终面了。\n回过头来看看，没想到两周前自己的想法有很大问题。\n还是得仔细琢磨积极主动的意思。","source":"_posts/准备找暑期实习，至此时大约一个月.md","raw":"---\ntitle: 准备找暑期实习，至此时大约一个月\ndate: 2020-03-10 14:22:06\ncategories: 程序人生\ntags:\n---\n\n- 恍恍惚惚　\n从2.13号开始询问宇神如何制作简历，慌慌张张地制作完成简历，开始疯狂复习基础、刷面经。\n感觉自己啥都不会，看着面经都有点不知道该怎么说。\n经过一周多不到两周的准备，大约有点知识储备了，开始投阿里的提前批。第一次面试，面的十分僵硬，\ntcp　http 没怎么准备，好多问题不清楚。<br><!--more-->\n开始查漏补缺，看基础、源码。\n\n- 底气不足\n现在，面了阿里的几个部门都是一面没有问题，钉钉在等hr面，互动平台明天二面。还没有投其他公司，打算今明两天开始投其他大厂。\n感觉面试的几个组成部分，java spring jvm　并发　数据库　网络　分布式。\n这几块中，数据库是我最薄弱的部分，同时分布式以及中间件也掌握的不行，接下来重点准备这一部分，同时深入学习下netty\n\n- 阶段总结\n这一个月以来，学习效率不是很高，有时候压力有点大，总是忍不住出去喘口气。\n投简历这一块，还是要多投，多找机会。之前投了３个部门就感觉很多了，想集中精力学习，不再投递。\n后面才明白，多投递一次简历就多一次机会，可能再等这个部门的同时，另一个部门已经终面了。\n回过头来看看，没想到两周前自己的想法有很大问题。\n还是得仔细琢磨积极主动的意思。","slug":"准备找暑期实习，至此时大约一个月","published":1,"updated":"2020-03-10T08:00:04.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7f001i9oet98vehwlc","content":"<ul>\n<li><p>恍恍惚惚　<br>从2.13号开始询问宇神如何制作简历，慌慌张张地制作完成简历，开始疯狂复习基础、刷面经。<br>感觉自己啥都不会，看着面经都有点不知道该怎么说。<br>经过一周多不到两周的准备，大约有点知识储备了，开始投阿里的提前批。第一次面试，面的十分僵硬，<br>tcp　http 没怎么准备，好多问题不清楚。<br><a id=\"more\"></a><br>开始查漏补缺，看基础、源码。</p>\n</li>\n<li><p>底气不足<br>现在，面了阿里的几个部门都是一面没有问题，钉钉在等hr面，互动平台明天二面。还没有投其他公司，打算今明两天开始投其他大厂。<br>感觉面试的几个组成部分，java spring jvm　并发　数据库　网络　分布式。<br>这几块中，数据库是我最薄弱的部分，同时分布式以及中间件也掌握的不行，接下来重点准备这一部分，同时深入学习下netty</p>\n</li>\n<li><p>阶段总结<br>这一个月以来，学习效率不是很高，有时候压力有点大，总是忍不住出去喘口气。<br>投简历这一块，还是要多投，多找机会。之前投了３个部门就感觉很多了，想集中精力学习，不再投递。<br>后面才明白，多投递一次简历就多一次机会，可能再等这个部门的同时，另一个部门已经终面了。<br>回过头来看看，没想到两周前自己的想法有很大问题。<br>还是得仔细琢磨积极主动的意思。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>恍恍惚惚　<br>从2.13号开始询问宇神如何制作简历，慌慌张张地制作完成简历，开始疯狂复习基础、刷面经。<br>感觉自己啥都不会，看着面经都有点不知道该怎么说。<br>经过一周多不到两周的准备，大约有点知识储备了，开始投阿里的提前批。第一次面试，面的十分僵硬，<br>tcp　http 没怎么准备，好多问题不清楚。<br></p></li></ul>","more":"<br>开始查漏补缺，看基础、源码。</p>\n</li>\n<li><p>底气不足<br>现在，面了阿里的几个部门都是一面没有问题，钉钉在等hr面，互动平台明天二面。还没有投其他公司，打算今明两天开始投其他大厂。<br>感觉面试的几个组成部分，java spring jvm　并发　数据库　网络　分布式。<br>这几块中，数据库是我最薄弱的部分，同时分布式以及中间件也掌握的不行，接下来重点准备这一部分，同时深入学习下netty</p>\n</li>\n<li><p>阶段总结<br>这一个月以来，学习效率不是很高，有时候压力有点大，总是忍不住出去喘口气。<br>投简历这一块，还是要多投，多找机会。之前投了３个部门就感觉很多了，想集中精力学习，不再投递。<br>后面才明白，多投递一次简历就多一次机会，可能再等这个部门的同时，另一个部门已经终面了。<br>回过头来看看，没想到两周前自己的想法有很大问题。<br>还是得仔细琢磨积极主动的意思。</p>\n</li>\n</ul>"},{"title":"java内存分配","date":"2019-12-04T14:09:38.000Z","_content":"\n### java内存区域\n\n线程私有的：程序计数器、虚拟机栈、本地方法栈\n线程公有的：方法区、堆\n\n- 程序计数器\n\n和操作系统的程序计数器类似，用于控制程序执行步数，计算跳转内存地址\n\n- 虚拟机栈\n\n用来存储方法执行时的局部变量、动态链接、方法出口等。\n\n- 本地方法栈\n\n用来存储java JNI调用的native方法的相关信息，和虚拟机栈类似\n\n<!--more-->\n\n- 方法区\n\n用来存储常量、静态变量、类信息等信息，通俗来讲存储类的通用的模板数据\n\n- 堆\n\n存储几乎所有的实例化对象和数组，包括对象的实例变量。\n\nJava7之后，String Pool被移到堆内，因为永久代空间有限，在大量使用字符串的场景下会出现OutOfMemoryError错误\n\n- 直接内存\n\n这不是虚拟机数据区的一部分，属于堆外内存。这样可以避免在java堆和native堆中来回复制数据。\n\n### java内存模型\n\n对于线程共享的静态变量、实例变量、和构成数组对象的元素是存储在堆中，算是常说的主内存。\n而每个线程使用这些变量的时候则需要将其读取复制到自身的工作内存，处理后再写会主内存。\n所以会有变量可见性问题，即不能及时看到变化。\n对于关键字volatile来说，其修饰的变量读写直接在主内存中，不涉及到工作内存的读写，所有是保证可见性的。","source":"_posts/java内存分配.md","raw":"---\ntitle: java内存分配\ndate: 2019-12-04 22:09:38\ncategories: Java\n---\n\n### java内存区域\n\n线程私有的：程序计数器、虚拟机栈、本地方法栈\n线程公有的：方法区、堆\n\n- 程序计数器\n\n和操作系统的程序计数器类似，用于控制程序执行步数，计算跳转内存地址\n\n- 虚拟机栈\n\n用来存储方法执行时的局部变量、动态链接、方法出口等。\n\n- 本地方法栈\n\n用来存储java JNI调用的native方法的相关信息，和虚拟机栈类似\n\n<!--more-->\n\n- 方法区\n\n用来存储常量、静态变量、类信息等信息，通俗来讲存储类的通用的模板数据\n\n- 堆\n\n存储几乎所有的实例化对象和数组，包括对象的实例变量。\n\nJava7之后，String Pool被移到堆内，因为永久代空间有限，在大量使用字符串的场景下会出现OutOfMemoryError错误\n\n- 直接内存\n\n这不是虚拟机数据区的一部分，属于堆外内存。这样可以避免在java堆和native堆中来回复制数据。\n\n### java内存模型\n\n对于线程共享的静态变量、实例变量、和构成数组对象的元素是存储在堆中，算是常说的主内存。\n而每个线程使用这些变量的时候则需要将其读取复制到自身的工作内存，处理后再写会主内存。\n所以会有变量可见性问题，即不能及时看到变化。\n对于关键字volatile来说，其修饰的变量读写直接在主内存中，不涉及到工作内存的读写，所有是保证可见性的。","slug":"java内存分配","published":1,"updated":"2020-01-06T13:16:32.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7h001l9oet5jo4acrw","content":"<h3 id=\"java内存区域\"><a href=\"#java内存区域\" class=\"headerlink\" title=\"java内存区域\"></a>java内存区域</h3><p>线程私有的：程序计数器、虚拟机栈、本地方法栈<br>线程公有的：方法区、堆</p>\n<ul>\n<li>程序计数器</li>\n</ul>\n<p>和操作系统的程序计数器类似，用于控制程序执行步数，计算跳转内存地址</p>\n<ul>\n<li>虚拟机栈</li>\n</ul>\n<p>用来存储方法执行时的局部变量、动态链接、方法出口等。</p>\n<ul>\n<li>本地方法栈</li>\n</ul>\n<p>用来存储java JNI调用的native方法的相关信息，和虚拟机栈类似</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>方法区</li>\n</ul>\n<p>用来存储常量、静态变量、类信息等信息，通俗来讲存储类的通用的模板数据</p>\n<ul>\n<li>堆</li>\n</ul>\n<p>存储几乎所有的实例化对象和数组，包括对象的实例变量。</p>\n<p>Java7之后，String Pool被移到堆内，因为永久代空间有限，在大量使用字符串的场景下会出现OutOfMemoryError错误</p>\n<ul>\n<li>直接内存</li>\n</ul>\n<p>这不是虚拟机数据区的一部分，属于堆外内存。这样可以避免在java堆和native堆中来回复制数据。</p>\n<h3 id=\"java内存模型\"><a href=\"#java内存模型\" class=\"headerlink\" title=\"java内存模型\"></a>java内存模型</h3><p>对于线程共享的静态变量、实例变量、和构成数组对象的元素是存储在堆中，算是常说的主内存。<br>而每个线程使用这些变量的时候则需要将其读取复制到自身的工作内存，处理后再写会主内存。<br>所以会有变量可见性问题，即不能及时看到变化。<br>对于关键字volatile来说，其修饰的变量读写直接在主内存中，不涉及到工作内存的读写，所有是保证可见性的。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"java内存区域\"><a href=\"#java内存区域\" class=\"headerlink\" title=\"java内存区域\"></a>java内存区域</h3><p>线程私有的：程序计数器、虚拟机栈、本地方法栈<br>线程公有的：方法区、堆</p>\n<ul>\n<li>程序计数器</li>\n</ul>\n<p>和操作系统的程序计数器类似，用于控制程序执行步数，计算跳转内存地址</p>\n<ul>\n<li>虚拟机栈</li>\n</ul>\n<p>用来存储方法执行时的局部变量、动态链接、方法出口等。</p>\n<ul>\n<li>本地方法栈</li>\n</ul>\n<p>用来存储java JNI调用的native方法的相关信息，和虚拟机栈类似</p>","more":"<ul>\n<li>方法区</li>\n</ul>\n<p>用来存储常量、静态变量、类信息等信息，通俗来讲存储类的通用的模板数据</p>\n<ul>\n<li>堆</li>\n</ul>\n<p>存储几乎所有的实例化对象和数组，包括对象的实例变量。</p>\n<p>Java7之后，String Pool被移到堆内，因为永久代空间有限，在大量使用字符串的场景下会出现OutOfMemoryError错误</p>\n<ul>\n<li>直接内存</li>\n</ul>\n<p>这不是虚拟机数据区的一部分，属于堆外内存。这样可以避免在java堆和native堆中来回复制数据。</p>\n<h3 id=\"java内存模型\"><a href=\"#java内存模型\" class=\"headerlink\" title=\"java内存模型\"></a>java内存模型</h3><p>对于线程共享的静态变量、实例变量、和构成数组对象的元素是存储在堆中，算是常说的主内存。<br>而每个线程使用这些变量的时候则需要将其读取复制到自身的工作内存，处理后再写会主内存。<br>所以会有变量可见性问题，即不能及时看到变化。<br>对于关键字volatile来说，其修饰的变量读写直接在主内存中，不涉及到工作内存的读写，所有是保证可见性的。</p>"},{"title":"Java基础","date":"2019-12-30T13:24:11.000Z","_content":"\n### 一、 数据类型\n\n#### 基本类型\n\n- byte 8\n- short 16\n- char 16\n- int 32\n- float 32\n- long 64\n- double 64\n- boolean ~\n\nboolean类型可以使用1bit来存储，但是具体大小没有明确规定。jvm会在编译时期将boolean类型转int，使用1 0 表示。\n\n<!--more-->\n#### 缓存池\n\n基本类型对应的缓存池如下：\n\n- boolean true false\n- short -128 and 127\n- int -128 and 127\n- char in the range \\u0000 to \\u007F\n\n以Integer为例子， new Integer()将新增一个对象，而Integer.valueOf()则会首先在缓存池里选取。\n\n### 二、 String\n\n#### String Pool\n\n字符串常量池保存着所有的字符串字面量。一般来说，这些字面量编译期就确定。也可以使用String.intern()在\n运行时期将字符串添加到String Pool中。\n\n\n### 三、 运算\n\n#### 参数传递\n\njava中的参数传递是以值传递的方式，而不是引用传递。\n可以认为传递的参数是针对原有引用存储值的拷贝，并不是原来的引用。\n\n### 四、 关键字\n\n#### final\n\n声明数据为常量\n- 对于基本类型，final使数据不变\n- 对于引用类型，final是引用不变，即不可引用其他对象，但被引用的对象可以修改\n\n声明方法不能被子类重写\nprivate方法隐式地定义为final，如果子类中出现和基类的一个private方法名相同的方法，不是对基类方法的重写，而是新定义的一个方法\n\n声明类不允许被继承\n\n#### static\n\n静态方法必须有实现，不能还是抽象方法\n静态方法中不能有this super关键字，这两个关键字与具体对象关联\n\n静态代码块在类初始化时运行一次\n\n初始化顺序：\n静态变量和静态代码块优于实例变量和普通代码块，构造函数最后初始化\n\n存在继承的情况下，初始化顺序为：\n- 父类 （静态变量、静态代码块）\n- 子类 （静态变量、静态代码块）\n- 父类 （实例变量、普通代码块）\n- 父类 （构造函数）\n- 子类 （实例变量、普通代码块）\n- 子类 （构造函数）\n\n### 五、 Object通用方法\n\n#### equals()\n\n实现：\n- 检查是否为同一个对象的引用，如果是直接返回true\n- 检查是否为同一种类型，如果不是直接返回false\n- 将Object对象进行转型\n- 判断每个关键字段是否相等\n\n```java\npublic class Example{\n    int a;\n    int b;\n    \n    @Override\n    public boolean equals(Object o){\n        if(this == o ) return true;\n        if(o ==null || getClass() != o.getClass()) return false;\n        Example that = (Example) o;\n        if(this.a == that.a && this.b == that.b)\n            return true;\n        else\n            return false;\n    }\n}\n```\n\n\n#### hashCode()\n\n等价的两个对象散列值一定相等\n在覆盖equals()方法时应当总是覆盖hashCode()方法，保证等价的两个对象哈希值也相等。\n\n理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求\n了哈希函数要把所有域的值都考虑进来。可以将每个域都当成R进制的某一位，然后组成一个R进制\n的整数。\n```java\n@Override\npublic int hashCode(){\n    int result = 17;\n    result = 31 * result + x;\n    result = 31 * result + y;\n    result = 31 * result + z;\n    return result;\n}\n```\n\n#### clone()\n\n**1.cloneable**\n\nclone()是Object的project方法，一个类没有重写Clone()方法，其他类就不能直接去调用该\n类实例的Clone()方法。还需要实现Cloneable接口。\n\n**2.浅拷贝与深拷贝**\n\n浅拷贝：原始对象和拷贝对象引用指向同一个对象\n深拷贝：原始对象和拷贝对象引用指向不同的对象\n\n上文中的clone()方法通常是对依照原始对象new一个新的拷贝对象，然后根据原始对象的每个域\n复制给拷贝对象。\n\n**3.clone()的替代方案**\n使用clone()方法比较复杂，最好不要使用clone()，可以使用拷贝构造函数或者拷贝工厂\n来拷贝一个对象\n\n也可以使用序列化的方式拷贝\n\n### 六、继承\n\n#### 抽象类与接口\n\n**1.抽象类**\n如果一个类中包含抽象方法，那这个类必须声明为抽象类\n抽象类和普通类最大的区别是抽象类不能被实例化，只能被继承\n\n**2.接口**\n\n接口的成员(字段+方法)默认都是public的，并且不允许定义为private和protected\n接口的字段默认都是static和final的\n\n**3.比较**\n\n- 从设计层面看，抽象类提供一种is-a关系，需要满足里氏代换原则，即子类对象必须\n能够替换掉所有父类对象；接口更像是一种like-a关系\n- 从使用上看，一个类可以实现多个接口，但是不能继承多个抽象类。\n- 接口字段只能是static和final类型的，抽象类没有限制\n- 接口的成员只能是public的，抽象类成员可有多种访问权限\n\n### 七、泛型\n\n使用泛型的好处：\n1.在集合中存储对象并在使用前进行类型转换不方便，泛型提供了编译期间的类型安全，\n确保能能够把正确类型的对象放入到集合中\n<br>\n2.在写业务封装对象时，泛型可以提供限定某种类型\n\n[10道java泛型面试题](https://cloud.tencent.com/developer/article/1033693)\n","source":"_posts/Java数据类型.md","raw":"---\ntitle: Java基础\ndate: 2019-12-30 21:24:11\ncategories: Java\ntags: Java\n---\n\n### 一、 数据类型\n\n#### 基本类型\n\n- byte 8\n- short 16\n- char 16\n- int 32\n- float 32\n- long 64\n- double 64\n- boolean ~\n\nboolean类型可以使用1bit来存储，但是具体大小没有明确规定。jvm会在编译时期将boolean类型转int，使用1 0 表示。\n\n<!--more-->\n#### 缓存池\n\n基本类型对应的缓存池如下：\n\n- boolean true false\n- short -128 and 127\n- int -128 and 127\n- char in the range \\u0000 to \\u007F\n\n以Integer为例子， new Integer()将新增一个对象，而Integer.valueOf()则会首先在缓存池里选取。\n\n### 二、 String\n\n#### String Pool\n\n字符串常量池保存着所有的字符串字面量。一般来说，这些字面量编译期就确定。也可以使用String.intern()在\n运行时期将字符串添加到String Pool中。\n\n\n### 三、 运算\n\n#### 参数传递\n\njava中的参数传递是以值传递的方式，而不是引用传递。\n可以认为传递的参数是针对原有引用存储值的拷贝，并不是原来的引用。\n\n### 四、 关键字\n\n#### final\n\n声明数据为常量\n- 对于基本类型，final使数据不变\n- 对于引用类型，final是引用不变，即不可引用其他对象，但被引用的对象可以修改\n\n声明方法不能被子类重写\nprivate方法隐式地定义为final，如果子类中出现和基类的一个private方法名相同的方法，不是对基类方法的重写，而是新定义的一个方法\n\n声明类不允许被继承\n\n#### static\n\n静态方法必须有实现，不能还是抽象方法\n静态方法中不能有this super关键字，这两个关键字与具体对象关联\n\n静态代码块在类初始化时运行一次\n\n初始化顺序：\n静态变量和静态代码块优于实例变量和普通代码块，构造函数最后初始化\n\n存在继承的情况下，初始化顺序为：\n- 父类 （静态变量、静态代码块）\n- 子类 （静态变量、静态代码块）\n- 父类 （实例变量、普通代码块）\n- 父类 （构造函数）\n- 子类 （实例变量、普通代码块）\n- 子类 （构造函数）\n\n### 五、 Object通用方法\n\n#### equals()\n\n实现：\n- 检查是否为同一个对象的引用，如果是直接返回true\n- 检查是否为同一种类型，如果不是直接返回false\n- 将Object对象进行转型\n- 判断每个关键字段是否相等\n\n```java\npublic class Example{\n    int a;\n    int b;\n    \n    @Override\n    public boolean equals(Object o){\n        if(this == o ) return true;\n        if(o ==null || getClass() != o.getClass()) return false;\n        Example that = (Example) o;\n        if(this.a == that.a && this.b == that.b)\n            return true;\n        else\n            return false;\n    }\n}\n```\n\n\n#### hashCode()\n\n等价的两个对象散列值一定相等\n在覆盖equals()方法时应当总是覆盖hashCode()方法，保证等价的两个对象哈希值也相等。\n\n理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求\n了哈希函数要把所有域的值都考虑进来。可以将每个域都当成R进制的某一位，然后组成一个R进制\n的整数。\n```java\n@Override\npublic int hashCode(){\n    int result = 17;\n    result = 31 * result + x;\n    result = 31 * result + y;\n    result = 31 * result + z;\n    return result;\n}\n```\n\n#### clone()\n\n**1.cloneable**\n\nclone()是Object的project方法，一个类没有重写Clone()方法，其他类就不能直接去调用该\n类实例的Clone()方法。还需要实现Cloneable接口。\n\n**2.浅拷贝与深拷贝**\n\n浅拷贝：原始对象和拷贝对象引用指向同一个对象\n深拷贝：原始对象和拷贝对象引用指向不同的对象\n\n上文中的clone()方法通常是对依照原始对象new一个新的拷贝对象，然后根据原始对象的每个域\n复制给拷贝对象。\n\n**3.clone()的替代方案**\n使用clone()方法比较复杂，最好不要使用clone()，可以使用拷贝构造函数或者拷贝工厂\n来拷贝一个对象\n\n也可以使用序列化的方式拷贝\n\n### 六、继承\n\n#### 抽象类与接口\n\n**1.抽象类**\n如果一个类中包含抽象方法，那这个类必须声明为抽象类\n抽象类和普通类最大的区别是抽象类不能被实例化，只能被继承\n\n**2.接口**\n\n接口的成员(字段+方法)默认都是public的，并且不允许定义为private和protected\n接口的字段默认都是static和final的\n\n**3.比较**\n\n- 从设计层面看，抽象类提供一种is-a关系，需要满足里氏代换原则，即子类对象必须\n能够替换掉所有父类对象；接口更像是一种like-a关系\n- 从使用上看，一个类可以实现多个接口，但是不能继承多个抽象类。\n- 接口字段只能是static和final类型的，抽象类没有限制\n- 接口的成员只能是public的，抽象类成员可有多种访问权限\n\n### 七、泛型\n\n使用泛型的好处：\n1.在集合中存储对象并在使用前进行类型转换不方便，泛型提供了编译期间的类型安全，\n确保能能够把正确类型的对象放入到集合中\n<br>\n2.在写业务封装对象时，泛型可以提供限定某种类型\n\n[10道java泛型面试题](https://cloud.tencent.com/developer/article/1033693)\n","slug":"Java数据类型","published":1,"updated":"2020-01-06T13:16:32.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7o001p9oetc32y6066","content":"<h3 id=\"一、-数据类型\"><a href=\"#一、-数据类型\" class=\"headerlink\" title=\"一、 数据类型\"></a>一、 数据类型</h3><h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><ul>\n<li>byte 8</li>\n<li>short 16</li>\n<li>char 16</li>\n<li>int 32</li>\n<li>float 32</li>\n<li>long 64</li>\n<li>double 64</li>\n<li>boolean ~</li>\n</ul>\n<p>boolean类型可以使用1bit来存储，但是具体大小没有明确规定。jvm会在编译时期将boolean类型转int，使用1 0 表示。</p>\n<a id=\"more\"></a>\n<h4 id=\"缓存池\"><a href=\"#缓存池\" class=\"headerlink\" title=\"缓存池\"></a>缓存池</h4><p>基本类型对应的缓存池如下：</p>\n<ul>\n<li>boolean true false</li>\n<li>short -128 and 127</li>\n<li>int -128 and 127</li>\n<li>char in the range \\u0000 to \\u007F</li>\n</ul>\n<p>以Integer为例子， new Integer()将新增一个对象，而Integer.valueOf()则会首先在缓存池里选取。</p>\n<h3 id=\"二、-String\"><a href=\"#二、-String\" class=\"headerlink\" title=\"二、 String\"></a>二、 String</h3><h4 id=\"String-Pool\"><a href=\"#String-Pool\" class=\"headerlink\" title=\"String Pool\"></a>String Pool</h4><p>字符串常量池保存着所有的字符串字面量。一般来说，这些字面量编译期就确定。也可以使用String.intern()在<br>运行时期将字符串添加到String Pool中。</p>\n<h3 id=\"三、-运算\"><a href=\"#三、-运算\" class=\"headerlink\" title=\"三、 运算\"></a>三、 运算</h3><h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><p>java中的参数传递是以值传递的方式，而不是引用传递。<br>可以认为传递的参数是针对原有引用存储值的拷贝，并不是原来的引用。</p>\n<h3 id=\"四、-关键字\"><a href=\"#四、-关键字\" class=\"headerlink\" title=\"四、 关键字\"></a>四、 关键字</h3><h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>声明数据为常量</p>\n<ul>\n<li>对于基本类型，final使数据不变</li>\n<li>对于引用类型，final是引用不变，即不可引用其他对象，但被引用的对象可以修改</li>\n</ul>\n<p>声明方法不能被子类重写<br>private方法隐式地定义为final，如果子类中出现和基类的一个private方法名相同的方法，不是对基类方法的重写，而是新定义的一个方法</p>\n<p>声明类不允许被继承</p>\n<h4 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h4><p>静态方法必须有实现，不能还是抽象方法<br>静态方法中不能有this super关键字，这两个关键字与具体对象关联</p>\n<p>静态代码块在类初始化时运行一次</p>\n<p>初始化顺序：<br>静态变量和静态代码块优于实例变量和普通代码块，构造函数最后初始化</p>\n<p>存在继承的情况下，初始化顺序为：</p>\n<ul>\n<li>父类 （静态变量、静态代码块）</li>\n<li>子类 （静态变量、静态代码块）</li>\n<li>父类 （实例变量、普通代码块）</li>\n<li>父类 （构造函数）</li>\n<li>子类 （实例变量、普通代码块）</li>\n<li>子类 （构造函数）</li>\n</ul>\n<h3 id=\"五、-Object通用方法\"><a href=\"#五、-Object通用方法\" class=\"headerlink\" title=\"五、 Object通用方法\"></a>五、 Object通用方法</h3><h4 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals()\"></a>equals()</h4><p>实现：</p>\n<ul>\n<li>检查是否为同一个对象的引用，如果是直接返回true</li>\n<li>检查是否为同一种类型，如果不是直接返回false</li>\n<li>将Object对象进行转型</li>\n<li>判断每个关键字段是否相等</li>\n</ul>\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Example</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">int</span> a;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">int</span> b;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-meta\">@Override</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">equals</span><span class=\"hljs-params\">(Object o)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span> == o ) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">if</span>(o ==<span class=\"hljs-keyword\">null</span> || getClass() != o.getClass()) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">        Example that = (Example) o;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.a == that.a &amp;&amp; <span class=\"hljs-keyword\">this</span>.b == that.b)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>\n\n\n<h4 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\"hashCode()\"></a>hashCode()</h4><p>等价的两个对象散列值一定相等<br>在覆盖equals()方法时应当总是覆盖hashCode()方法，保证等价的两个对象哈希值也相等。</p>\n<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求<br>了哈希函数要把所有域的值都考虑进来。可以将每个域都当成R进制的某一位，然后组成一个R进制<br>的整数。</p>\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-meta\">@Override</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hashCode</span><span class=\"hljs-params\">()</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">17</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    result = <span class=\"hljs-number\">31</span> * result + x;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    result = <span class=\"hljs-number\">31</span> * result + y;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">    result = <span class=\"hljs-number\">31</span> * result + z;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">return</span> result;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>\n\n<h4 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone()\"></a>clone()</h4><p><strong>1.cloneable</strong></p>\n<p>clone()是Object的project方法，一个类没有重写Clone()方法，其他类就不能直接去调用该<br>类实例的Clone()方法。还需要实现Cloneable接口。</p>\n<p><strong>2.浅拷贝与深拷贝</strong></p>\n<p>浅拷贝：原始对象和拷贝对象引用指向同一个对象<br>深拷贝：原始对象和拷贝对象引用指向不同的对象</p>\n<p>上文中的clone()方法通常是对依照原始对象new一个新的拷贝对象，然后根据原始对象的每个域<br>复制给拷贝对象。</p>\n<p><strong>3.clone()的替代方案</strong><br>使用clone()方法比较复杂，最好不要使用clone()，可以使用拷贝构造函数或者拷贝工厂<br>来拷贝一个对象</p>\n<p>也可以使用序列化的方式拷贝</p>\n<h3 id=\"六、继承\"><a href=\"#六、继承\" class=\"headerlink\" title=\"六、继承\"></a>六、继承</h3><h4 id=\"抽象类与接口\"><a href=\"#抽象类与接口\" class=\"headerlink\" title=\"抽象类与接口\"></a>抽象类与接口</h4><p><strong>1.抽象类</strong><br>如果一个类中包含抽象方法，那这个类必须声明为抽象类<br>抽象类和普通类最大的区别是抽象类不能被实例化，只能被继承</p>\n<p><strong>2.接口</strong></p>\n<p>接口的成员(字段+方法)默认都是public的，并且不允许定义为private和protected<br>接口的字段默认都是static和final的</p>\n<p><strong>3.比较</strong></p>\n<ul>\n<li>从设计层面看，抽象类提供一种is-a关系，需要满足里氏代换原则，即子类对象必须<br>能够替换掉所有父类对象；接口更像是一种like-a关系</li>\n<li>从使用上看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>\n<li>接口字段只能是static和final类型的，抽象类没有限制</li>\n<li>接口的成员只能是public的，抽象类成员可有多种访问权限</li>\n</ul>\n<h3 id=\"七、泛型\"><a href=\"#七、泛型\" class=\"headerlink\" title=\"七、泛型\"></a>七、泛型</h3><p>使用泛型的好处：<br>1.在集合中存储对象并在使用前进行类型转换不方便，泛型提供了编译期间的类型安全，<br>确保能能够把正确类型的对象放入到集合中<br><br><br>2.在写业务封装对象时，泛型可以提供限定某种类型</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1033693\" target=\"_blank\" rel=\"noopener\">10道java泛型面试题</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、-数据类型\"><a href=\"#一、-数据类型\" class=\"headerlink\" title=\"一、 数据类型\"></a>一、 数据类型</h3><h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><ul>\n<li>byte 8</li>\n<li>short 16</li>\n<li>char 16</li>\n<li>int 32</li>\n<li>float 32</li>\n<li>long 64</li>\n<li>double 64</li>\n<li>boolean ~</li>\n</ul>\n<p>boolean类型可以使用1bit来存储，但是具体大小没有明确规定。jvm会在编译时期将boolean类型转int，使用1 0 表示。</p>","more":"<h4 id=\"缓存池\"><a href=\"#缓存池\" class=\"headerlink\" title=\"缓存池\"></a>缓存池</h4><p>基本类型对应的缓存池如下：</p>\n<ul>\n<li>boolean true false</li>\n<li>short -128 and 127</li>\n<li>int -128 and 127</li>\n<li>char in the range \\u0000 to \\u007F</li>\n</ul>\n<p>以Integer为例子， new Integer()将新增一个对象，而Integer.valueOf()则会首先在缓存池里选取。</p>\n<h3 id=\"二、-String\"><a href=\"#二、-String\" class=\"headerlink\" title=\"二、 String\"></a>二、 String</h3><h4 id=\"String-Pool\"><a href=\"#String-Pool\" class=\"headerlink\" title=\"String Pool\"></a>String Pool</h4><p>字符串常量池保存着所有的字符串字面量。一般来说，这些字面量编译期就确定。也可以使用String.intern()在<br>运行时期将字符串添加到String Pool中。</p>\n<h3 id=\"三、-运算\"><a href=\"#三、-运算\" class=\"headerlink\" title=\"三、 运算\"></a>三、 运算</h3><h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><p>java中的参数传递是以值传递的方式，而不是引用传递。<br>可以认为传递的参数是针对原有引用存储值的拷贝，并不是原来的引用。</p>\n<h3 id=\"四、-关键字\"><a href=\"#四、-关键字\" class=\"headerlink\" title=\"四、 关键字\"></a>四、 关键字</h3><h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>声明数据为常量</p>\n<ul>\n<li>对于基本类型，final使数据不变</li>\n<li>对于引用类型，final是引用不变，即不可引用其他对象，但被引用的对象可以修改</li>\n</ul>\n<p>声明方法不能被子类重写<br>private方法隐式地定义为final，如果子类中出现和基类的一个private方法名相同的方法，不是对基类方法的重写，而是新定义的一个方法</p>\n<p>声明类不允许被继承</p>\n<h4 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h4><p>静态方法必须有实现，不能还是抽象方法<br>静态方法中不能有this super关键字，这两个关键字与具体对象关联</p>\n<p>静态代码块在类初始化时运行一次</p>\n<p>初始化顺序：<br>静态变量和静态代码块优于实例变量和普通代码块，构造函数最后初始化</p>\n<p>存在继承的情况下，初始化顺序为：</p>\n<ul>\n<li>父类 （静态变量、静态代码块）</li>\n<li>子类 （静态变量、静态代码块）</li>\n<li>父类 （实例变量、普通代码块）</li>\n<li>父类 （构造函数）</li>\n<li>子类 （实例变量、普通代码块）</li>\n<li>子类 （构造函数）</li>\n</ul>\n<h3 id=\"五、-Object通用方法\"><a href=\"#五、-Object通用方法\" class=\"headerlink\" title=\"五、 Object通用方法\"></a>五、 Object通用方法</h3><h4 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals()\"></a>equals()</h4><p>实现：</p>\n<ul>\n<li>检查是否为同一个对象的引用，如果是直接返回true</li>\n<li>检查是否为同一种类型，如果不是直接返回false</li>\n<li>将Object对象进行转型</li>\n<li>判断每个关键字段是否相等</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">int</span> a;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">int</span> b;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Override</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == o ) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">if</span>(o ==<span class=\"keyword\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">        Example that = (Example) o;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.a == that.a &amp;&amp; <span class=\"keyword\">this</span>.b == that.b)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">else</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>\n\n\n<h4 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\"hashCode()\"></a>hashCode()</h4><p>等价的两个对象散列值一定相等<br>在覆盖equals()方法时应当总是覆盖hashCode()方法，保证等价的两个对象哈希值也相等。</p>\n<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求<br>了哈希函数要把所有域的值都考虑进来。可以将每个域都当成R进制的某一位，然后组成一个R进制<br>的整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">17</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    result = <span class=\"number\">31</span> * result + x;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    result = <span class=\"number\">31</span> * result + y;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">    result = <span class=\"number\">31</span> * result + z;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">return</span> result;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>\n\n<h4 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone()\"></a>clone()</h4><p><strong>1.cloneable</strong></p>\n<p>clone()是Object的project方法，一个类没有重写Clone()方法，其他类就不能直接去调用该<br>类实例的Clone()方法。还需要实现Cloneable接口。</p>\n<p><strong>2.浅拷贝与深拷贝</strong></p>\n<p>浅拷贝：原始对象和拷贝对象引用指向同一个对象<br>深拷贝：原始对象和拷贝对象引用指向不同的对象</p>\n<p>上文中的clone()方法通常是对依照原始对象new一个新的拷贝对象，然后根据原始对象的每个域<br>复制给拷贝对象。</p>\n<p><strong>3.clone()的替代方案</strong><br>使用clone()方法比较复杂，最好不要使用clone()，可以使用拷贝构造函数或者拷贝工厂<br>来拷贝一个对象</p>\n<p>也可以使用序列化的方式拷贝</p>\n<h3 id=\"六、继承\"><a href=\"#六、继承\" class=\"headerlink\" title=\"六、继承\"></a>六、继承</h3><h4 id=\"抽象类与接口\"><a href=\"#抽象类与接口\" class=\"headerlink\" title=\"抽象类与接口\"></a>抽象类与接口</h4><p><strong>1.抽象类</strong><br>如果一个类中包含抽象方法，那这个类必须声明为抽象类<br>抽象类和普通类最大的区别是抽象类不能被实例化，只能被继承</p>\n<p><strong>2.接口</strong></p>\n<p>接口的成员(字段+方法)默认都是public的，并且不允许定义为private和protected<br>接口的字段默认都是static和final的</p>\n<p><strong>3.比较</strong></p>\n<ul>\n<li>从设计层面看，抽象类提供一种is-a关系，需要满足里氏代换原则，即子类对象必须<br>能够替换掉所有父类对象；接口更像是一种like-a关系</li>\n<li>从使用上看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>\n<li>接口字段只能是static和final类型的，抽象类没有限制</li>\n<li>接口的成员只能是public的，抽象类成员可有多种访问权限</li>\n</ul>\n<h3 id=\"七、泛型\"><a href=\"#七、泛型\" class=\"headerlink\" title=\"七、泛型\"></a>七、泛型</h3><p>使用泛型的好处：<br>1.在集合中存储对象并在使用前进行类型转换不方便，泛型提供了编译期间的类型安全，<br>确保能能够把正确类型的对象放入到集合中<br><br><br>2.在写业务封装对象时，泛型可以提供限定某种类型</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1033693\" target=\"_blank\" rel=\"noopener\">10道java泛型面试题</a></p>"},{"title":"双亲委派模型类加载器问题","date":"2019-12-02T11:10:04.000Z","_content":"\n下图是关于类加载顺序的总结\n\n<!--more-->\n\n![](https://raw.githubusercontent.com/csxiaoshang/images/master/bolg/image1241399721.jpg)","source":"_posts/双亲委派模型类加载器问题.md","raw":"---\ntitle: 双亲委派模型类加载器问题\ndate: 2019-12-02 19:10:04\ncategories: Java\n---\n\n下图是关于类加载顺序的总结\n\n<!--more-->\n\n![](https://raw.githubusercontent.com/csxiaoshang/images/master/bolg/image1241399721.jpg)","slug":"双亲委派模型类加载器问题","published":1,"updated":"2020-01-21T08:15:22.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7r001r9oet1v1t25pz","content":"<p>下图是关于类加载顺序的总结</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://raw.githubusercontent.com/csxiaoshang/images/master/bolg/image1241399721.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<p>下图是关于类加载顺序的总结</p>","more":"<p><img src=\"https://raw.githubusercontent.com/csxiaoshang/images/master/bolg/image1241399721.jpg\" alt=\"\"></p>"},{"title":"gc","date":"2019-12-05T01:42:57.000Z","_content":"\n### 判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。\n引用计数器：\n当引用计数器为零的时候，表明没用引用再指向该对象，但是引用计数器不能解决循环引用的情况；\n可达性分析：\n1. 当不能从GC Root寻找一条路径到达该对象时， 将进行第一次标记。\n2. 第一次标记后检查对象是否重写了finalize() 和是否已经被调用了finalize()方法。若没有重写finalize()方法或已经被调用，则进行回收。\n3. 在已经重写finalize()方法且未调用的情况下，将对象加入一个F-Queue 的队列中，稍后进行第二次检查。\n4. 在第二次标记之前，对象如果执行finalize()方法并完成自救，对象则不会被回收。否则完成第二次标记，进行回收。值得注意的是finalize()方法并不可靠。","source":"_posts/gc.md","raw":"---\ntitle: gc\ndate: 2019-12-05 09:42:57\ncategories: Java\n---\n\n### 判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。\n引用计数器：\n当引用计数器为零的时候，表明没用引用再指向该对象，但是引用计数器不能解决循环引用的情况；\n可达性分析：\n1. 当不能从GC Root寻找一条路径到达该对象时， 将进行第一次标记。\n2. 第一次标记后检查对象是否重写了finalize() 和是否已经被调用了finalize()方法。若没有重写finalize()方法或已经被调用，则进行回收。\n3. 在已经重写finalize()方法且未调用的情况下，将对象加入一个F-Queue 的队列中，稍后进行第二次检查。\n4. 在第二次标记之前，对象如果执行finalize()方法并完成自救，对象则不会被回收。否则完成第二次标记，进行回收。值得注意的是finalize()方法并不可靠。","slug":"gc","published":1,"updated":"2020-01-21T08:15:22.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7t001v9oet17kr3hk9","content":"<h3 id=\"判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。\"><a href=\"#判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。\" class=\"headerlink\" title=\"判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。\"></a>判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。</h3><p>引用计数器：<br>当引用计数器为零的时候，表明没用引用再指向该对象，但是引用计数器不能解决循环引用的情况；<br>可达性分析：</p>\n<ol>\n<li>当不能从GC Root寻找一条路径到达该对象时， 将进行第一次标记。</li>\n<li>第一次标记后检查对象是否重写了finalize() 和是否已经被调用了finalize()方法。若没有重写finalize()方法或已经被调用，则进行回收。</li>\n<li>在已经重写finalize()方法且未调用的情况下，将对象加入一个F-Queue 的队列中，稍后进行第二次检查。</li>\n<li>在第二次标记之前，对象如果执行finalize()方法并完成自救，对象则不会被回收。否则完成第二次标记，进行回收。值得注意的是finalize()方法并不可靠。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。\"><a href=\"#判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。\" class=\"headerlink\" title=\"判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。\"></a>判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。</h3><p>引用计数器：<br>当引用计数器为零的时候，表明没用引用再指向该对象，但是引用计数器不能解决循环引用的情况；<br>可达性分析：</p>\n<ol>\n<li>当不能从GC Root寻找一条路径到达该对象时， 将进行第一次标记。</li>\n<li>第一次标记后检查对象是否重写了finalize() 和是否已经被调用了finalize()方法。若没有重写finalize()方法或已经被调用，则进行回收。</li>\n<li>在已经重写finalize()方法且未调用的情况下，将对象加入一个F-Queue 的队列中，稍后进行第二次检查。</li>\n<li>在第二次标记之前，对象如果执行finalize()方法并完成自救，对象则不会被回收。否则完成第二次标记，进行回收。值得注意的是finalize()方法并不可靠。</li>\n</ol>\n"},{"layout":"post","title":"命令模式","date":"2019-11-27T07:30:00.000Z","_content":"\n\n- 命令模式\n\n下图为命令模式类图\n![](https://raw.githubusercontent.com/csxiaoshang/images/master/bolg/images20191127153840.png)\n<br>\n<br>\n简单的看，命令模式实现了命令发起者和命令执行者的解耦，中间增加了一层调用者。\n命令组合命令执行者，调用者中维护一个命令列表，并封装命令执行方法。命令发起者则将命令添加到命令调用者中。\n\n<!--more--> \n\n```\nclass Client{\n    putCommand(Command command,Receiver receiver);\n}\n\nclass Invoker{\n    List<Command> commandList;\n    executeCommand(){\n        commandList.forEach(command->command.execute());\n    }\n}\n\ninterface Command{\n    execute();\n}\n\nclass CommandA implements Command{\n    Receiver receiver;\n    execute(){\n        receiver.action();\n    }\n}\n\nclass Receiver{\n    action(){\n        // 需要执行的业务逻辑\n    }\n}\n\n```","source":"_posts/2019-11-27-CommandPattern.md","raw":"---\nlayout: post\ntitle:  \"命令模式\"\ndate:   2019-11-27 15:30:00\ncategories: 设计模式\ntags: learning\n---\n\n\n- 命令模式\n\n下图为命令模式类图\n![](https://raw.githubusercontent.com/csxiaoshang/images/master/bolg/images20191127153840.png)\n<br>\n<br>\n简单的看，命令模式实现了命令发起者和命令执行者的解耦，中间增加了一层调用者。\n命令组合命令执行者，调用者中维护一个命令列表，并封装命令执行方法。命令发起者则将命令添加到命令调用者中。\n\n<!--more--> \n\n```\nclass Client{\n    putCommand(Command command,Receiver receiver);\n}\n\nclass Invoker{\n    List<Command> commandList;\n    executeCommand(){\n        commandList.forEach(command->command.execute());\n    }\n}\n\ninterface Command{\n    execute();\n}\n\nclass CommandA implements Command{\n    Receiver receiver;\n    execute(){\n        receiver.action();\n    }\n}\n\nclass Receiver{\n    action(){\n        // 需要执行的业务逻辑\n    }\n}\n\n```","slug":"2019-11-27-CommandPattern","published":1,"updated":"2019-11-30T07:37:13.949Z","comments":1,"photos":[],"link":"","_id":"ck7yrhz7u001x9oet2gzy37f9","content":"<ul>\n<li>命令模式</li>\n</ul>\n<p>下图为命令模式类图<br><img src=\"https://raw.githubusercontent.com/csxiaoshang/images/master/bolg/images20191127153840.png\" alt><br><br><br><br><br>简单的看，命令模式实现了命令发起者和命令执行者的解耦，中间增加了一层调用者。<br>命令组合命令执行者，调用者中维护一个命令列表，并封装命令执行方法。命令发起者则将命令添加到命令调用者中。</p>\n<a id=\"more\"></a> \n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">class Client&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    putCommand(Command command,Receiver receiver);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">class Invoker&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">    List&lt;Command&gt; commandList;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    executeCommand()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">        commandList.forEach(command-&gt;command.execute());</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">interface Command&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">    execute();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">class CommandA implements Command&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">    Receiver receiver;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">    execute()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">        receiver.action();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">class Receiver&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">    action()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#x2F;&#x2F; 需要执行的业务逻辑</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<ul>\n<li>命令模式</li>\n</ul>\n<p>下图为命令模式类图<br><img src=\"https://raw.githubusercontent.com/csxiaoshang/images/master/bolg/images20191127153840.png\" alt><br><br><br><br><br>简单的看，命令模式实现了命令发起者和命令执行者的解耦，中间增加了一层调用者。<br>命令组合命令执行者，调用者中维护一个命令列表，并封装命令执行方法。命令发起者则将命令添加到命令调用者中。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">class Client&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    putCommand(Command command,Receiver receiver);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">class Invoker&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">    List&lt;Command&gt; commandList;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    executeCommand()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">        commandList.forEach(command-&gt;command.execute());</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">interface Command&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">    execute();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">class CommandA implements Command&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">    Receiver receiver;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">    execute()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">        receiver.action();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">class Receiver&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">    action()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#x2F;&#x2F; 需要执行的业务逻辑</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>"},{"title":"美团到店saas业务面试","date":"2020-03-19T03:39:20.000Z","_content":"- 一面\n    - HashSet的实现;如何判断不重复;插入数据是头插入还是尾插入\n        同样要遍历比较key，为啥要采用头插入\n    - 多线程了解吗;x打印值的范围为多少；如何是打印值为200，有集中方法\n```java\n        public class Test implements Runnable{\n        static int x;\n        @override\n        public void run(){\n          for(int i=0;i<100;i++){\n          x++;\n}\n}\n     public static void main(String[] args){\n         Test test = new Test();\n         new Tread(test).start();\n         new Tread(test).start();\n         system.out.println(x);\n     }\n  }\n```\n    - condition和barrier原理是什么\n    - AQS是干什么用的;wait notify和park　unPark区别;AQS为何是双向链表;如何是实现公平锁和非公平锁\n    - 两个线程交替打印\"A\" \"B\"  \n```java\npublic class Test implement Runnable{\n    ReentrantLock lock = new ReenTrantLock();\n    Condition condition = lock.condition();\n    public void run1(){\n        while(true){\n            // condition\n               system.out.println(\"A\");\n            // condition\n        }\n    }\n    public void run1(){\n                while(true){\n            // condition\n               system.out.println(\"B\");\n            // condition\n        }\n    }\n    public static void main(String[] args){\n        Test test = new Test();\n        new Thread((test) -> {        while(true){\n            // condition\n               system.out.println(\"A\");\n            // condition\n        }}).start();\n        new Thread(() -> {                while(true){\n            // condition\n               system.out.println(\"B\");\n            // condition\n        }}).start();\n    }\n}\n\n\n// AtomicInteger\n\npublic static void main(String[] args){\n    public volatile AtomicInteger count = new AtomicInteger(1);\n    new Thread((count)->{\n        while(true){\n            if(count == 1){\n                               system.out.println(\"A\");\n                count.getAndIncrement();\n            }\n        }\n    }).start();\n    new Thread((count)->{\n        while(true){\n            if(count == 2){\n                system.out.println(\"B\");\n                count.getAndDec();\n            }\n        }\n    }).start();\n}\n ```\n - 二叉树前序遍历非递归实现，后序遍历非递归实现\n ```\n// pre\n\npublic void solution(TreeNode node ){\n    LinkedList<TreeNode> stack = new LinkedList<>();\n    if(node == null){\n        return;\n    }\n    stack.push(node);\n    // visit node;\n    while(!stack.isEmpty()){\n        TreeNode tem = stack.peak();\n        if(tem.left!=null){\n            // visit tem.left;\n            stack.push(tem.left);\n            tem.left == null;\n        }else{\n            stack.pop();\n            if(tem.right!=null){  \n                // visit tem.right\n                stack.push(tem.right);\n            }\n        }\n    }\n}\n```","source":"_posts/美团到店saas业务面试.md","raw":"---\ntitle: 美团到店saas业务面试\ndate: 2020-03-19 11:39:20\ncategories: note\ntags: 美团\n---\n- 一面\n    - HashSet的实现;如何判断不重复;插入数据是头插入还是尾插入\n        同样要遍历比较key，为啥要采用头插入\n    - 多线程了解吗;x打印值的范围为多少；如何是打印值为200，有集中方法\n```java\n        public class Test implements Runnable{\n        static int x;\n        @override\n        public void run(){\n          for(int i=0;i<100;i++){\n          x++;\n}\n}\n     public static void main(String[] args){\n         Test test = new Test();\n         new Tread(test).start();\n         new Tread(test).start();\n         system.out.println(x);\n     }\n  }\n```\n    - condition和barrier原理是什么\n    - AQS是干什么用的;wait notify和park　unPark区别;AQS为何是双向链表;如何是实现公平锁和非公平锁\n    - 两个线程交替打印\"A\" \"B\"  \n```java\npublic class Test implement Runnable{\n    ReentrantLock lock = new ReenTrantLock();\n    Condition condition = lock.condition();\n    public void run1(){\n        while(true){\n            // condition\n               system.out.println(\"A\");\n            // condition\n        }\n    }\n    public void run1(){\n                while(true){\n            // condition\n               system.out.println(\"B\");\n            // condition\n        }\n    }\n    public static void main(String[] args){\n        Test test = new Test();\n        new Thread((test) -> {        while(true){\n            // condition\n               system.out.println(\"A\");\n            // condition\n        }}).start();\n        new Thread(() -> {                while(true){\n            // condition\n               system.out.println(\"B\");\n            // condition\n        }}).start();\n    }\n}\n\n\n// AtomicInteger\n\npublic static void main(String[] args){\n    public volatile AtomicInteger count = new AtomicInteger(1);\n    new Thread((count)->{\n        while(true){\n            if(count == 1){\n                               system.out.println(\"A\");\n                count.getAndIncrement();\n            }\n        }\n    }).start();\n    new Thread((count)->{\n        while(true){\n            if(count == 2){\n                system.out.println(\"B\");\n                count.getAndDec();\n            }\n        }\n    }).start();\n}\n ```\n - 二叉树前序遍历非递归实现，后序遍历非递归实现\n ```\n// pre\n\npublic void solution(TreeNode node ){\n    LinkedList<TreeNode> stack = new LinkedList<>();\n    if(node == null){\n        return;\n    }\n    stack.push(node);\n    // visit node;\n    while(!stack.isEmpty()){\n        TreeNode tem = stack.peak();\n        if(tem.left!=null){\n            // visit tem.left;\n            stack.push(tem.left);\n            tem.left == null;\n        }else{\n            stack.pop();\n            if(tem.right!=null){  \n                // visit tem.right\n                stack.push(tem.right);\n            }\n        }\n    }\n}\n```","slug":"美团到店saas业务面试","published":1,"updated":"2020-03-19T12:59:45.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7w00219oet090yabe0","content":"<ul>\n<li>一面<ul>\n<li>HashSet的实现;如何判断不重复;插入数据是头插入还是尾插入<br>  同样要遍历比较key，为啥要采用头插入</li>\n<li>多线程了解吗;x打印值的范围为多少；如何是打印值为200，有集中方法<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> x;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-meta\">@override</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">          x++;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">         Test test = <span class=\"hljs-keyword\">new</span> Test();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"hljs-keyword\">new</span> Tread(test).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"hljs-keyword\">new</span> Tread(test).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">         system.out.println(x);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">     &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr></table></figure></li>\n<li>condition和barrier原理是什么</li>\n<li>AQS是干什么用的;wait notify和park　unPark区别;AQS为何是双向链表;如何是实现公平锁和非公平锁</li>\n<li>两个线程交替打印”A” “B”  <figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-title\">implement</span> <span class=\"hljs-title\">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    ReentrantLock lock = <span class=\"hljs-keyword\">new</span> ReenTrantLock();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    Condition condition = lock.condition();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run1</span><span class=\"hljs-params\">()</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">               system.out.println(<span class=\"hljs-string\">\"A\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run1</span><span class=\"hljs-params\">()</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">                <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">               system.out.println(<span class=\"hljs-string\">\"B\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">        Test test = <span class=\"hljs-keyword\">new</span> Test();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">new</span> Thread((test) -&gt; &#123;        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">               system.out.println(<span class=\"hljs-string\">\"A\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;&#125;).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;                <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">               system.out.println(<span class=\"hljs-string\">\"B\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">28</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">29</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;&#125;).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">30</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">31</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">32</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">33</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">34</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// AtomicInteger</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">35</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">36</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">37</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">volatile</span> AtomicInteger count = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">1</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">38</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">new</span> Thread((count)-&gt;&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">39</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">40</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-keyword\">if</span>(count == <span class=\"hljs-number\">1</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">41</span></pre></td><td class=\"code\"><pre><span class=\"line\">                               system.out.println(<span class=\"hljs-string\">\"A\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">42</span></pre></td><td class=\"code\"><pre><span class=\"line\">                count.getAndIncrement();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">43</span></pre></td><td class=\"code\"><pre><span class=\"line\">            &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">44</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">45</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">46</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">new</span> Thread((count)-&gt;&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">47</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">48</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"hljs-keyword\">if</span>(count == <span class=\"hljs-number\">2</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">49</span></pre></td><td class=\"code\"><pre><span class=\"line\">                system.out.println(<span class=\"hljs-string\">\"B\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">50</span></pre></td><td class=\"code\"><pre><span class=\"line\">                count.getAndDec();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">51</span></pre></td><td class=\"code\"><pre><span class=\"line\">            &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">52</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">53</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">54</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>\n<ul>\n<li>二叉树前序遍历非递归实现，后序遍历非递归实现<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; pre</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">public void solution(TreeNode node )&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    LinkedList&lt;TreeNode&gt; stack &#x3D; new LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    if(node &#x3D;&#x3D; null)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">        return;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">    stack.push(node);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#x2F;&#x2F; visit node;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">    while(!stack.isEmpty())&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">        TreeNode tem &#x3D; stack.peak();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">        if(tem.left!&#x3D;null)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">            &#x2F;&#x2F; visit tem.left;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">            stack.push(tem.left);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">            tem.left &#x3D;&#x3D; null;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;else&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">            stack.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">            if(tem.right!&#x3D;null)&#123;  </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">                &#x2F;&#x2F; visit tem.right</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">                stack.push(tem.right);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">            &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>一面<ul>\n<li>HashSet的实现;如何判断不重复;插入数据是头插入还是尾插入<br>  同样要遍历比较key，为啥要采用头插入</li>\n<li>多线程了解吗;x打印值的范围为多少；如何是打印值为200，有集中方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> x;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"meta\">@override</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">100</span>;i++)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">          x++;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">         Test test = <span class=\"keyword\">new</span> Test();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"keyword\">new</span> Tread(test).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"keyword\">new</span> Tread(test).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">         system.out.println(x);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">     &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr></table></figure></li>\n<li>condition和barrier原理是什么</li>\n<li>AQS是干什么用的;wait notify和park　unPark区别;AQS为何是双向链表;如何是实现公平锁和非公平锁</li>\n<li>两个线程交替打印”A” “B”  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"title\">implement</span> <span class=\"title\">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    ReentrantLock lock = <span class=\"keyword\">new</span> ReenTrantLock();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    Condition condition = lock.condition();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run1</span><span class=\"params\">()</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">               system.out.println(<span class=\"string\">\"A\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run1</span><span class=\"params\">()</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">               system.out.println(<span class=\"string\">\"B\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">        Test test = <span class=\"keyword\">new</span> Test();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">new</span> Thread((test) -&gt; &#123;        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">               system.out.println(<span class=\"string\">\"A\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;&#125;).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;                <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">               system.out.println(<span class=\"string\">\"B\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">28</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"comment\">// condition</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">29</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;&#125;).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">30</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">31</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">32</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">33</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">34</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AtomicInteger</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">35</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">36</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">37</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">38</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">new</span> Thread((count)-&gt;&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">39</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">40</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"keyword\">if</span>(count == <span class=\"number\">1</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">41</span></pre></td><td class=\"code\"><pre><span class=\"line\">                               system.out.println(<span class=\"string\">\"A\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">42</span></pre></td><td class=\"code\"><pre><span class=\"line\">                count.getAndIncrement();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">43</span></pre></td><td class=\"code\"><pre><span class=\"line\">            &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">44</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">45</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">46</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">new</span> Thread((count)-&gt;&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">47</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">48</span></pre></td><td class=\"code\"><pre><span class=\"line\">            <span class=\"keyword\">if</span>(count == <span class=\"number\">2</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">49</span></pre></td><td class=\"code\"><pre><span class=\"line\">                system.out.println(<span class=\"string\">\"B\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">50</span></pre></td><td class=\"code\"><pre><span class=\"line\">                count.getAndDec();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">51</span></pre></td><td class=\"code\"><pre><span class=\"line\">            &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">52</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">53</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;).start();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">54</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>\n<ul>\n<li>二叉树前序遍历非递归实现，后序遍历非递归实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; pre</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">public void solution(TreeNode node )&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    LinkedList&lt;TreeNode&gt; stack &#x3D; new LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    if(node &#x3D;&#x3D; null)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">        return;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">    stack.push(node);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#x2F;&#x2F; visit node;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">    while(!stack.isEmpty())&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">        TreeNode tem &#x3D; stack.peak();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">        if(tem.left!&#x3D;null)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">            &#x2F;&#x2F; visit tem.left;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">            stack.push(tem.left);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">            tem.left &#x3D;&#x3D; null;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;else&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">            stack.pop();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">            if(tem.right!&#x3D;null)&#123;  </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">                &#x2F;&#x2F; visit tem.right</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">                stack.push(tem.right);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">            &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">        &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"暑期实习面试准备","date":"2020-02-17T08:36:25.000Z","_content":"\n### 面试\n\n- 多思考，挖掘项目难点，多总结\n做完项目一定要总结，自己在项目中担任什么角色，解决了什么痛点，项目有哪些难点，怎么解决难点这些，\n以及可以优化的地方，优化方案等，可以不一定实现，但是一定要知道怎么去解决。\n但是如果没有想清楚难点、优化思路，再多的项目经验也白搭。\n- 引导式面试\n面试肯定会遇到不会的地方，这个时候直接说不会，虽然不一定会直接挂，但是对整个面试肯定会有影响，\n这个时候就可以把面试官引导到自己熟悉的相关技术上，一般绝大多数面试官会让继续讲，\n建议可以各个方面知识都研究一个，研究深入点即可，例如缓存redis、消息队列kafka等。\n去理解面试官想要问的东西，主动去说，不一定要等到面试官问透，而且很多面试官表述问题不清楚，\n这时候一定要问清楚面试官想问的是不是你要回答的，答非所问也十分不可取。\n- 每次面试必总结\n面试真的是学习技术最快的过程，很多时候自己学的，不一定学透了，经过面试官一顿灵魂拷问后发现自己什么都不会，\n面试完总结这些知识，然后多面试几次后面就很容易了。\n- 自信\n很多时候会被面试官问到怀疑人生，也可能会经历压力面，面试问的越难，反倒可能说明面试官对你很认可，\n需要问些更深入的问题提高评级。\n不论面试官问的问题是已经准备了很久的、烂熟于心还是从未接触过，都要自信，从容面对，也千万不要因为简单问题而放松，简单问题也可以回答的不一样，\n例如java gc可以降到jdk11最新回收算法，这肯定比书上看到的cms g1有亮点的多，面试官也会觉得你热爱技术。\n\n\n### 数据结构和算法\n\n- 红黑树\n- B树和B+树\n- 大文件排序\n[对含有一亿数据的大文件进行排序，要求使用内存小于32MB](https://blog.csdn.net/qq_29048719/article/details/81133643)\n参考链接：\n[二叉树，平衡二叉树，红黑树，B-树、B+树、B*树的区别](https://blog.csdn.net/wyqwilliam/article/details/82935922)\n[红黑树和AVL树（平衡二叉树）区别](https://blog.csdn.net/u010899985/article/details/80981053#commentBox)\n[一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)](https://www.cnblogs.com/aspirant/p/9214485.html)\n### Java基础\n[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)\n[面向对象与面向过程的优缺点](https://www.cnblogs.com/nanqiang/p/9934063.html)\n[面向对象五大基本原则详解](https://blog.csdn.net/qq_34375473/article/details/84852650)\n[反射原理](https://blog.csdn.net/h2604396739/article/details/83109292)\n[补码原理——负数为什么要用补码表示](https://blog.csdn.net/leonliu06/article/details/78685197)\n[跳表（SkipList）及ConcurrentSkipListMap源码解析](https://blog.csdn.net/sunxianghuang/article/details/52221913?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n<!--more-->\n### linux命令\n[Linux常用命令（面试题）](https://blog.csdn.net/qq_40910541/article/details/80686362)\n[最全Linux 面试常用命令](https://blog.csdn.net/jiangbr/article/details/82848492)\n### Jvm\n\n- 分代回收算法:http://www.importnew.com/19255.html\n年轻代：复制回收算法 Scavenge GC（Eden->Survivor->Survivor）\n老年代：年轻代n次回收后，扔存在的对象进入老年代。Full GC（老年、持久被写满或显示调用）用的是标记／清除法，老年代的垃圾回收会导致长时间的停顿\n持久代：存放静态文件\n收集器：串行：单线程效率高（适用于client模式下）；并行：多线程（最大垃圾回收暂停:吞吐量）；并发：应用不停止，响应要求高。浮动垃圾，需要保证内存空间\nCMS收集器，目前web服务器开发最常用的收集器，并发收集（也就是垃圾回收线程和应用程序线程同时运行）。问豪神：（由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 再次标记阶段（remark））\n\n- 在Java语言中，可以作为GC Roots的对象包括下面几种：\n\n虚拟机栈（栈帧中的本地变量表）中的引用对象。\n方法区中的类静态属性引用的对象。\n方法区中的常量引用的对象。\n本地方法栈中JNI（Native方法）的引用对象\n\n- JVM垃圾收集器：\n  Serial 收集器：串行收集器，使用单线程进行收集，适用于client模式\n  ParNew收集器：Serial的多线程版本\n  CMS 收集器：\n  初始标记：只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿\n  并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿\n  重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿\n  并发清除：不需要停顿\n- 对象创建过程：\n检查常量池中是否有即将要创建的这个对象所属的类的符号引用；\n进而检查这个符号引用所代表的类是否已经被JVM加载；若该类还没有被加载，就找该类的class文件，并加载进方法区；若该类已经被JVM加载，则准备为对象分配内存；\n根据方法区中该类的信息确定该类所需的内存大小； 一个对象所需的内存大小是在这个对象所属类被定义完就能确定的！且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。\n从堆中划分一块对应大小的内存空间给新的对象； 分配堆中内存有两种方式：指针碰撞 －－如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。　　空闲列表 －－如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。\n为对象中的成员变量赋上初始值(默认初始化)；对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；\n设置对象头中的信息；\n调用对象的构造函数进行初始化\n- JVM内存模型：\n【Java堆】用于存储Java对象，每个Java对象都是这个对象类的副本，会复制包含继承自它父类的所有非静态属性。\n【方法区】用于存储类结构信息，class文件加载进JVM时会被解析成JVM识别的几个部分分别存储在不同的数据结构中：常量池、域、方法数据、方法体、构造函数，包括类中的方法、实例初始化、接口初始化等。\n【Java栈】和线程关联，每个线程创建的时候，JVM都会为他分配一个对应的Java栈，这个栈含有多个栈帧；栈帧则是个方法关联，每个方法的运行都会创建一个自己的栈帧，含有内存变量，操作栈、方法返回值。\n【PC寄存器】则用于记录下一条要执行的字节码指令地址和被中断。如果方法是 native的，程序计数器寄存器的值不会被定义为空。\n【本地方法栈】是为JVM运行Native方法准备的空间，类似于Java栈。\n\n- 双亲委派模型\n\n启动类加载器  拓展类加载器  应用程序类加载器 自定义加载器\n每个类加载器在收到类加载请求时，都不会自己先加载，而是将该请求委派给父类加载器去完成，若父类加载器可以完成该类的加载请求任务，\n则成功返回，若父类加载器无法完成该类的加载请求任务，子类加载器才会尝试加载，这就是双亲委派模式。\n\n优点：采用双亲委派模式可使Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父加载器已经加载了该类时，就没有必要让子ClassLoader再加载一次。其次还可以防止子类加载器加载的类恶意覆盖Java核心API。例如，类java.lang.Object类存放在JDK\\jre\\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。\n\n- 类加载\n\n启动类加载器：Bootstrap ClassLoader，它负责加载存放在JDK\\jre\\lib(JDK代表??JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。\n扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。\n应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：1）在执行非置信代码之前，自动验证数字签名。2）动态地创建符合用户特定需要的定制化构建类。3）从特定的场所取得java class，例如数据库中和网络中。\n\n- 符号引用和直接引用\n\n在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类引用org.simple.Tool类，在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类 的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。\n符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。\n直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。\n\n参考链接：\n[CMS 垃圾收集器 - 工作原理，浮动垃圾，三色标记法 ](http://blog.sina.com.cn/s/blog_df25c55f0102wxh3.html)\n[jvm如何判断对象是否可以回收或存活](https://blog.csdn.net/weixin_28760063/article/details/81271827)\n[深入理解JVM虚拟机2：JVM垃圾回收基本原理和算法](https://blog.csdn.net/a724888/article/details/77981592)\n[CMS收集器和G1收集器 他们的优缺点对比 最后并发清除 CMS 不需要停顿，G1需要停顿...](https://blog.csdn.net/diaopai5230/article/details/101216653)\n[Jvm介绍](https://thinkinjava.cn/categories/JVM/)\n[自定义类加载器](https://blog.csdn.net/qq_36071795/article/details/83715456)\n[java虚拟机的符号引用和直接引用](https://blog.csdn.net/qq_34402394/article/details/72793119#commentBox)\n[JVM关于OOM异常的调优](https://blog.csdn.net/seujava_er/article/details/90114716)\n[深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型](https://blog.csdn.net/qq_38182963/article/details/78660779)\n[深入理解JVM-内存模型（jmm）和GC](https://www.jianshu.com/p/76959115d486)\n[阿里面试100%问到，JVM性能调优篇](https://blog.csdn.net/qq_20499001/article/details/89288497)\n[面试题之窒息翻译：类加载机制的双亲委派（正解：父委派模型）](https://blog.csdn.net/lengxiao1993/article/details/86689331#comments)\n[深入JVM字节码执行引擎](https://blog.csdn.net/dd864140130/article/details/49515403)\n### 并发\n\n1.悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。\n2.乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。\n3.线程池：新建线程 -> 达到核心数 -> 加入队列 -> 新建线程（非核心） -> 达到最大数 -> 触发拒绝策略。　线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务。线程数量达到了corePools，则将任务移入队列。等待队列已满，新建线程(非核心线程)执行任务。队列已满，总线程数又达到了maximumPoolSize，就会由(RejectedExecutionHandler)抛出异常\n4.为什么使用线程池：单个任务处理时间比较短，需要处理的任务数量很大。降低资源消耗　提高线程的可管理性　\n5.newCachedThreadPool 工作线程的创建数量几乎没有限制 newFixedThreadPool　　　 newScheduledThreadPool支持定时及周期性任务执行　　newSingleThreadExecutor单线程化的线程池，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行　　　\n6.线程池中的线程在新建后进入while循环，从task队列获取任务，当没有待执行任务时，若线程数量小于等于核心线程数量，若核心线程不可退出则调用队列的take阻塞直到新任务到来，若可以退出，则调用poll，时间超时后线程结束。\n7.CountDownLatch 利用它可以实现一个任务等待其他一个或一组任务执行后再触发的功能，不可重用。CyclicBarrier　让一组线程等待至某个状态之后再全部同时执行，可重用。\n8.分布式系统CAP定理：Consistency（一致性），Availability（可用性），Partition tolerance（分区容错）　web场景一般可用性高于一致性　所以退而求其次追求最终一致性(eventual consistency)　　分区容错在分布式系统中不可避免\n9.自旋锁与互斥锁：自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，所以自旋锁的效率远 高于互斥锁。虽然它的效率比互斥锁高，但是它一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。不适用与IO场景，单核CPU，代码长时间执行。自旋锁的实现：使用java的cas原子操作AtomicReference，循环将原子变量从null设置为当前线程，若当前原子变量不为null则一直循环。\n10.死锁的原因与预防：１互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程　２占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源　３不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。　４循环等待：存在一个进程环，使得每个进程都占有下一个进程所需的至少一种资源。\n       预防的主要做法是破坏除互斥之外的三个条件\n11.线程与进程的区别：\n       一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。\n       资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。\n       引入线程的操作系统中，把线程作为调度和分派的基本单位。而把进程作为资源拥有的基本单位\n       系统开销　由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。\n12.进程的几种状态: 1) 运行状态：进程正在处理器上上运行。在单处理器环境下，每个时刻最多只有一个进程处于运行状态。2) 就绪状态：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器即可运行。3) 阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入/输出完成。即使处理器空闲，该进程也不能运行。4) 创建状态：进程正在被创建，尚未到就绪状态。5) 结束状态：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\n13.程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码。初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据。未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据。栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。堆 (Heap):存储动态内存分配,需要程序员手工分配,手工释放.\n14.使用线程池的好处：减少创建和销毁线程导致的时间开销和内存资源开销，如果不使用线程池可能导致系统创建大量同类线程导致资源耗尽或者频繁切换\n15.UUID含义是通用唯一识别码 (Universally Unique Identifier) UUID由以下几部分的组合：\n       1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同\n       2）时钟序列。？？？问五七\n       3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得\n16.线程的几种创建方式：以继承Thread类的方式创建线程，　以实现Runnable接口的方式创建线程，　以Callable+FutureTask的方式创建线程\n17.公平锁与非公平锁的区别\n       非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。\n       非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。\n       公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。\n18.分布式事务：\n       TCC:Try、Confirm、Cancel　Try 阶段：对各个服务的资源做检测以及对资源进行锁定。Confirm 阶段：在各个服务中执行实际的操作。Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。 \n       [tcc事务原理](https://www.cnblogs.com/jajian/p/10014145.html)  \n参考链接：\n[Java并发编程之异步Future机制的原理和实现](https://blog.csdn.net/lovezhaohaimig/article/details/80344299)\n[深度解读 java 线程池设计思想及源码实现](https://javadoop.com/post/java-thread-pool)\n[CompletableFuture原理解析](https://www.jianshu.com/p/abfa29c01e1d)\n[CountDownLatch和CylicBarrier以及Semaphare你使用过吗](https://www.cnblogs.com/wangsen/p/11170709.html)\n[[分布式]：分布式系统的CAP理论](https://blog.csdn.net/w372426096/article/details/80437198)\n[分布式事务之TCC](https://www.jianshu.com/p/58911d2e8b28)\n[自旋锁、排队自旋锁、MCS锁、CLH锁](https://coderbee.net/index.php/concurrent/20131115/577)\n### Spring\n\n- 动态代理\n\nCglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.\njdk动态代理\n\n- IOC\n\n    1.IOC: 容器ApplicationContext虽然继承自BeanFactory的接口，但其内部持有一个BeanFactory实例，用于创建和管理Bean，项目启动后调用其refresh方法进行初始化，生成所有单例模式的Bean。BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。首先会根据配置加载BeanDefinition，然后将所以的BeanDefinition存入容器的一个Map中，完成后BeanFactory的初始化完成。随后开始Bean的初始化流程，通过getBean进行加载，已经加载过的会直接返回，加载过程中遇到依赖的Bean会进行递归加载，调用无参构造函数或者构造函数依赖注入进行实例创建，然后对Bean依赖的property进行注入\n    2.Spring循换依赖问题：通过三级缓存和提前曝光机制解决。比如Ａ字段中依赖Ｂ，Ｂ字段中依赖Ａ。当Ａ在实例化后（对象初始化的第一步）便曝光到第三级缓存中，属性赋值Ｂ时发现没有B，便初始化Ｂ，在属性赋值Ａ时便可以在第三级缓存中找到Ａ的引用赋值，完成Ｂ的初始化，保存到第一级缓存；之后返回给Ａ完成初始化。\n    \n参考链接：\n[Spring IOC 容器源码分析](https://javadoop.com/post/spring-ioc)\n[Spring如何解决循环依赖](https://blog.csdn.net/quliuwuyiz/article/details/79416184)\n\n-　AOP\n\nAOP:　ProxyFatoryBean用于创建代理对象，先初始化Advisor链，然后进行代理类的生成。当代理类执行方法时，会调用invoke方法，invoke方法中对aop拦截器进行检测，如果存在拦截器，则生成MethodInvocation进行拦截链的链式调用。不断得调用procced方法，每次进去后计数器自增，取出下一个拦截其，检查advise与当前的调用是否match,匹配的话将执行该advise    \n\n\n参考链接：\n[Spring AOP 源码解析](https://javadoop.com/post/spring-aop-source)\n[剑指Spring源码（三）俯瞰Spring的Bean的生命周期（大众版）](https://www.cnblogs.com/CodeBear/p/10867707.html#4462519)\n### Spring Cloud\n\n- Ribbon\n　负责均衡客户端基于RestTemplate实现，通过拦截器机制实现负载均衡，在拦截器中拿到请求url中的serviceId，传入LoadBalanceClient进行服务实例的获取,获取时通过ILoadBalance负载均衡器获取服务，服务实例对象封装了ip等信息。利用服务实例初始化serviceRequestWarpper，重写getUri函数将服务id转换为ip，继续进行后续拦截链的链式调用。\n\n参考链接：\n[关于RestTemplate 非常推荐的几篇博文（原理剖析）](https://blog.csdn.net/hanhanbubble/article/details/90752591)\n[spring cloud底层原理](https://www.cnblogs.com/jajian/p/9973555.html)\n### 设计模式\n\n- 代理模式\n\n静态代理：由程序员或特定工具创建代理类，在程序运行前代理类的.class文件已经存在\n动态代理：在程序运行时通过反射机制动态创建而成\n\n静态代理类优缺点\n\n优点：\n\n代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合），对于如上的客户端代码，newUserManagerImpl()可以应用工厂将它隐藏，如上只是举个例子而已。\n\n缺点：\n\n1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。\n\n参考链接：\n[代理模式](https://www.cnblogs.com/zuoxiaolong/p/pattern3.html)\n[JAVA学习篇--静态代理VS动态代理](https://blog.csdn.net/hejingyuan6/article/details/36203505)\n[项目中用到的设计模式](https://www.jianshu.com/p/8afd396e314f)\n### 数据库\n\n- 引擎对比  \nMyISAM拥有较高的插入、查询速度，但不支持事务。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复\nInnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。辅助索引data域存储相应记录主键的值而不是地址。InnoDB还支持外键（FOREIGN KEY）\n\n[MySQL存储引擎MyISAM与InnoDB区别总结整理]()\n- 事务\n\n数据库事务的实现原理：\n事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁），这时该事物的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中），这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。\n原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。\nRedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。\n\n脏读：是指一个事务中访问到了另外一个事务未提交的数据。不可重复读是指在一个事务内根据同一个条件对行记录进行多次查询，但是搜出来的结果却不一致。幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。不同在于不可重复读是同一个记录的数据内容被修改了，幻读是数据行记录变多了或者少了\n事务隔离：read uncommitted（读取未提交数据：导致脏读）　read committed（可以读取其他事务提交的数据：导致不可重复读）---大多数数据库默认的隔离级别；repeatable read（可重读：导致幻读）---MySQL默认的隔离级别；serializable（串行化：有事务读的时候其他写会被挂起）\n\n事务特性：原子性　　一致性　数据库总数从一个一致性的状态转换到另一个一致性的状态。　　隔离性　一个事务所做的修改在最终提交以前，对其他事务是不可见的。　持久性　一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。\n- 索引\n数据库索引分类：从数据结构角度　B+树索引　hash索引　FULLTEXT索引（InnoDB引擎5.7以后支持）R-Tree索引　　从物理存储角度　　聚簇索引（一般对主键建立，物理存放顺序与索引顺序是一致的）　非聚簇索引　　聚簇索引中的每个叶子节点包含主键值和余下的列\n\n- mysql gap锁\n\n只有在rr隔离级别下才会使用gap锁，会把数据库中索引行划分为一个个左开右闭的区间（相邻行记录），根据where < >这种查询方式，使用gap锁\n\n[MySQL innodb中各种SQL语句加锁分析](http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html)\n[和刚入门的菜鸟们聊聊--什么是聚簇索引与非聚簇索引](https://www.cnblogs.com/auxg/p/Cluster-and-NonCluster-index.html)\n[多个单列索引和联合索引的区别详解](https://blog.csdn.net/Abysscarry/article/details/80792876)\n- Redis\nRedis主从同步策略　主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。https://blog.csdn.net/rentuo53/article/details/84912941\nRedis的哨兵机制　能监控多个master-slave集群，发现master宕机后能进行自动切换。不时地监控redis是否按照预期良好地运行;如果发现某个redis节点运行出现状况，能够通知另外一个进程；能够进行自动切换（进行主备切换）。当一个master节点不可用时，能够选举出master的多个slave中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。使用raft选举算法.\n缓存穿透：缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。　　　解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n缓存雪崩　缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。解决方案：缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n缓存击穿　对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。解决方案　使用互斥锁(mutex key)　业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。\n[Redis深度解析](https://blog.csdn.net/a2133212132/article/details/80685313?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n- 分布式系统一致性\n  XA协议　　第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交　　第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。　　优点： 尽量保证了数据的强一致，实现成本较低，缺点:　单点问题:事务管理器如果宕机，资源管理器就会一直阻塞，导致数据库无法使用。　同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。　数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。\n- 数据库优化\n\n查询优化：面对大规模数据量时，采取SELECT * FROM table WHERE id >= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 对分页查询进行优化，由于查询出id后，会遍历按照id 去外存区table数据　然后丢弃前面的，导致效率低下。\n[如何提高MySQL Limit查询的性能](http://www.nowamagic.net/librarys/veda/detail/1900)\n[数据库优化方案整理](https://blog.csdn.net/u013628152/article/details/82184809)\n\n参考链接：\n[MySQL的锁机制和加锁原理](https://blog.csdn.net/qq_38238296/article/details/88362999#commentBox)\n[mysql学习](https://blog.csdn.net/mysteryhaohao/category_6270382.html)\n[MySql 三大知识点——索引、锁、事务](https://thinkinjava.cn/2019/03/16/2019/2019-03-16-mysql/)\n[为什么分布式一定要有redis，redis的一些优缺点q](https://blog.csdn.net/hcmony/article/details/80694560)\n[数据库本地事务的实现原理](https://blog.csdn.net/qq360694660/article/details/88695365)\n[数据库 redo undo log](https://blog.csdn.net/oracle_29/article/details/85717855)\n[大白话布隆过滤器](https://www.cnblogs.com/CodeBear/p/10911177.html)\n[谈谈数据库，缓存一致性](https://www.cnblogs.com/CodeBear/p/12118050.html#4472208)\n[REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案](https://www.cnblogs.com/xichji/p/11286443.html)\n[一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)](https://www.cnblogs.com/aspirant/p/9214485.html)\n[Redis持久化(rdb、aof、混合)](https://blog.csdn.net/yhl_jxy/article/details/91879874)\n[面试中关于Redis的问题看这篇就够了](https://blog.csdn.net/qq_34337272/article/details/80012284)\n### 网络\n- tcp三次握手的本质：交换并确认双方的数据序号。\n        1.SYN-SENT --> <SEQ=100><CTL=SYN> --> SYN-RECEIVED ​ \n        2.ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED ​ \n        3.ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK> --> ESTABLISHED\n        四次挥手，每一端的关闭请求都需要被确认一次：2（client, server）*2(FIN, ACK)　服务器主动关闭链接的话会只有两次挥手　后续会回复客户端RST\n        \n        TIME_WAIT的产生条件：主动关闭方在发送四次挥手的最后一个ACK（第四次挥手后不会立刻关闭）会变为TIME_WAIT状态，保留次状态的时间为两个MSL（linux里一个MSL为30s，是不可配置的）\n        TIME_WAIT两个MSL的作用：可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会对FIN开启TCP重传，发\n        送多个FIN包，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其它服务产生影响。\n        TIME_WAIT占用的资源：少量内存（查资料大概4K）和一个fd。\n        TIME_WAIT关闭的危害：1、  网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被\n        动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；2、  同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动\n        方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。\n        TIME_WAIT过多的解决办法： net.ipv4.tcp_tw_recycle=1  　表示开启TCP连接中TIME-WAIT sockets的快速回收\n- Reactor模式\n    　一种比较流行的做法是服务端监听线程和 IO 线程分离，类似于 Reactor 的多线程模型。bossGrouＰ线程组实际就是 Acceptor 线程池，负责处理客户端的 TCP 连接请求，workerGroup 是真正负责 I/O 读写操作的线程组\n    \n- TCP确保可靠性的机制　校验和　序列号　确认应答　超时重传　连接管理（三次握手　四次挥手）　\n  流量控制　在TCP协议的报头信息当中，有窗口大小，即接收端接收数据缓冲区的剩余大小。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。\n  拥塞控制　 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认\n  RST标志位表示强制断开链接\n  sack selective acknowledgment，也就是选择性确认，添加sack功能需要在TCP包头加两个选项，一个是开启选项（enabling optiocookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效,存放数据大小一般4K左右，而sessionStorage与localStorage大小在5兆左右，在客户端生成，localStorage除非被清除，否则会永久保存，sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除，cookie在与服务器端通信每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题,而sessionStorage与localStorage仅在客户端（即浏览器）中保存，不参与和服务器的通信。n），另一个是sack选项（sack option）本身。开启sack选项后，receiver会将自己收到了哪些包，没收到哪些包的信息记录在sack段中告诉给sender，这样sender便可以一次性重传所有的丢包。\n  MSS : Maximum Segment Size最大分段大小\n- 状态码:\n  100（Continue）客户端应该继续它的请求。这个过渡的响应用于告知客户端，请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应。服务器必须在请求完成后发送一个最终的响应。\n  206状态码（Partial Content）服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n  304 表明了客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题.\n  301 redirect: 301 代表永久性转移(Permanently Moved) 302 redirect: 302 代表暂时性转移(Temporarily Moved )\n- EPoll两种工作模式\n    ET:当有事件发生时，系统只会通知你一次，即在调用epoll_wait返回fd后，不管这个事件你处理还是没处理，处理完没有处理完，当再次调用epoll_wait时，都不会再返回该fd　LT:使用LT模式意味着只要fd处于可读或者可写状态，每次epoll_wait都会返回该fd，这样的话会带来很大的系统开销，且处理时候每次都需要把这些fd轮询一遍，如果fd的数量巨大，不管有没有事件发生，epoll_wait都会触发这些fd的轮询判断。\n- TCP报文段是面向字节流的，UDP包是面向数据报的\n    面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。在TCP建立连接前两次握手的SYN报文中选项字段的MSS值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口协议来控制通信双发的数据。\n    tcp传输对准确性要求高速度相对可以慢，因此用于HTTP,FTP，邮件传输，远程连接；udp用于即时通讯延迟低，准确性低，网络电话，语音通信\n- netty的零拷贝\n    将内存空间分段的字节数组在逻辑上整合为一个整体的字节数组（段式内存思想，将逻辑index变成分块编号和段内偏移）\n参考链接：\n[Reactor三种线程模型与Netty线程模型](https://www.cnblogs.com/lvyahui/p/9030232.html)    \n[TCP 和 UDP 的区别](https://blog.csdn.net/zhang6223284/article/details/81414149)\n[TCP-IP详解：SACK选项（Selective Acknowledgment）](https://blog.csdn.net/wdscq1234/article/details/52503315?locationNum=3)\n### IO\n- 网络io发生时涉及的对象和步骤\n    1）等待数据准备 (Waiting for the data to be ready)\n    2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)\n[web服务器和客户端完成并行处理请求三大方式](https://blog.csdn.net/u011032846/article/details/81507216)\n[并发编程(IO多路复用)](https://www.cnblogs.com/cainingning/p/9556642.html)\n### 分布式\n- rpc\n[如何给老婆解释什么是RPC](https://www.jianshu.com/p/2accc2840a1b)\n[如何实现一个简单的RPC](https://www.jianshu.com/p/5b90a4e70783)\n- springCloud\n[SpringCloud面试常见问题](https://blog.csdn.net/jerryDzan/article/details/89137818)\n### 场景问题\n[Reactor模式](https://www.cnblogs.com/crazymakercircle/p/9833847.html)\n[一个最简单的RPC实现及其原理](https://blog.csdn.net/qq_38601777/article/details/104092959)\n[架构师手把手教你如何设计一个秒杀系统？](https://www.jianshu.com/p/729f1f0f6e18)\n[如何设计一个秒杀系统](https://blog.csdn.net/mulinsen77/article/details/89054063)\n[检查 1亿的手机号码以进行重复](https://kb.kutu66.com/algorithm/post_1011410  )\n[如何在有限的内存限制下实现数十亿级手机号码去重](https://www.jianshu.com/p/b39eb55d4670)\n[Java多线程读取大文件](https://www.cnblogs.com/metoy/p/4470418.html)","source":"_posts/暑期实习面试准备.md","raw":"---\ntitle: 暑期实习面试准备\ndate: 2020-02-17 16:36:25\ncategories: note\ntags: interview\n---\n\n### 面试\n\n- 多思考，挖掘项目难点，多总结\n做完项目一定要总结，自己在项目中担任什么角色，解决了什么痛点，项目有哪些难点，怎么解决难点这些，\n以及可以优化的地方，优化方案等，可以不一定实现，但是一定要知道怎么去解决。\n但是如果没有想清楚难点、优化思路，再多的项目经验也白搭。\n- 引导式面试\n面试肯定会遇到不会的地方，这个时候直接说不会，虽然不一定会直接挂，但是对整个面试肯定会有影响，\n这个时候就可以把面试官引导到自己熟悉的相关技术上，一般绝大多数面试官会让继续讲，\n建议可以各个方面知识都研究一个，研究深入点即可，例如缓存redis、消息队列kafka等。\n去理解面试官想要问的东西，主动去说，不一定要等到面试官问透，而且很多面试官表述问题不清楚，\n这时候一定要问清楚面试官想问的是不是你要回答的，答非所问也十分不可取。\n- 每次面试必总结\n面试真的是学习技术最快的过程，很多时候自己学的，不一定学透了，经过面试官一顿灵魂拷问后发现自己什么都不会，\n面试完总结这些知识，然后多面试几次后面就很容易了。\n- 自信\n很多时候会被面试官问到怀疑人生，也可能会经历压力面，面试问的越难，反倒可能说明面试官对你很认可，\n需要问些更深入的问题提高评级。\n不论面试官问的问题是已经准备了很久的、烂熟于心还是从未接触过，都要自信，从容面对，也千万不要因为简单问题而放松，简单问题也可以回答的不一样，\n例如java gc可以降到jdk11最新回收算法，这肯定比书上看到的cms g1有亮点的多，面试官也会觉得你热爱技术。\n\n\n### 数据结构和算法\n\n- 红黑树\n- B树和B+树\n- 大文件排序\n[对含有一亿数据的大文件进行排序，要求使用内存小于32MB](https://blog.csdn.net/qq_29048719/article/details/81133643)\n参考链接：\n[二叉树，平衡二叉树，红黑树，B-树、B+树、B*树的区别](https://blog.csdn.net/wyqwilliam/article/details/82935922)\n[红黑树和AVL树（平衡二叉树）区别](https://blog.csdn.net/u010899985/article/details/80981053#commentBox)\n[一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)](https://www.cnblogs.com/aspirant/p/9214485.html)\n### Java基础\n[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)\n[面向对象与面向过程的优缺点](https://www.cnblogs.com/nanqiang/p/9934063.html)\n[面向对象五大基本原则详解](https://blog.csdn.net/qq_34375473/article/details/84852650)\n[反射原理](https://blog.csdn.net/h2604396739/article/details/83109292)\n[补码原理——负数为什么要用补码表示](https://blog.csdn.net/leonliu06/article/details/78685197)\n[跳表（SkipList）及ConcurrentSkipListMap源码解析](https://blog.csdn.net/sunxianghuang/article/details/52221913?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n<!--more-->\n### linux命令\n[Linux常用命令（面试题）](https://blog.csdn.net/qq_40910541/article/details/80686362)\n[最全Linux 面试常用命令](https://blog.csdn.net/jiangbr/article/details/82848492)\n### Jvm\n\n- 分代回收算法:http://www.importnew.com/19255.html\n年轻代：复制回收算法 Scavenge GC（Eden->Survivor->Survivor）\n老年代：年轻代n次回收后，扔存在的对象进入老年代。Full GC（老年、持久被写满或显示调用）用的是标记／清除法，老年代的垃圾回收会导致长时间的停顿\n持久代：存放静态文件\n收集器：串行：单线程效率高（适用于client模式下）；并行：多线程（最大垃圾回收暂停:吞吐量）；并发：应用不停止，响应要求高。浮动垃圾，需要保证内存空间\nCMS收集器，目前web服务器开发最常用的收集器，并发收集（也就是垃圾回收线程和应用程序线程同时运行）。问豪神：（由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 再次标记阶段（remark））\n\n- 在Java语言中，可以作为GC Roots的对象包括下面几种：\n\n虚拟机栈（栈帧中的本地变量表）中的引用对象。\n方法区中的类静态属性引用的对象。\n方法区中的常量引用的对象。\n本地方法栈中JNI（Native方法）的引用对象\n\n- JVM垃圾收集器：\n  Serial 收集器：串行收集器，使用单线程进行收集，适用于client模式\n  ParNew收集器：Serial的多线程版本\n  CMS 收集器：\n  初始标记：只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿\n  并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿\n  重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿\n  并发清除：不需要停顿\n- 对象创建过程：\n检查常量池中是否有即将要创建的这个对象所属的类的符号引用；\n进而检查这个符号引用所代表的类是否已经被JVM加载；若该类还没有被加载，就找该类的class文件，并加载进方法区；若该类已经被JVM加载，则准备为对象分配内存；\n根据方法区中该类的信息确定该类所需的内存大小； 一个对象所需的内存大小是在这个对象所属类被定义完就能确定的！且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。\n从堆中划分一块对应大小的内存空间给新的对象； 分配堆中内存有两种方式：指针碰撞 －－如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。　　空闲列表 －－如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。\n为对象中的成员变量赋上初始值(默认初始化)；对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；\n设置对象头中的信息；\n调用对象的构造函数进行初始化\n- JVM内存模型：\n【Java堆】用于存储Java对象，每个Java对象都是这个对象类的副本，会复制包含继承自它父类的所有非静态属性。\n【方法区】用于存储类结构信息，class文件加载进JVM时会被解析成JVM识别的几个部分分别存储在不同的数据结构中：常量池、域、方法数据、方法体、构造函数，包括类中的方法、实例初始化、接口初始化等。\n【Java栈】和线程关联，每个线程创建的时候，JVM都会为他分配一个对应的Java栈，这个栈含有多个栈帧；栈帧则是个方法关联，每个方法的运行都会创建一个自己的栈帧，含有内存变量，操作栈、方法返回值。\n【PC寄存器】则用于记录下一条要执行的字节码指令地址和被中断。如果方法是 native的，程序计数器寄存器的值不会被定义为空。\n【本地方法栈】是为JVM运行Native方法准备的空间，类似于Java栈。\n\n- 双亲委派模型\n\n启动类加载器  拓展类加载器  应用程序类加载器 自定义加载器\n每个类加载器在收到类加载请求时，都不会自己先加载，而是将该请求委派给父类加载器去完成，若父类加载器可以完成该类的加载请求任务，\n则成功返回，若父类加载器无法完成该类的加载请求任务，子类加载器才会尝试加载，这就是双亲委派模式。\n\n优点：采用双亲委派模式可使Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父加载器已经加载了该类时，就没有必要让子ClassLoader再加载一次。其次还可以防止子类加载器加载的类恶意覆盖Java核心API。例如，类java.lang.Object类存放在JDK\\jre\\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。\n\n- 类加载\n\n启动类加载器：Bootstrap ClassLoader，它负责加载存放在JDK\\jre\\lib(JDK代表??JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。\n扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。\n应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：1）在执行非置信代码之前，自动验证数字签名。2）动态地创建符合用户特定需要的定制化构建类。3）从特定的场所取得java class，例如数据库中和网络中。\n\n- 符号引用和直接引用\n\n在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类引用org.simple.Tool类，在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类 的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。\n符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。\n直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。\n\n参考链接：\n[CMS 垃圾收集器 - 工作原理，浮动垃圾，三色标记法 ](http://blog.sina.com.cn/s/blog_df25c55f0102wxh3.html)\n[jvm如何判断对象是否可以回收或存活](https://blog.csdn.net/weixin_28760063/article/details/81271827)\n[深入理解JVM虚拟机2：JVM垃圾回收基本原理和算法](https://blog.csdn.net/a724888/article/details/77981592)\n[CMS收集器和G1收集器 他们的优缺点对比 最后并发清除 CMS 不需要停顿，G1需要停顿...](https://blog.csdn.net/diaopai5230/article/details/101216653)\n[Jvm介绍](https://thinkinjava.cn/categories/JVM/)\n[自定义类加载器](https://blog.csdn.net/qq_36071795/article/details/83715456)\n[java虚拟机的符号引用和直接引用](https://blog.csdn.net/qq_34402394/article/details/72793119#commentBox)\n[JVM关于OOM异常的调优](https://blog.csdn.net/seujava_er/article/details/90114716)\n[深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型](https://blog.csdn.net/qq_38182963/article/details/78660779)\n[深入理解JVM-内存模型（jmm）和GC](https://www.jianshu.com/p/76959115d486)\n[阿里面试100%问到，JVM性能调优篇](https://blog.csdn.net/qq_20499001/article/details/89288497)\n[面试题之窒息翻译：类加载机制的双亲委派（正解：父委派模型）](https://blog.csdn.net/lengxiao1993/article/details/86689331#comments)\n[深入JVM字节码执行引擎](https://blog.csdn.net/dd864140130/article/details/49515403)\n### 并发\n\n1.悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。\n2.乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。\n3.线程池：新建线程 -> 达到核心数 -> 加入队列 -> 新建线程（非核心） -> 达到最大数 -> 触发拒绝策略。　线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务。线程数量达到了corePools，则将任务移入队列。等待队列已满，新建线程(非核心线程)执行任务。队列已满，总线程数又达到了maximumPoolSize，就会由(RejectedExecutionHandler)抛出异常\n4.为什么使用线程池：单个任务处理时间比较短，需要处理的任务数量很大。降低资源消耗　提高线程的可管理性　\n5.newCachedThreadPool 工作线程的创建数量几乎没有限制 newFixedThreadPool　　　 newScheduledThreadPool支持定时及周期性任务执行　　newSingleThreadExecutor单线程化的线程池，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行　　　\n6.线程池中的线程在新建后进入while循环，从task队列获取任务，当没有待执行任务时，若线程数量小于等于核心线程数量，若核心线程不可退出则调用队列的take阻塞直到新任务到来，若可以退出，则调用poll，时间超时后线程结束。\n7.CountDownLatch 利用它可以实现一个任务等待其他一个或一组任务执行后再触发的功能，不可重用。CyclicBarrier　让一组线程等待至某个状态之后再全部同时执行，可重用。\n8.分布式系统CAP定理：Consistency（一致性），Availability（可用性），Partition tolerance（分区容错）　web场景一般可用性高于一致性　所以退而求其次追求最终一致性(eventual consistency)　　分区容错在分布式系统中不可避免\n9.自旋锁与互斥锁：自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，所以自旋锁的效率远 高于互斥锁。虽然它的效率比互斥锁高，但是它一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。不适用与IO场景，单核CPU，代码长时间执行。自旋锁的实现：使用java的cas原子操作AtomicReference，循环将原子变量从null设置为当前线程，若当前原子变量不为null则一直循环。\n10.死锁的原因与预防：１互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程　２占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源　３不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。　４循环等待：存在一个进程环，使得每个进程都占有下一个进程所需的至少一种资源。\n       预防的主要做法是破坏除互斥之外的三个条件\n11.线程与进程的区别：\n       一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。\n       资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。\n       引入线程的操作系统中，把线程作为调度和分派的基本单位。而把进程作为资源拥有的基本单位\n       系统开销　由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。\n12.进程的几种状态: 1) 运行状态：进程正在处理器上上运行。在单处理器环境下，每个时刻最多只有一个进程处于运行状态。2) 就绪状态：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器即可运行。3) 阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入/输出完成。即使处理器空闲，该进程也不能运行。4) 创建状态：进程正在被创建，尚未到就绪状态。5) 结束状态：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\n13.程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码。初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据。未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据。栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。堆 (Heap):存储动态内存分配,需要程序员手工分配,手工释放.\n14.使用线程池的好处：减少创建和销毁线程导致的时间开销和内存资源开销，如果不使用线程池可能导致系统创建大量同类线程导致资源耗尽或者频繁切换\n15.UUID含义是通用唯一识别码 (Universally Unique Identifier) UUID由以下几部分的组合：\n       1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同\n       2）时钟序列。？？？问五七\n       3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得\n16.线程的几种创建方式：以继承Thread类的方式创建线程，　以实现Runnable接口的方式创建线程，　以Callable+FutureTask的方式创建线程\n17.公平锁与非公平锁的区别\n       非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。\n       非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。\n       公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。\n18.分布式事务：\n       TCC:Try、Confirm、Cancel　Try 阶段：对各个服务的资源做检测以及对资源进行锁定。Confirm 阶段：在各个服务中执行实际的操作。Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。 \n       [tcc事务原理](https://www.cnblogs.com/jajian/p/10014145.html)  \n参考链接：\n[Java并发编程之异步Future机制的原理和实现](https://blog.csdn.net/lovezhaohaimig/article/details/80344299)\n[深度解读 java 线程池设计思想及源码实现](https://javadoop.com/post/java-thread-pool)\n[CompletableFuture原理解析](https://www.jianshu.com/p/abfa29c01e1d)\n[CountDownLatch和CylicBarrier以及Semaphare你使用过吗](https://www.cnblogs.com/wangsen/p/11170709.html)\n[[分布式]：分布式系统的CAP理论](https://blog.csdn.net/w372426096/article/details/80437198)\n[分布式事务之TCC](https://www.jianshu.com/p/58911d2e8b28)\n[自旋锁、排队自旋锁、MCS锁、CLH锁](https://coderbee.net/index.php/concurrent/20131115/577)\n### Spring\n\n- 动态代理\n\nCglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.\njdk动态代理\n\n- IOC\n\n    1.IOC: 容器ApplicationContext虽然继承自BeanFactory的接口，但其内部持有一个BeanFactory实例，用于创建和管理Bean，项目启动后调用其refresh方法进行初始化，生成所有单例模式的Bean。BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。首先会根据配置加载BeanDefinition，然后将所以的BeanDefinition存入容器的一个Map中，完成后BeanFactory的初始化完成。随后开始Bean的初始化流程，通过getBean进行加载，已经加载过的会直接返回，加载过程中遇到依赖的Bean会进行递归加载，调用无参构造函数或者构造函数依赖注入进行实例创建，然后对Bean依赖的property进行注入\n    2.Spring循换依赖问题：通过三级缓存和提前曝光机制解决。比如Ａ字段中依赖Ｂ，Ｂ字段中依赖Ａ。当Ａ在实例化后（对象初始化的第一步）便曝光到第三级缓存中，属性赋值Ｂ时发现没有B，便初始化Ｂ，在属性赋值Ａ时便可以在第三级缓存中找到Ａ的引用赋值，完成Ｂ的初始化，保存到第一级缓存；之后返回给Ａ完成初始化。\n    \n参考链接：\n[Spring IOC 容器源码分析](https://javadoop.com/post/spring-ioc)\n[Spring如何解决循环依赖](https://blog.csdn.net/quliuwuyiz/article/details/79416184)\n\n-　AOP\n\nAOP:　ProxyFatoryBean用于创建代理对象，先初始化Advisor链，然后进行代理类的生成。当代理类执行方法时，会调用invoke方法，invoke方法中对aop拦截器进行检测，如果存在拦截器，则生成MethodInvocation进行拦截链的链式调用。不断得调用procced方法，每次进去后计数器自增，取出下一个拦截其，检查advise与当前的调用是否match,匹配的话将执行该advise    \n\n\n参考链接：\n[Spring AOP 源码解析](https://javadoop.com/post/spring-aop-source)\n[剑指Spring源码（三）俯瞰Spring的Bean的生命周期（大众版）](https://www.cnblogs.com/CodeBear/p/10867707.html#4462519)\n### Spring Cloud\n\n- Ribbon\n　负责均衡客户端基于RestTemplate实现，通过拦截器机制实现负载均衡，在拦截器中拿到请求url中的serviceId，传入LoadBalanceClient进行服务实例的获取,获取时通过ILoadBalance负载均衡器获取服务，服务实例对象封装了ip等信息。利用服务实例初始化serviceRequestWarpper，重写getUri函数将服务id转换为ip，继续进行后续拦截链的链式调用。\n\n参考链接：\n[关于RestTemplate 非常推荐的几篇博文（原理剖析）](https://blog.csdn.net/hanhanbubble/article/details/90752591)\n[spring cloud底层原理](https://www.cnblogs.com/jajian/p/9973555.html)\n### 设计模式\n\n- 代理模式\n\n静态代理：由程序员或特定工具创建代理类，在程序运行前代理类的.class文件已经存在\n动态代理：在程序运行时通过反射机制动态创建而成\n\n静态代理类优缺点\n\n优点：\n\n代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合），对于如上的客户端代码，newUserManagerImpl()可以应用工厂将它隐藏，如上只是举个例子而已。\n\n缺点：\n\n1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。\n\n参考链接：\n[代理模式](https://www.cnblogs.com/zuoxiaolong/p/pattern3.html)\n[JAVA学习篇--静态代理VS动态代理](https://blog.csdn.net/hejingyuan6/article/details/36203505)\n[项目中用到的设计模式](https://www.jianshu.com/p/8afd396e314f)\n### 数据库\n\n- 引擎对比  \nMyISAM拥有较高的插入、查询速度，但不支持事务。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复\nInnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。辅助索引data域存储相应记录主键的值而不是地址。InnoDB还支持外键（FOREIGN KEY）\n\n[MySQL存储引擎MyISAM与InnoDB区别总结整理]()\n- 事务\n\n数据库事务的实现原理：\n事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁），这时该事物的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中），这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。\n原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。\nRedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。\n\n脏读：是指一个事务中访问到了另外一个事务未提交的数据。不可重复读是指在一个事务内根据同一个条件对行记录进行多次查询，但是搜出来的结果却不一致。幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。不同在于不可重复读是同一个记录的数据内容被修改了，幻读是数据行记录变多了或者少了\n事务隔离：read uncommitted（读取未提交数据：导致脏读）　read committed（可以读取其他事务提交的数据：导致不可重复读）---大多数数据库默认的隔离级别；repeatable read（可重读：导致幻读）---MySQL默认的隔离级别；serializable（串行化：有事务读的时候其他写会被挂起）\n\n事务特性：原子性　　一致性　数据库总数从一个一致性的状态转换到另一个一致性的状态。　　隔离性　一个事务所做的修改在最终提交以前，对其他事务是不可见的。　持久性　一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。\n- 索引\n数据库索引分类：从数据结构角度　B+树索引　hash索引　FULLTEXT索引（InnoDB引擎5.7以后支持）R-Tree索引　　从物理存储角度　　聚簇索引（一般对主键建立，物理存放顺序与索引顺序是一致的）　非聚簇索引　　聚簇索引中的每个叶子节点包含主键值和余下的列\n\n- mysql gap锁\n\n只有在rr隔离级别下才会使用gap锁，会把数据库中索引行划分为一个个左开右闭的区间（相邻行记录），根据where < >这种查询方式，使用gap锁\n\n[MySQL innodb中各种SQL语句加锁分析](http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html)\n[和刚入门的菜鸟们聊聊--什么是聚簇索引与非聚簇索引](https://www.cnblogs.com/auxg/p/Cluster-and-NonCluster-index.html)\n[多个单列索引和联合索引的区别详解](https://blog.csdn.net/Abysscarry/article/details/80792876)\n- Redis\nRedis主从同步策略　主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。https://blog.csdn.net/rentuo53/article/details/84912941\nRedis的哨兵机制　能监控多个master-slave集群，发现master宕机后能进行自动切换。不时地监控redis是否按照预期良好地运行;如果发现某个redis节点运行出现状况，能够通知另外一个进程；能够进行自动切换（进行主备切换）。当一个master节点不可用时，能够选举出master的多个slave中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。使用raft选举算法.\n缓存穿透：缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。　　　解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n缓存雪崩　缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。解决方案：缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n缓存击穿　对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。解决方案　使用互斥锁(mutex key)　业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。\n[Redis深度解析](https://blog.csdn.net/a2133212132/article/details/80685313?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n- 分布式系统一致性\n  XA协议　　第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交　　第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。　　优点： 尽量保证了数据的强一致，实现成本较低，缺点:　单点问题:事务管理器如果宕机，资源管理器就会一直阻塞，导致数据库无法使用。　同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。　数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。\n- 数据库优化\n\n查询优化：面对大规模数据量时，采取SELECT * FROM table WHERE id >= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 对分页查询进行优化，由于查询出id后，会遍历按照id 去外存区table数据　然后丢弃前面的，导致效率低下。\n[如何提高MySQL Limit查询的性能](http://www.nowamagic.net/librarys/veda/detail/1900)\n[数据库优化方案整理](https://blog.csdn.net/u013628152/article/details/82184809)\n\n参考链接：\n[MySQL的锁机制和加锁原理](https://blog.csdn.net/qq_38238296/article/details/88362999#commentBox)\n[mysql学习](https://blog.csdn.net/mysteryhaohao/category_6270382.html)\n[MySql 三大知识点——索引、锁、事务](https://thinkinjava.cn/2019/03/16/2019/2019-03-16-mysql/)\n[为什么分布式一定要有redis，redis的一些优缺点q](https://blog.csdn.net/hcmony/article/details/80694560)\n[数据库本地事务的实现原理](https://blog.csdn.net/qq360694660/article/details/88695365)\n[数据库 redo undo log](https://blog.csdn.net/oracle_29/article/details/85717855)\n[大白话布隆过滤器](https://www.cnblogs.com/CodeBear/p/10911177.html)\n[谈谈数据库，缓存一致性](https://www.cnblogs.com/CodeBear/p/12118050.html#4472208)\n[REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案](https://www.cnblogs.com/xichji/p/11286443.html)\n[一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)](https://www.cnblogs.com/aspirant/p/9214485.html)\n[Redis持久化(rdb、aof、混合)](https://blog.csdn.net/yhl_jxy/article/details/91879874)\n[面试中关于Redis的问题看这篇就够了](https://blog.csdn.net/qq_34337272/article/details/80012284)\n### 网络\n- tcp三次握手的本质：交换并确认双方的数据序号。\n        1.SYN-SENT --> <SEQ=100><CTL=SYN> --> SYN-RECEIVED ​ \n        2.ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED ​ \n        3.ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK> --> ESTABLISHED\n        四次挥手，每一端的关闭请求都需要被确认一次：2（client, server）*2(FIN, ACK)　服务器主动关闭链接的话会只有两次挥手　后续会回复客户端RST\n        \n        TIME_WAIT的产生条件：主动关闭方在发送四次挥手的最后一个ACK（第四次挥手后不会立刻关闭）会变为TIME_WAIT状态，保留次状态的时间为两个MSL（linux里一个MSL为30s，是不可配置的）\n        TIME_WAIT两个MSL的作用：可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会对FIN开启TCP重传，发\n        送多个FIN包，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其它服务产生影响。\n        TIME_WAIT占用的资源：少量内存（查资料大概4K）和一个fd。\n        TIME_WAIT关闭的危害：1、  网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被\n        动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；2、  同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动\n        方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。\n        TIME_WAIT过多的解决办法： net.ipv4.tcp_tw_recycle=1  　表示开启TCP连接中TIME-WAIT sockets的快速回收\n- Reactor模式\n    　一种比较流行的做法是服务端监听线程和 IO 线程分离，类似于 Reactor 的多线程模型。bossGrouＰ线程组实际就是 Acceptor 线程池，负责处理客户端的 TCP 连接请求，workerGroup 是真正负责 I/O 读写操作的线程组\n    \n- TCP确保可靠性的机制　校验和　序列号　确认应答　超时重传　连接管理（三次握手　四次挥手）　\n  流量控制　在TCP协议的报头信息当中，有窗口大小，即接收端接收数据缓冲区的剩余大小。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。\n  拥塞控制　 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认\n  RST标志位表示强制断开链接\n  sack selective acknowledgment，也就是选择性确认，添加sack功能需要在TCP包头加两个选项，一个是开启选项（enabling optiocookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效,存放数据大小一般4K左右，而sessionStorage与localStorage大小在5兆左右，在客户端生成，localStorage除非被清除，否则会永久保存，sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除，cookie在与服务器端通信每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题,而sessionStorage与localStorage仅在客户端（即浏览器）中保存，不参与和服务器的通信。n），另一个是sack选项（sack option）本身。开启sack选项后，receiver会将自己收到了哪些包，没收到哪些包的信息记录在sack段中告诉给sender，这样sender便可以一次性重传所有的丢包。\n  MSS : Maximum Segment Size最大分段大小\n- 状态码:\n  100（Continue）客户端应该继续它的请求。这个过渡的响应用于告知客户端，请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应。服务器必须在请求完成后发送一个最终的响应。\n  206状态码（Partial Content）服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n  304 表明了客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题.\n  301 redirect: 301 代表永久性转移(Permanently Moved) 302 redirect: 302 代表暂时性转移(Temporarily Moved )\n- EPoll两种工作模式\n    ET:当有事件发生时，系统只会通知你一次，即在调用epoll_wait返回fd后，不管这个事件你处理还是没处理，处理完没有处理完，当再次调用epoll_wait时，都不会再返回该fd　LT:使用LT模式意味着只要fd处于可读或者可写状态，每次epoll_wait都会返回该fd，这样的话会带来很大的系统开销，且处理时候每次都需要把这些fd轮询一遍，如果fd的数量巨大，不管有没有事件发生，epoll_wait都会触发这些fd的轮询判断。\n- TCP报文段是面向字节流的，UDP包是面向数据报的\n    面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。在TCP建立连接前两次握手的SYN报文中选项字段的MSS值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口协议来控制通信双发的数据。\n    tcp传输对准确性要求高速度相对可以慢，因此用于HTTP,FTP，邮件传输，远程连接；udp用于即时通讯延迟低，准确性低，网络电话，语音通信\n- netty的零拷贝\n    将内存空间分段的字节数组在逻辑上整合为一个整体的字节数组（段式内存思想，将逻辑index变成分块编号和段内偏移）\n参考链接：\n[Reactor三种线程模型与Netty线程模型](https://www.cnblogs.com/lvyahui/p/9030232.html)    \n[TCP 和 UDP 的区别](https://blog.csdn.net/zhang6223284/article/details/81414149)\n[TCP-IP详解：SACK选项（Selective Acknowledgment）](https://blog.csdn.net/wdscq1234/article/details/52503315?locationNum=3)\n### IO\n- 网络io发生时涉及的对象和步骤\n    1）等待数据准备 (Waiting for the data to be ready)\n    2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)\n[web服务器和客户端完成并行处理请求三大方式](https://blog.csdn.net/u011032846/article/details/81507216)\n[并发编程(IO多路复用)](https://www.cnblogs.com/cainingning/p/9556642.html)\n### 分布式\n- rpc\n[如何给老婆解释什么是RPC](https://www.jianshu.com/p/2accc2840a1b)\n[如何实现一个简单的RPC](https://www.jianshu.com/p/5b90a4e70783)\n- springCloud\n[SpringCloud面试常见问题](https://blog.csdn.net/jerryDzan/article/details/89137818)\n### 场景问题\n[Reactor模式](https://www.cnblogs.com/crazymakercircle/p/9833847.html)\n[一个最简单的RPC实现及其原理](https://blog.csdn.net/qq_38601777/article/details/104092959)\n[架构师手把手教你如何设计一个秒杀系统？](https://www.jianshu.com/p/729f1f0f6e18)\n[如何设计一个秒杀系统](https://blog.csdn.net/mulinsen77/article/details/89054063)\n[检查 1亿的手机号码以进行重复](https://kb.kutu66.com/algorithm/post_1011410  )\n[如何在有限的内存限制下实现数十亿级手机号码去重](https://www.jianshu.com/p/b39eb55d4670)\n[Java多线程读取大文件](https://www.cnblogs.com/metoy/p/4470418.html)","slug":"暑期实习面试准备","published":1,"updated":"2020-03-16T07:13:21.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz7z00239oet94uje4b8","content":"<h3 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h3><ul>\n<li>多思考，挖掘项目难点，多总结<br>做完项目一定要总结，自己在项目中担任什么角色，解决了什么痛点，项目有哪些难点，怎么解决难点这些，<br>以及可以优化的地方，优化方案等，可以不一定实现，但是一定要知道怎么去解决。<br>但是如果没有想清楚难点、优化思路，再多的项目经验也白搭。</li>\n<li>引导式面试<br>面试肯定会遇到不会的地方，这个时候直接说不会，虽然不一定会直接挂，但是对整个面试肯定会有影响，<br>这个时候就可以把面试官引导到自己熟悉的相关技术上，一般绝大多数面试官会让继续讲，<br>建议可以各个方面知识都研究一个，研究深入点即可，例如缓存redis、消息队列kafka等。<br>去理解面试官想要问的东西，主动去说，不一定要等到面试官问透，而且很多面试官表述问题不清楚，<br>这时候一定要问清楚面试官想问的是不是你要回答的，答非所问也十分不可取。</li>\n<li>每次面试必总结<br>面试真的是学习技术最快的过程，很多时候自己学的，不一定学透了，经过面试官一顿灵魂拷问后发现自己什么都不会，<br>面试完总结这些知识，然后多面试几次后面就很容易了。</li>\n<li>自信<br>很多时候会被面试官问到怀疑人生，也可能会经历压力面，面试问的越难，反倒可能说明面试官对你很认可，<br>需要问些更深入的问题提高评级。<br>不论面试官问的问题是已经准备了很久的、烂熟于心还是从未接触过，都要自信，从容面对，也千万不要因为简单问题而放松，简单问题也可以回答的不一样，<br>例如java gc可以降到jdk11最新回收算法，这肯定比书上看到的cms g1有亮点的多，面试官也会觉得你热爱技术。</li>\n</ul>\n<h3 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h3><ul>\n<li><p>红黑树</p>\n</li>\n<li><p>B树和B+树</p>\n</li>\n<li><p>大文件排序<br><a href=\"https://blog.csdn.net/qq_29048719/article/details/81133643\" target=\"_blank\" rel=\"noopener\">对含有一亿数据的大文件进行排序，要求使用内存小于32MB</a><br>参考链接：<br><a href=\"https://blog.csdn.net/wyqwilliam/article/details/82935922\" target=\"_blank\" rel=\"noopener\">二叉树，平衡二叉树，红黑树，B-树、B+树、B*树的区别</a><br><a href=\"https://blog.csdn.net/u010899985/article/details/80981053#commentBox\" target=\"_blank\" rel=\"noopener\">红黑树和AVL树（平衡二叉树）区别</a><br><a href=\"https://www.cnblogs.com/aspirant/p/9214485.html\" target=\"_blank\" rel=\"noopener\">一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)</a></p>\n<h3 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h3><p><a href=\"https://tech.meituan.com/2018/11/15/java-lock.html\" target=\"_blank\" rel=\"noopener\">不可不说的Java“锁”事</a><br><a href=\"https://www.cnblogs.com/nanqiang/p/9934063.html\" target=\"_blank\" rel=\"noopener\">面向对象与面向过程的优缺点</a><br><a href=\"https://blog.csdn.net/qq_34375473/article/details/84852650\" target=\"_blank\" rel=\"noopener\">面向对象五大基本原则详解</a><br><a href=\"https://blog.csdn.net/h2604396739/article/details/83109292\" target=\"_blank\" rel=\"noopener\">反射原理</a><br><a href=\"https://blog.csdn.net/leonliu06/article/details/78685197\" target=\"_blank\" rel=\"noopener\">补码原理——负数为什么要用补码表示</a><br><a href=\"https://blog.csdn.net/sunxianghuang/article/details/52221913?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">跳表（SkipList）及ConcurrentSkipListMap源码解析</a></p>\n<a id=\"more\"></a>\n<h3 id=\"linux命令\"><a href=\"#linux命令\" class=\"headerlink\" title=\"linux命令\"></a>linux命令</h3><p><a href=\"https://blog.csdn.net/qq_40910541/article/details/80686362\" target=\"_blank\" rel=\"noopener\">Linux常用命令（面试题）</a><br><a href=\"https://blog.csdn.net/jiangbr/article/details/82848492\" target=\"_blank\" rel=\"noopener\">最全Linux 面试常用命令</a></p>\n<h3 id=\"Jvm\"><a href=\"#Jvm\" class=\"headerlink\" title=\"Jvm\"></a>Jvm</h3></li>\n<li><p>分代回收算法:<a href=\"http://www.importnew.com/19255.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/19255.html</a><br>年轻代：复制回收算法 Scavenge GC（Eden-&gt;Survivor-&gt;Survivor）<br>老年代：年轻代n次回收后，扔存在的对象进入老年代。Full GC（老年、持久被写满或显示调用）用的是标记／清除法，老年代的垃圾回收会导致长时间的停顿<br>持久代：存放静态文件<br>收集器：串行：单线程效率高（适用于client模式下）；并行：多线程（最大垃圾回收暂停:吞吐量）；并发：应用不停止，响应要求高。浮动垃圾，需要保证内存空间<br>CMS收集器，目前web服务器开发最常用的收集器，并发收集（也就是垃圾回收线程和应用程序线程同时运行）。问豪神：（由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 再次标记阶段（remark））</p>\n</li>\n<li><p>在Java语言中，可以作为GC Roots的对象包括下面几种：</p>\n</li>\n</ul>\n<p>虚拟机栈（栈帧中的本地变量表）中的引用对象。<br>方法区中的类静态属性引用的对象。<br>方法区中的常量引用的对象。<br>本地方法栈中JNI（Native方法）的引用对象</p>\n<ul>\n<li><p>JVM垃圾收集器：<br>Serial 收集器：串行收集器，使用单线程进行收集，适用于client模式<br>ParNew收集器：Serial的多线程版本<br>CMS 收集器：<br>初始标记：只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿<br>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿<br>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿<br>并发清除：不需要停顿</p>\n</li>\n<li><p>对象创建过程：<br>检查常量池中是否有即将要创建的这个对象所属的类的符号引用；<br>进而检查这个符号引用所代表的类是否已经被JVM加载；若该类还没有被加载，就找该类的class文件，并加载进方法区；若该类已经被JVM加载，则准备为对象分配内存；<br>根据方法区中该类的信息确定该类所需的内存大小； 一个对象所需的内存大小是在这个对象所属类被定义完就能确定的！且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。<br>从堆中划分一块对应大小的内存空间给新的对象； 分配堆中内存有两种方式：指针碰撞 －－如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。　　空闲列表 －－如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。<br>为对象中的成员变量赋上初始值(默认初始化)；对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；<br>设置对象头中的信息；<br>调用对象的构造函数进行初始化</p>\n</li>\n<li><p>JVM内存模型：<br>【Java堆】用于存储Java对象，每个Java对象都是这个对象类的副本，会复制包含继承自它父类的所有非静态属性。<br>【方法区】用于存储类结构信息，class文件加载进JVM时会被解析成JVM识别的几个部分分别存储在不同的数据结构中：常量池、域、方法数据、方法体、构造函数，包括类中的方法、实例初始化、接口初始化等。<br>【Java栈】和线程关联，每个线程创建的时候，JVM都会为他分配一个对应的Java栈，这个栈含有多个栈帧；栈帧则是个方法关联，每个方法的运行都会创建一个自己的栈帧，含有内存变量，操作栈、方法返回值。<br>【PC寄存器】则用于记录下一条要执行的字节码指令地址和被中断。如果方法是 native的，程序计数器寄存器的值不会被定义为空。<br>【本地方法栈】是为JVM运行Native方法准备的空间，类似于Java栈。</p>\n</li>\n<li><p>双亲委派模型</p>\n</li>\n</ul>\n<p>启动类加载器  拓展类加载器  应用程序类加载器 自定义加载器<br>每个类加载器在收到类加载请求时，都不会自己先加载，而是将该请求委派给父类加载器去完成，若父类加载器可以完成该类的加载请求任务，<br>则成功返回，若父类加载器无法完成该类的加载请求任务，子类加载器才会尝试加载，这就是双亲委派模式。</p>\n<p>优点：采用双亲委派模式可使Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父加载器已经加载了该类时，就没有必要让子ClassLoader再加载一次。其次还可以防止子类加载器加载的类恶意覆盖Java核心API。例如，类java.lang.Object类存放在JDK\\jre\\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>\n<ul>\n<li>类加载</li>\n</ul>\n<p>启动类加载器：Bootstrap ClassLoader，它负责加载存放在JDK\\jre\\lib(JDK代表??JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.<em>开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。<br>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.</em>开头的类），开发者可以直接使用扩展类加载器。<br>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br>因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：1）在执行非置信代码之前，自动验证数字签名。2）动态地创建符合用户特定需要的定制化构建类。3）从特定的场所取得java class，例如数据库中和网络中。</p>\n<ul>\n<li>符号引用和直接引用</li>\n</ul>\n<p>在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类引用org.simple.Tool类，在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类 的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。<br>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。<br>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p>\n<p>参考链接：<br><a href=\"http://blog.sina.com.cn/s/blog_df25c55f0102wxh3.html\" target=\"_blank\" rel=\"noopener\">CMS 垃圾收集器 - 工作原理，浮动垃圾，三色标记法 </a><br><a href=\"https://blog.csdn.net/weixin_28760063/article/details/81271827\" target=\"_blank\" rel=\"noopener\">jvm如何判断对象是否可以回收或存活</a><br><a href=\"https://blog.csdn.net/a724888/article/details/77981592\" target=\"_blank\" rel=\"noopener\">深入理解JVM虚拟机2：JVM垃圾回收基本原理和算法</a><br><a href=\"https://blog.csdn.net/diaopai5230/article/details/101216653\" target=\"_blank\" rel=\"noopener\">CMS收集器和G1收集器 他们的优缺点对比 最后并发清除 CMS 不需要停顿，G1需要停顿…</a><br><a href=\"https://thinkinjava.cn/categories/JVM/\" target=\"_blank\" rel=\"noopener\">Jvm介绍</a><br><a href=\"https://blog.csdn.net/qq_36071795/article/details/83715456\" target=\"_blank\" rel=\"noopener\">自定义类加载器</a><br><a href=\"https://blog.csdn.net/qq_34402394/article/details/72793119#commentBox\" target=\"_blank\" rel=\"noopener\">java虚拟机的符号引用和直接引用</a><br><a href=\"https://blog.csdn.net/seujava_er/article/details/90114716\" target=\"_blank\" rel=\"noopener\">JVM关于OOM异常的调优</a><br><a href=\"https://blog.csdn.net/qq_38182963/article/details/78660779\" target=\"_blank\" rel=\"noopener\">深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型</a><br><a href=\"https://www.jianshu.com/p/76959115d486\" target=\"_blank\" rel=\"noopener\">深入理解JVM-内存模型（jmm）和GC</a><br><a href=\"https://blog.csdn.net/qq_20499001/article/details/89288497\" target=\"_blank\" rel=\"noopener\">阿里面试100%问到，JVM性能调优篇</a><br><a href=\"https://blog.csdn.net/lengxiao1993/article/details/86689331#comments\" target=\"_blank\" rel=\"noopener\">面试题之窒息翻译：类加载机制的双亲委派（正解：父委派模型）</a><br><a href=\"https://blog.csdn.net/dd864140130/article/details/49515403\" target=\"_blank\" rel=\"noopener\">深入JVM字节码执行引擎</a></p>\n<h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3><p>1.悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。<br>2.乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。<br>3.线程池：新建线程 -&gt; 达到核心数 -&gt; 加入队列 -&gt; 新建线程（非核心） -&gt; 达到最大数 -&gt; 触发拒绝策略。　线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务。线程数量达到了corePools，则将任务移入队列。等待队列已满，新建线程(非核心线程)执行任务。队列已满，总线程数又达到了maximumPoolSize，就会由(RejectedExecutionHandler)抛出异常<br>4.为什么使用线程池：单个任务处理时间比较短，需要处理的任务数量很大。降低资源消耗　提高线程的可管理性　<br>5.newCachedThreadPool 工作线程的创建数量几乎没有限制 newFixedThreadPool　　　 newScheduledThreadPool支持定时及周期性任务执行　　newSingleThreadExecutor单线程化的线程池，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行　　　<br>6.线程池中的线程在新建后进入while循环，从task队列获取任务，当没有待执行任务时，若线程数量小于等于核心线程数量，若核心线程不可退出则调用队列的take阻塞直到新任务到来，若可以退出，则调用poll，时间超时后线程结束。<br>7.CountDownLatch 利用它可以实现一个任务等待其他一个或一组任务执行后再触发的功能，不可重用。CyclicBarrier　让一组线程等待至某个状态之后再全部同时执行，可重用。<br>8.分布式系统CAP定理：Consistency（一致性），Availability（可用性），Partition tolerance（分区容错）　web场景一般可用性高于一致性　所以退而求其次追求最终一致性(eventual consistency)　　分区容错在分布式系统中不可避免<br>9.自旋锁与互斥锁：自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，所以自旋锁的效率远 高于互斥锁。虽然它的效率比互斥锁高，但是它一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。不适用与IO场景，单核CPU，代码长时间执行。自旋锁的实现：使用java的cas原子操作AtomicReference，循环将原子变量从null设置为当前线程，若当前原子变量不为null则一直循环。<br>10.死锁的原因与预防：１互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程　２占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源　３不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。　４循环等待：存在一个进程环，使得每个进程都占有下一个进程所需的至少一种资源。<br>       预防的主要做法是破坏除互斥之外的三个条件<br>11.线程与进程的区别：<br>       一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。<br>       资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。<br>       引入线程的操作系统中，把线程作为调度和分派的基本单位。而把进程作为资源拥有的基本单位<br>       系统开销　由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。<br>12.进程的几种状态: 1) 运行状态：进程正在处理器上上运行。在单处理器环境下，每个时刻最多只有一个进程处于运行状态。2) 就绪状态：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器即可运行。3) 阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入/输出完成。即使处理器空闲，该进程也不能运行。4) 创建状态：进程正在被创建，尚未到就绪状态。5) 结束状态：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。<br>13.程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码。初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据。未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据。栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。堆 (Heap):存储动态内存分配,需要程序员手工分配,手工释放.<br>14.使用线程池的好处：减少创建和销毁线程导致的时间开销和内存资源开销，如果不使用线程池可能导致系统创建大量同类线程导致资源耗尽或者频繁切换<br>15.UUID含义是通用唯一识别码 (Universally Unique Identifier) UUID由以下几部分的组合：<br>       1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同<br>       2）时钟序列。？？？问五七<br>       3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得<br>16.线程的几种创建方式：以继承Thread类的方式创建线程，　以实现Runnable接口的方式创建线程，　以Callable+FutureTask的方式创建线程<br>17.公平锁与非公平锁的区别<br>       非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。<br>       非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。<br>       公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。<br>18.分布式事务：<br>       TCC:Try、Confirm、Cancel　Try 阶段：对各个服务的资源做检测以及对资源进行锁定。Confirm 阶段：在各个服务中执行实际的操作。Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。<br>       <a href=\"https://www.cnblogs.com/jajian/p/10014145.html\" target=\"_blank\" rel=\"noopener\">tcc事务原理</a><br>参考链接：<br><a href=\"https://blog.csdn.net/lovezhaohaimig/article/details/80344299\" target=\"_blank\" rel=\"noopener\">Java并发编程之异步Future机制的原理和实现</a><br><a href=\"https://javadoop.com/post/java-thread-pool\" target=\"_blank\" rel=\"noopener\">深度解读 java 线程池设计思想及源码实现</a><br><a href=\"https://www.jianshu.com/p/abfa29c01e1d\" target=\"_blank\" rel=\"noopener\">CompletableFuture原理解析</a><br><a href=\"https://www.cnblogs.com/wangsen/p/11170709.html\" target=\"_blank\" rel=\"noopener\">CountDownLatch和CylicBarrier以及Semaphare你使用过吗</a><br><a href=\"https://blog.csdn.net/w372426096/article/details/80437198\" target=\"_blank\" rel=\"noopener\">[分布式]：分布式系统的CAP理论</a><br><a href=\"https://www.jianshu.com/p/58911d2e8b28\" target=\"_blank\" rel=\"noopener\">分布式事务之TCC</a><br><a href=\"https://coderbee.net/index.php/concurrent/20131115/577\" target=\"_blank\" rel=\"noopener\">自旋锁、排队自旋锁、MCS锁、CLH锁</a></p>\n<h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><ul>\n<li>动态代理</li>\n</ul>\n<p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.<br>jdk动态代理</p>\n<ul>\n<li><p>IOC</p>\n<p>  1.IOC: 容器ApplicationContext虽然继承自BeanFactory的接口，但其内部持有一个BeanFactory实例，用于创建和管理Bean，项目启动后调用其refresh方法进行初始化，生成所有单例模式的Bean。BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。首先会根据配置加载BeanDefinition，然后将所以的BeanDefinition存入容器的一个Map中，完成后BeanFactory的初始化完成。随后开始Bean的初始化流程，通过getBean进行加载，已经加载过的会直接返回，加载过程中遇到依赖的Bean会进行递归加载，调用无参构造函数或者构造函数依赖注入进行实例创建，然后对Bean依赖的property进行注入<br>  2.Spring循换依赖问题：通过三级缓存和提前曝光机制解决。比如Ａ字段中依赖Ｂ，Ｂ字段中依赖Ａ。当Ａ在实例化后（对象初始化的第一步）便曝光到第三级缓存中，属性赋值Ｂ时发现没有B，便初始化Ｂ，在属性赋值Ａ时便可以在第三级缓存中找到Ａ的引用赋值，完成Ｂ的初始化，保存到第一级缓存；之后返回给Ａ完成初始化。</p>\n</li>\n</ul>\n<p>参考链接：<br><a href=\"https://javadoop.com/post/spring-ioc\" target=\"_blank\" rel=\"noopener\">Spring IOC 容器源码分析</a><br><a href=\"https://blog.csdn.net/quliuwuyiz/article/details/79416184\" target=\"_blank\" rel=\"noopener\">Spring如何解决循环依赖</a></p>\n<p>-　AOP</p>\n<p>AOP:　ProxyFatoryBean用于创建代理对象，先初始化Advisor链，然后进行代理类的生成。当代理类执行方法时，会调用invoke方法，invoke方法中对aop拦截器进行检测，如果存在拦截器，则生成MethodInvocation进行拦截链的链式调用。不断得调用procced方法，每次进去后计数器自增，取出下一个拦截其，检查advise与当前的调用是否match,匹配的话将执行该advise    </p>\n<p>参考链接：<br><a href=\"https://javadoop.com/post/spring-aop-source\" target=\"_blank\" rel=\"noopener\">Spring AOP 源码解析</a><br><a href=\"https://www.cnblogs.com/CodeBear/p/10867707.html#4462519\" target=\"_blank\" rel=\"noopener\">剑指Spring源码（三）俯瞰Spring的Bean的生命周期（大众版）</a></p>\n<h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3><ul>\n<li>Ribbon<br>　负责均衡客户端基于RestTemplate实现，通过拦截器机制实现负载均衡，在拦截器中拿到请求url中的serviceId，传入LoadBalanceClient进行服务实例的获取,获取时通过ILoadBalance负载均衡器获取服务，服务实例对象封装了ip等信息。利用服务实例初始化serviceRequestWarpper，重写getUri函数将服务id转换为ip，继续进行后续拦截链的链式调用。</li>\n</ul>\n<p>参考链接：<br><a href=\"https://blog.csdn.net/hanhanbubble/article/details/90752591\" target=\"_blank\" rel=\"noopener\">关于RestTemplate 非常推荐的几篇博文（原理剖析）</a><br><a href=\"https://www.cnblogs.com/jajian/p/9973555.html\" target=\"_blank\" rel=\"noopener\">spring cloud底层原理</a></p>\n<h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><ul>\n<li>代理模式</li>\n</ul>\n<p>静态代理：由程序员或特定工具创建代理类，在程序运行前代理类的.class文件已经存在<br>动态代理：在程序运行时通过反射机制动态创建而成</p>\n<p>静态代理类优缺点</p>\n<p>优点：</p>\n<p>代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合），对于如上的客户端代码，newUserManagerImpl()可以应用工厂将它隐藏，如上只是举个例子而已。</p>\n<p>缺点：</p>\n<p>1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p>\n<p>2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。</p>\n<p>参考链接：<br><a href=\"https://www.cnblogs.com/zuoxiaolong/p/pattern3.html\" target=\"_blank\" rel=\"noopener\">代理模式</a><br><a href=\"https://blog.csdn.net/hejingyuan6/article/details/36203505\" target=\"_blank\" rel=\"noopener\">JAVA学习篇–静态代理VS动态代理</a><br><a href=\"https://www.jianshu.com/p/8afd396e314f\" target=\"_blank\" rel=\"noopener\">项目中用到的设计模式</a></p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><ul>\n<li>引擎对比<br>MyISAM拥有较高的插入、查询速度，但不支持事务。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复<br>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。辅助索引data域存储相应记录主键的值而不是地址。InnoDB还支持外键（FOREIGN KEY）</li>\n</ul>\n<p><a href>MySQL存储引擎MyISAM与InnoDB区别总结整理</a></p>\n<ul>\n<li>事务</li>\n</ul>\n<p>数据库事务的实现原理：<br>事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁），这时该事物的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中），这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。<br>原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。</p>\n<p>脏读：是指一个事务中访问到了另外一个事务未提交的数据。不可重复读是指在一个事务内根据同一个条件对行记录进行多次查询，但是搜出来的结果却不一致。幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。不同在于不可重复读是同一个记录的数据内容被修改了，幻读是数据行记录变多了或者少了<br>事务隔离：read uncommitted（读取未提交数据：导致脏读）　read committed（可以读取其他事务提交的数据：导致不可重复读）—大多数数据库默认的隔离级别；repeatable read（可重读：导致幻读）—MySQL默认的隔离级别；serializable（串行化：有事务读的时候其他写会被挂起）</p>\n<p>事务特性：原子性　　一致性　数据库总数从一个一致性的状态转换到另一个一致性的状态。　　隔离性　一个事务所做的修改在最终提交以前，对其他事务是不可见的。　持久性　一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>\n<ul>\n<li><p>索引<br>数据库索引分类：从数据结构角度　B+树索引　hash索引　FULLTEXT索引（InnoDB引擎5.7以后支持）R-Tree索引　　从物理存储角度　　聚簇索引（一般对主键建立，物理存放顺序与索引顺序是一致的）　非聚簇索引　　聚簇索引中的每个叶子节点包含主键值和余下的列</p>\n</li>\n<li><p>mysql gap锁</p>\n</li>\n</ul>\n<p>只有在rr隔离级别下才会使用gap锁，会把数据库中索引行划分为一个个左开右闭的区间（相邻行记录），根据where &lt; &gt;这种查询方式，使用gap锁</p>\n<p><a href=\"http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html\" target=\"_blank\" rel=\"noopener\">MySQL innodb中各种SQL语句加锁分析</a><br><a href=\"https://www.cnblogs.com/auxg/p/Cluster-and-NonCluster-index.html\" target=\"_blank\" rel=\"noopener\">和刚入门的菜鸟们聊聊–什么是聚簇索引与非聚簇索引</a><br><a href=\"https://blog.csdn.net/Abysscarry/article/details/80792876\" target=\"_blank\" rel=\"noopener\">多个单列索引和联合索引的区别详解</a></p>\n<ul>\n<li>Redis<br>Redis主从同步策略　主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。<a href=\"https://blog.csdn.net/rentuo53/article/details/84912941\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/rentuo53/article/details/84912941</a><br>Redis的哨兵机制　能监控多个master-slave集群，发现master宕机后能进行自动切换。不时地监控redis是否按照预期良好地运行;如果发现某个redis节点运行出现状况，能够通知另外一个进程；能够进行自动切换（进行主备切换）。当一个master节点不可用时，能够选举出master的多个slave中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。使用raft选举算法.<br>缓存穿透：缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。　　　解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br>缓存雪崩　缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。解决方案：缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>缓存击穿　对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。解决方案　使用互斥锁(mutex key)　业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。<br><a href=\"https://blog.csdn.net/a2133212132/article/details/80685313?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">Redis深度解析</a></li>\n<li>分布式系统一致性<br>XA协议　　第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交　　第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。　　优点： 尽量保证了数据的强一致，实现成本较低，缺点:　单点问题:事务管理器如果宕机，资源管理器就会一直阻塞，导致数据库无法使用。　同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。　数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li>\n<li>数据库优化</li>\n</ul>\n<p>查询优化：面对大规模数据量时，采取SELECT * FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 对分页查询进行优化，由于查询出id后，会遍历按照id 去外存区table数据　然后丢弃前面的，导致效率低下。<br><a href=\"http://www.nowamagic.net/librarys/veda/detail/1900\" target=\"_blank\" rel=\"noopener\">如何提高MySQL Limit查询的性能</a><br><a href=\"https://blog.csdn.net/u013628152/article/details/82184809\" target=\"_blank\" rel=\"noopener\">数据库优化方案整理</a></p>\n<p>参考链接：<br><a href=\"https://blog.csdn.net/qq_38238296/article/details/88362999#commentBox\" target=\"_blank\" rel=\"noopener\">MySQL的锁机制和加锁原理</a><br><a href=\"https://blog.csdn.net/mysteryhaohao/category_6270382.html\" target=\"_blank\" rel=\"noopener\">mysql学习</a><br><a href=\"https://thinkinjava.cn/2019/03/16/2019/2019-03-16-mysql/\" target=\"_blank\" rel=\"noopener\">MySql 三大知识点——索引、锁、事务</a><br><a href=\"https://blog.csdn.net/hcmony/article/details/80694560\" target=\"_blank\" rel=\"noopener\">为什么分布式一定要有redis，redis的一些优缺点q</a><br><a href=\"https://blog.csdn.net/qq360694660/article/details/88695365\" target=\"_blank\" rel=\"noopener\">数据库本地事务的实现原理</a><br><a href=\"https://blog.csdn.net/oracle_29/article/details/85717855\" target=\"_blank\" rel=\"noopener\">数据库 redo undo log</a><br><a href=\"https://www.cnblogs.com/CodeBear/p/10911177.html\" target=\"_blank\" rel=\"noopener\">大白话布隆过滤器</a><br><a href=\"https://www.cnblogs.com/CodeBear/p/12118050.html#4472208\" target=\"_blank\" rel=\"noopener\">谈谈数据库，缓存一致性</a><br><a href=\"https://www.cnblogs.com/xichji/p/11286443.html\" target=\"_blank\" rel=\"noopener\">REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案</a><br><a href=\"https://www.cnblogs.com/aspirant/p/9214485.html\" target=\"_blank\" rel=\"noopener\">一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)</a><br><a href=\"https://blog.csdn.net/yhl_jxy/article/details/91879874\" target=\"_blank\" rel=\"noopener\">Redis持久化(rdb、aof、混合)</a><br><a href=\"https://blog.csdn.net/qq_34337272/article/details/80012284\" target=\"_blank\" rel=\"noopener\">面试中关于Redis的问题看这篇就够了</a></p>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><ul>\n<li><p>tcp三次握手的本质：交换并确认双方的数据序号。</p>\n<pre><code>1.SYN-SENT --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt; --&gt; SYN-RECEIVED ​ \n2.ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt; &lt;-- SYN-RECEIVED ​ \n3.ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt; --&gt; ESTABLISHED\n四次挥手，每一端的关闭请求都需要被确认一次：2（client, server）*2(FIN, ACK)　服务器主动关闭链接的话会只有两次挥手　后续会回复客户端RST\n\nTIME_WAIT的产生条件：主动关闭方在发送四次挥手的最后一个ACK（第四次挥手后不会立刻关闭）会变为TIME_WAIT状态，保留次状态的时间为两个MSL（linux里一个MSL为30s，是不可配置的）\nTIME_WAIT两个MSL的作用：可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会对FIN开启TCP重传，发\n送多个FIN包，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其它服务产生影响。\nTIME_WAIT占用的资源：少量内存（查资料大概4K）和一个fd。\nTIME_WAIT关闭的危害：1、  网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被\n动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；2、  同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动\n方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。\nTIME_WAIT过多的解决办法： net.ipv4.tcp_tw_recycle=1  　表示开启TCP连接中TIME-WAIT sockets的快速回收</code></pre></li>\n<li><p>Reactor模式<br>  　一种比较流行的做法是服务端监听线程和 IO 线程分离，类似于 Reactor 的多线程模型。bossGrouＰ线程组实际就是 Acceptor 线程池，负责处理客户端的 TCP 连接请求，workerGroup 是真正负责 I/O 读写操作的线程组</p>\n</li>\n<li><p>TCP确保可靠性的机制　校验和　序列号　确认应答　超时重传　连接管理（三次握手　四次挥手）　<br>流量控制　在TCP协议的报头信息当中，有窗口大小，即接收端接收数据缓冲区的剩余大小。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。<br>拥塞控制　 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认<br>RST标志位表示强制断开链接<br>sack selective acknowledgment，也就是选择性确认，添加sack功能需要在TCP包头加两个选项，一个是开启选项（enabling optiocookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效,存放数据大小一般4K左右，而sessionStorage与localStorage大小在5兆左右，在客户端生成，localStorage除非被清除，否则会永久保存，sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除，cookie在与服务器端通信每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题,而sessionStorage与localStorage仅在客户端（即浏览器）中保存，不参与和服务器的通信。n），另一个是sack选项（sack option）本身。开启sack选项后，receiver会将自己收到了哪些包，没收到哪些包的信息记录在sack段中告诉给sender，这样sender便可以一次性重传所有的丢包。<br>MSS : Maximum Segment Size最大分段大小</p>\n</li>\n<li><p>状态码:<br>100（Continue）客户端应该继续它的请求。这个过渡的响应用于告知客户端，请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应。服务器必须在请求完成后发送一个最终的响应。<br>206状态码（Partial Content）服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<br>304 表明了客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题.<br>301 redirect: 301 代表永久性转移(Permanently Moved) 302 redirect: 302 代表暂时性转移(Temporarily Moved )</p>\n</li>\n<li><p>EPoll两种工作模式<br>  ET:当有事件发生时，系统只会通知你一次，即在调用epoll_wait返回fd后，不管这个事件你处理还是没处理，处理完没有处理完，当再次调用epoll_wait时，都不会再返回该fd　LT:使用LT模式意味着只要fd处于可读或者可写状态，每次epoll_wait都会返回该fd，这样的话会带来很大的系统开销，且处理时候每次都需要把这些fd轮询一遍，如果fd的数量巨大，不管有没有事件发生，epoll_wait都会触发这些fd的轮询判断。</p>\n</li>\n<li><p>TCP报文段是面向字节流的，UDP包是面向数据报的<br>  面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。在TCP建立连接前两次握手的SYN报文中选项字段的MSS值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口协议来控制通信双发的数据。<br>  tcp传输对准确性要求高速度相对可以慢，因此用于HTTP,FTP，邮件传输，远程连接；udp用于即时通讯延迟低，准确性低，网络电话，语音通信</p>\n</li>\n<li><p>netty的零拷贝<br>  将内存空间分段的字节数组在逻辑上整合为一个整体的字节数组（段式内存思想，将逻辑index变成分块编号和段内偏移）<br>参考链接：<br><a href=\"https://www.cnblogs.com/lvyahui/p/9030232.html\" target=\"_blank\" rel=\"noopener\">Reactor三种线程模型与Netty线程模型</a><br><a href=\"https://blog.csdn.net/zhang6223284/article/details/81414149\" target=\"_blank\" rel=\"noopener\">TCP 和 UDP 的区别</a><br><a href=\"https://blog.csdn.net/wdscq1234/article/details/52503315?locationNum=3\" target=\"_blank\" rel=\"noopener\">TCP-IP详解：SACK选项（Selective Acknowledgment）</a></p>\n<h3 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h3></li>\n<li><p>网络io发生时涉及的对象和步骤<br>  1）等待数据准备 (Waiting for the data to be ready)<br>  2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)<br><a href=\"https://blog.csdn.net/u011032846/article/details/81507216\" target=\"_blank\" rel=\"noopener\">web服务器和客户端完成并行处理请求三大方式</a><br><a href=\"https://www.cnblogs.com/cainingning/p/9556642.html\" target=\"_blank\" rel=\"noopener\">并发编程(IO多路复用)</a></p>\n<h3 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h3></li>\n<li><p>rpc<br><a href=\"https://www.jianshu.com/p/2accc2840a1b\" target=\"_blank\" rel=\"noopener\">如何给老婆解释什么是RPC</a><br><a href=\"https://www.jianshu.com/p/5b90a4e70783\" target=\"_blank\" rel=\"noopener\">如何实现一个简单的RPC</a></p>\n</li>\n<li><p>springCloud<br><a href=\"https://blog.csdn.net/jerryDzan/article/details/89137818\" target=\"_blank\" rel=\"noopener\">SpringCloud面试常见问题</a></p>\n<h3 id=\"场景问题\"><a href=\"#场景问题\" class=\"headerlink\" title=\"场景问题\"></a>场景问题</h3><p><a href=\"https://www.cnblogs.com/crazymakercircle/p/9833847.html\" target=\"_blank\" rel=\"noopener\">Reactor模式</a><br><a href=\"https://blog.csdn.net/qq_38601777/article/details/104092959\" target=\"_blank\" rel=\"noopener\">一个最简单的RPC实现及其原理</a><br><a href=\"https://www.jianshu.com/p/729f1f0f6e18\" target=\"_blank\" rel=\"noopener\">架构师手把手教你如何设计一个秒杀系统？</a><br><a href=\"https://blog.csdn.net/mulinsen77/article/details/89054063\" target=\"_blank\" rel=\"noopener\">如何设计一个秒杀系统</a><br><a href=\"https://kb.kutu66.com/algorithm/post_1011410\" target=\"_blank\" rel=\"noopener\">检查 1亿的手机号码以进行重复</a><br><a href=\"https://www.jianshu.com/p/b39eb55d4670\" target=\"_blank\" rel=\"noopener\">如何在有限的内存限制下实现数十亿级手机号码去重</a><br><a href=\"https://www.cnblogs.com/metoy/p/4470418.html\" target=\"_blank\" rel=\"noopener\">Java多线程读取大文件</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h3><ul>\n<li>多思考，挖掘项目难点，多总结<br>做完项目一定要总结，自己在项目中担任什么角色，解决了什么痛点，项目有哪些难点，怎么解决难点这些，<br>以及可以优化的地方，优化方案等，可以不一定实现，但是一定要知道怎么去解决。<br>但是如果没有想清楚难点、优化思路，再多的项目经验也白搭。</li>\n<li>引导式面试<br>面试肯定会遇到不会的地方，这个时候直接说不会，虽然不一定会直接挂，但是对整个面试肯定会有影响，<br>这个时候就可以把面试官引导到自己熟悉的相关技术上，一般绝大多数面试官会让继续讲，<br>建议可以各个方面知识都研究一个，研究深入点即可，例如缓存redis、消息队列kafka等。<br>去理解面试官想要问的东西，主动去说，不一定要等到面试官问透，而且很多面试官表述问题不清楚，<br>这时候一定要问清楚面试官想问的是不是你要回答的，答非所问也十分不可取。</li>\n<li>每次面试必总结<br>面试真的是学习技术最快的过程，很多时候自己学的，不一定学透了，经过面试官一顿灵魂拷问后发现自己什么都不会，<br>面试完总结这些知识，然后多面试几次后面就很容易了。</li>\n<li>自信<br>很多时候会被面试官问到怀疑人生，也可能会经历压力面，面试问的越难，反倒可能说明面试官对你很认可，<br>需要问些更深入的问题提高评级。<br>不论面试官问的问题是已经准备了很久的、烂熟于心还是从未接触过，都要自信，从容面对，也千万不要因为简单问题而放松，简单问题也可以回答的不一样，<br>例如java gc可以降到jdk11最新回收算法，这肯定比书上看到的cms g1有亮点的多，面试官也会觉得你热爱技术。</li>\n</ul>\n<h3 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h3><ul>\n<li><p>红黑树</p>\n</li>\n<li><p>B树和B+树</p>\n</li>\n<li><p>大文件排序<br><a href=\"https://blog.csdn.net/qq_29048719/article/details/81133643\" target=\"_blank\" rel=\"noopener\">对含有一亿数据的大文件进行排序，要求使用内存小于32MB</a><br>参考链接：<br><a href=\"https://blog.csdn.net/wyqwilliam/article/details/82935922\" target=\"_blank\" rel=\"noopener\">二叉树，平衡二叉树，红黑树，B-树、B+树、B*树的区别</a><br><a href=\"https://blog.csdn.net/u010899985/article/details/80981053#commentBox\" target=\"_blank\" rel=\"noopener\">红黑树和AVL树（平衡二叉树）区别</a><br><a href=\"https://www.cnblogs.com/aspirant/p/9214485.html\" target=\"_blank\" rel=\"noopener\">一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)</a></p>\n<h3 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h3><p><a href=\"https://tech.meituan.com/2018/11/15/java-lock.html\" target=\"_blank\" rel=\"noopener\">不可不说的Java“锁”事</a><br><a href=\"https://www.cnblogs.com/nanqiang/p/9934063.html\" target=\"_blank\" rel=\"noopener\">面向对象与面向过程的优缺点</a><br><a href=\"https://blog.csdn.net/qq_34375473/article/details/84852650\" target=\"_blank\" rel=\"noopener\">面向对象五大基本原则详解</a><br><a href=\"https://blog.csdn.net/h2604396739/article/details/83109292\" target=\"_blank\" rel=\"noopener\">反射原理</a><br><a href=\"https://blog.csdn.net/leonliu06/article/details/78685197\" target=\"_blank\" rel=\"noopener\">补码原理——负数为什么要用补码表示</a><br><a href=\"https://blog.csdn.net/sunxianghuang/article/details/52221913?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">跳表（SkipList）及ConcurrentSkipListMap源码解析</a></p></li></ul>","more":"<h3 id=\"linux命令\"><a href=\"#linux命令\" class=\"headerlink\" title=\"linux命令\"></a>linux命令</h3><p><a href=\"https://blog.csdn.net/qq_40910541/article/details/80686362\" target=\"_blank\" rel=\"noopener\">Linux常用命令（面试题）</a><br><a href=\"https://blog.csdn.net/jiangbr/article/details/82848492\" target=\"_blank\" rel=\"noopener\">最全Linux 面试常用命令</a></p>\n<h3 id=\"Jvm\"><a href=\"#Jvm\" class=\"headerlink\" title=\"Jvm\"></a>Jvm</h3></li>\n<li><p>分代回收算法:<a href=\"http://www.importnew.com/19255.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/19255.html</a><br>年轻代：复制回收算法 Scavenge GC（Eden-&gt;Survivor-&gt;Survivor）<br>老年代：年轻代n次回收后，扔存在的对象进入老年代。Full GC（老年、持久被写满或显示调用）用的是标记／清除法，老年代的垃圾回收会导致长时间的停顿<br>持久代：存放静态文件<br>收集器：串行：单线程效率高（适用于client模式下）；并行：多线程（最大垃圾回收暂停:吞吐量）；并发：应用不停止，响应要求高。浮动垃圾，需要保证内存空间<br>CMS收集器，目前web服务器开发最常用的收集器，并发收集（也就是垃圾回收线程和应用程序线程同时运行）。问豪神：（由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 再次标记阶段（remark））</p>\n</li>\n<li><p>在Java语言中，可以作为GC Roots的对象包括下面几种：</p>\n</li>\n</ul>\n<p>虚拟机栈（栈帧中的本地变量表）中的引用对象。<br>方法区中的类静态属性引用的对象。<br>方法区中的常量引用的对象。<br>本地方法栈中JNI（Native方法）的引用对象</p>\n<ul>\n<li><p>JVM垃圾收集器：<br>Serial 收集器：串行收集器，使用单线程进行收集，适用于client模式<br>ParNew收集器：Serial的多线程版本<br>CMS 收集器：<br>初始标记：只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿<br>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿<br>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿<br>并发清除：不需要停顿</p>\n</li>\n<li><p>对象创建过程：<br>检查常量池中是否有即将要创建的这个对象所属的类的符号引用；<br>进而检查这个符号引用所代表的类是否已经被JVM加载；若该类还没有被加载，就找该类的class文件，并加载进方法区；若该类已经被JVM加载，则准备为对象分配内存；<br>根据方法区中该类的信息确定该类所需的内存大小； 一个对象所需的内存大小是在这个对象所属类被定义完就能确定的！且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。<br>从堆中划分一块对应大小的内存空间给新的对象； 分配堆中内存有两种方式：指针碰撞 －－如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。　　空闲列表 －－如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。<br>为对象中的成员变量赋上初始值(默认初始化)；对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；<br>设置对象头中的信息；<br>调用对象的构造函数进行初始化</p>\n</li>\n<li><p>JVM内存模型：<br>【Java堆】用于存储Java对象，每个Java对象都是这个对象类的副本，会复制包含继承自它父类的所有非静态属性。<br>【方法区】用于存储类结构信息，class文件加载进JVM时会被解析成JVM识别的几个部分分别存储在不同的数据结构中：常量池、域、方法数据、方法体、构造函数，包括类中的方法、实例初始化、接口初始化等。<br>【Java栈】和线程关联，每个线程创建的时候，JVM都会为他分配一个对应的Java栈，这个栈含有多个栈帧；栈帧则是个方法关联，每个方法的运行都会创建一个自己的栈帧，含有内存变量，操作栈、方法返回值。<br>【PC寄存器】则用于记录下一条要执行的字节码指令地址和被中断。如果方法是 native的，程序计数器寄存器的值不会被定义为空。<br>【本地方法栈】是为JVM运行Native方法准备的空间，类似于Java栈。</p>\n</li>\n<li><p>双亲委派模型</p>\n</li>\n</ul>\n<p>启动类加载器  拓展类加载器  应用程序类加载器 自定义加载器<br>每个类加载器在收到类加载请求时，都不会自己先加载，而是将该请求委派给父类加载器去完成，若父类加载器可以完成该类的加载请求任务，<br>则成功返回，若父类加载器无法完成该类的加载请求任务，子类加载器才会尝试加载，这就是双亲委派模式。</p>\n<p>优点：采用双亲委派模式可使Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父加载器已经加载了该类时，就没有必要让子ClassLoader再加载一次。其次还可以防止子类加载器加载的类恶意覆盖Java核心API。例如，类java.lang.Object类存放在JDK\\jre\\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>\n<ul>\n<li>类加载</li>\n</ul>\n<p>启动类加载器：Bootstrap ClassLoader，它负责加载存放在JDK\\jre\\lib(JDK代表??JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.<em>开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。<br>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.</em>开头的类），开发者可以直接使用扩展类加载器。<br>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br>因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：1）在执行非置信代码之前，自动验证数字签名。2）动态地创建符合用户特定需要的定制化构建类。3）从特定的场所取得java class，例如数据库中和网络中。</p>\n<ul>\n<li>符号引用和直接引用</li>\n</ul>\n<p>在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类引用org.simple.Tool类，在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类 的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。<br>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。<br>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p>\n<p>参考链接：<br><a href=\"http://blog.sina.com.cn/s/blog_df25c55f0102wxh3.html\" target=\"_blank\" rel=\"noopener\">CMS 垃圾收集器 - 工作原理，浮动垃圾，三色标记法 </a><br><a href=\"https://blog.csdn.net/weixin_28760063/article/details/81271827\" target=\"_blank\" rel=\"noopener\">jvm如何判断对象是否可以回收或存活</a><br><a href=\"https://blog.csdn.net/a724888/article/details/77981592\" target=\"_blank\" rel=\"noopener\">深入理解JVM虚拟机2：JVM垃圾回收基本原理和算法</a><br><a href=\"https://blog.csdn.net/diaopai5230/article/details/101216653\" target=\"_blank\" rel=\"noopener\">CMS收集器和G1收集器 他们的优缺点对比 最后并发清除 CMS 不需要停顿，G1需要停顿…</a><br><a href=\"https://thinkinjava.cn/categories/JVM/\" target=\"_blank\" rel=\"noopener\">Jvm介绍</a><br><a href=\"https://blog.csdn.net/qq_36071795/article/details/83715456\" target=\"_blank\" rel=\"noopener\">自定义类加载器</a><br><a href=\"https://blog.csdn.net/qq_34402394/article/details/72793119#commentBox\" target=\"_blank\" rel=\"noopener\">java虚拟机的符号引用和直接引用</a><br><a href=\"https://blog.csdn.net/seujava_er/article/details/90114716\" target=\"_blank\" rel=\"noopener\">JVM关于OOM异常的调优</a><br><a href=\"https://blog.csdn.net/qq_38182963/article/details/78660779\" target=\"_blank\" rel=\"noopener\">深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型</a><br><a href=\"https://www.jianshu.com/p/76959115d486\" target=\"_blank\" rel=\"noopener\">深入理解JVM-内存模型（jmm）和GC</a><br><a href=\"https://blog.csdn.net/qq_20499001/article/details/89288497\" target=\"_blank\" rel=\"noopener\">阿里面试100%问到，JVM性能调优篇</a><br><a href=\"https://blog.csdn.net/lengxiao1993/article/details/86689331#comments\" target=\"_blank\" rel=\"noopener\">面试题之窒息翻译：类加载机制的双亲委派（正解：父委派模型）</a><br><a href=\"https://blog.csdn.net/dd864140130/article/details/49515403\" target=\"_blank\" rel=\"noopener\">深入JVM字节码执行引擎</a></p>\n<h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3><p>1.悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。<br>2.乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。<br>3.线程池：新建线程 -&gt; 达到核心数 -&gt; 加入队列 -&gt; 新建线程（非核心） -&gt; 达到最大数 -&gt; 触发拒绝策略。　线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务。线程数量达到了corePools，则将任务移入队列。等待队列已满，新建线程(非核心线程)执行任务。队列已满，总线程数又达到了maximumPoolSize，就会由(RejectedExecutionHandler)抛出异常<br>4.为什么使用线程池：单个任务处理时间比较短，需要处理的任务数量很大。降低资源消耗　提高线程的可管理性　<br>5.newCachedThreadPool 工作线程的创建数量几乎没有限制 newFixedThreadPool　　　 newScheduledThreadPool支持定时及周期性任务执行　　newSingleThreadExecutor单线程化的线程池，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行　　　<br>6.线程池中的线程在新建后进入while循环，从task队列获取任务，当没有待执行任务时，若线程数量小于等于核心线程数量，若核心线程不可退出则调用队列的take阻塞直到新任务到来，若可以退出，则调用poll，时间超时后线程结束。<br>7.CountDownLatch 利用它可以实现一个任务等待其他一个或一组任务执行后再触发的功能，不可重用。CyclicBarrier　让一组线程等待至某个状态之后再全部同时执行，可重用。<br>8.分布式系统CAP定理：Consistency（一致性），Availability（可用性），Partition tolerance（分区容错）　web场景一般可用性高于一致性　所以退而求其次追求最终一致性(eventual consistency)　　分区容错在分布式系统中不可避免<br>9.自旋锁与互斥锁：自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，所以自旋锁的效率远 高于互斥锁。虽然它的效率比互斥锁高，但是它一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。不适用与IO场景，单核CPU，代码长时间执行。自旋锁的实现：使用java的cas原子操作AtomicReference，循环将原子变量从null设置为当前线程，若当前原子变量不为null则一直循环。<br>10.死锁的原因与预防：１互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程　２占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源　３不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。　４循环等待：存在一个进程环，使得每个进程都占有下一个进程所需的至少一种资源。<br>       预防的主要做法是破坏除互斥之外的三个条件<br>11.线程与进程的区别：<br>       一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。<br>       资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。<br>       引入线程的操作系统中，把线程作为调度和分派的基本单位。而把进程作为资源拥有的基本单位<br>       系统开销　由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。<br>12.进程的几种状态: 1) 运行状态：进程正在处理器上上运行。在单处理器环境下，每个时刻最多只有一个进程处于运行状态。2) 就绪状态：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器即可运行。3) 阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入/输出完成。即使处理器空闲，该进程也不能运行。4) 创建状态：进程正在被创建，尚未到就绪状态。5) 结束状态：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。<br>13.程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码。初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据。未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据。栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。堆 (Heap):存储动态内存分配,需要程序员手工分配,手工释放.<br>14.使用线程池的好处：减少创建和销毁线程导致的时间开销和内存资源开销，如果不使用线程池可能导致系统创建大量同类线程导致资源耗尽或者频繁切换<br>15.UUID含义是通用唯一识别码 (Universally Unique Identifier) UUID由以下几部分的组合：<br>       1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同<br>       2）时钟序列。？？？问五七<br>       3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得<br>16.线程的几种创建方式：以继承Thread类的方式创建线程，　以实现Runnable接口的方式创建线程，　以Callable+FutureTask的方式创建线程<br>17.公平锁与非公平锁的区别<br>       非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。<br>       非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。<br>       公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。<br>18.分布式事务：<br>       TCC:Try、Confirm、Cancel　Try 阶段：对各个服务的资源做检测以及对资源进行锁定。Confirm 阶段：在各个服务中执行实际的操作。Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。<br>       <a href=\"https://www.cnblogs.com/jajian/p/10014145.html\" target=\"_blank\" rel=\"noopener\">tcc事务原理</a><br>参考链接：<br><a href=\"https://blog.csdn.net/lovezhaohaimig/article/details/80344299\" target=\"_blank\" rel=\"noopener\">Java并发编程之异步Future机制的原理和实现</a><br><a href=\"https://javadoop.com/post/java-thread-pool\" target=\"_blank\" rel=\"noopener\">深度解读 java 线程池设计思想及源码实现</a><br><a href=\"https://www.jianshu.com/p/abfa29c01e1d\" target=\"_blank\" rel=\"noopener\">CompletableFuture原理解析</a><br><a href=\"https://www.cnblogs.com/wangsen/p/11170709.html\" target=\"_blank\" rel=\"noopener\">CountDownLatch和CylicBarrier以及Semaphare你使用过吗</a><br><a href=\"https://blog.csdn.net/w372426096/article/details/80437198\" target=\"_blank\" rel=\"noopener\">[分布式]：分布式系统的CAP理论</a><br><a href=\"https://www.jianshu.com/p/58911d2e8b28\" target=\"_blank\" rel=\"noopener\">分布式事务之TCC</a><br><a href=\"https://coderbee.net/index.php/concurrent/20131115/577\" target=\"_blank\" rel=\"noopener\">自旋锁、排队自旋锁、MCS锁、CLH锁</a></p>\n<h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><ul>\n<li>动态代理</li>\n</ul>\n<p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.<br>jdk动态代理</p>\n<ul>\n<li><p>IOC</p>\n<p>  1.IOC: 容器ApplicationContext虽然继承自BeanFactory的接口，但其内部持有一个BeanFactory实例，用于创建和管理Bean，项目启动后调用其refresh方法进行初始化，生成所有单例模式的Bean。BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。首先会根据配置加载BeanDefinition，然后将所以的BeanDefinition存入容器的一个Map中，完成后BeanFactory的初始化完成。随后开始Bean的初始化流程，通过getBean进行加载，已经加载过的会直接返回，加载过程中遇到依赖的Bean会进行递归加载，调用无参构造函数或者构造函数依赖注入进行实例创建，然后对Bean依赖的property进行注入<br>  2.Spring循换依赖问题：通过三级缓存和提前曝光机制解决。比如Ａ字段中依赖Ｂ，Ｂ字段中依赖Ａ。当Ａ在实例化后（对象初始化的第一步）便曝光到第三级缓存中，属性赋值Ｂ时发现没有B，便初始化Ｂ，在属性赋值Ａ时便可以在第三级缓存中找到Ａ的引用赋值，完成Ｂ的初始化，保存到第一级缓存；之后返回给Ａ完成初始化。</p>\n</li>\n</ul>\n<p>参考链接：<br><a href=\"https://javadoop.com/post/spring-ioc\" target=\"_blank\" rel=\"noopener\">Spring IOC 容器源码分析</a><br><a href=\"https://blog.csdn.net/quliuwuyiz/article/details/79416184\" target=\"_blank\" rel=\"noopener\">Spring如何解决循环依赖</a></p>\n<p>-　AOP</p>\n<p>AOP:　ProxyFatoryBean用于创建代理对象，先初始化Advisor链，然后进行代理类的生成。当代理类执行方法时，会调用invoke方法，invoke方法中对aop拦截器进行检测，如果存在拦截器，则生成MethodInvocation进行拦截链的链式调用。不断得调用procced方法，每次进去后计数器自增，取出下一个拦截其，检查advise与当前的调用是否match,匹配的话将执行该advise    </p>\n<p>参考链接：<br><a href=\"https://javadoop.com/post/spring-aop-source\" target=\"_blank\" rel=\"noopener\">Spring AOP 源码解析</a><br><a href=\"https://www.cnblogs.com/CodeBear/p/10867707.html#4462519\" target=\"_blank\" rel=\"noopener\">剑指Spring源码（三）俯瞰Spring的Bean的生命周期（大众版）</a></p>\n<h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3><ul>\n<li>Ribbon<br>　负责均衡客户端基于RestTemplate实现，通过拦截器机制实现负载均衡，在拦截器中拿到请求url中的serviceId，传入LoadBalanceClient进行服务实例的获取,获取时通过ILoadBalance负载均衡器获取服务，服务实例对象封装了ip等信息。利用服务实例初始化serviceRequestWarpper，重写getUri函数将服务id转换为ip，继续进行后续拦截链的链式调用。</li>\n</ul>\n<p>参考链接：<br><a href=\"https://blog.csdn.net/hanhanbubble/article/details/90752591\" target=\"_blank\" rel=\"noopener\">关于RestTemplate 非常推荐的几篇博文（原理剖析）</a><br><a href=\"https://www.cnblogs.com/jajian/p/9973555.html\" target=\"_blank\" rel=\"noopener\">spring cloud底层原理</a></p>\n<h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><ul>\n<li>代理模式</li>\n</ul>\n<p>静态代理：由程序员或特定工具创建代理类，在程序运行前代理类的.class文件已经存在<br>动态代理：在程序运行时通过反射机制动态创建而成</p>\n<p>静态代理类优缺点</p>\n<p>优点：</p>\n<p>代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合），对于如上的客户端代码，newUserManagerImpl()可以应用工厂将它隐藏，如上只是举个例子而已。</p>\n<p>缺点：</p>\n<p>1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p>\n<p>2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。</p>\n<p>参考链接：<br><a href=\"https://www.cnblogs.com/zuoxiaolong/p/pattern3.html\" target=\"_blank\" rel=\"noopener\">代理模式</a><br><a href=\"https://blog.csdn.net/hejingyuan6/article/details/36203505\" target=\"_blank\" rel=\"noopener\">JAVA学习篇–静态代理VS动态代理</a><br><a href=\"https://www.jianshu.com/p/8afd396e314f\" target=\"_blank\" rel=\"noopener\">项目中用到的设计模式</a></p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><ul>\n<li>引擎对比<br>MyISAM拥有较高的插入、查询速度，但不支持事务。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复<br>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。辅助索引data域存储相应记录主键的值而不是地址。InnoDB还支持外键（FOREIGN KEY）</li>\n</ul>\n<p><a href=\"\">MySQL存储引擎MyISAM与InnoDB区别总结整理</a></p>\n<ul>\n<li>事务</li>\n</ul>\n<p>数据库事务的实现原理：<br>事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁），这时该事物的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中），这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。<br>原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。</p>\n<p>脏读：是指一个事务中访问到了另外一个事务未提交的数据。不可重复读是指在一个事务内根据同一个条件对行记录进行多次查询，但是搜出来的结果却不一致。幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。不同在于不可重复读是同一个记录的数据内容被修改了，幻读是数据行记录变多了或者少了<br>事务隔离：read uncommitted（读取未提交数据：导致脏读）　read committed（可以读取其他事务提交的数据：导致不可重复读）—大多数数据库默认的隔离级别；repeatable read（可重读：导致幻读）—MySQL默认的隔离级别；serializable（串行化：有事务读的时候其他写会被挂起）</p>\n<p>事务特性：原子性　　一致性　数据库总数从一个一致性的状态转换到另一个一致性的状态。　　隔离性　一个事务所做的修改在最终提交以前，对其他事务是不可见的。　持久性　一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>\n<ul>\n<li><p>索引<br>数据库索引分类：从数据结构角度　B+树索引　hash索引　FULLTEXT索引（InnoDB引擎5.7以后支持）R-Tree索引　　从物理存储角度　　聚簇索引（一般对主键建立，物理存放顺序与索引顺序是一致的）　非聚簇索引　　聚簇索引中的每个叶子节点包含主键值和余下的列</p>\n</li>\n<li><p>mysql gap锁</p>\n</li>\n</ul>\n<p>只有在rr隔离级别下才会使用gap锁，会把数据库中索引行划分为一个个左开右闭的区间（相邻行记录），根据where &lt; &gt;这种查询方式，使用gap锁</p>\n<p><a href=\"http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html\" target=\"_blank\" rel=\"noopener\">MySQL innodb中各种SQL语句加锁分析</a><br><a href=\"https://www.cnblogs.com/auxg/p/Cluster-and-NonCluster-index.html\" target=\"_blank\" rel=\"noopener\">和刚入门的菜鸟们聊聊–什么是聚簇索引与非聚簇索引</a><br><a href=\"https://blog.csdn.net/Abysscarry/article/details/80792876\" target=\"_blank\" rel=\"noopener\">多个单列索引和联合索引的区别详解</a></p>\n<ul>\n<li>Redis<br>Redis主从同步策略　主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。<a href=\"https://blog.csdn.net/rentuo53/article/details/84912941\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/rentuo53/article/details/84912941</a><br>Redis的哨兵机制　能监控多个master-slave集群，发现master宕机后能进行自动切换。不时地监控redis是否按照预期良好地运行;如果发现某个redis节点运行出现状况，能够通知另外一个进程；能够进行自动切换（进行主备切换）。当一个master节点不可用时，能够选举出master的多个slave中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。使用raft选举算法.<br>缓存穿透：缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。　　　解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br>缓存雪崩　缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。解决方案：缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>缓存击穿　对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。解决方案　使用互斥锁(mutex key)　业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。<br><a href=\"https://blog.csdn.net/a2133212132/article/details/80685313?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">Redis深度解析</a></li>\n<li>分布式系统一致性<br>XA协议　　第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交　　第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。　　优点： 尽量保证了数据的强一致，实现成本较低，缺点:　单点问题:事务管理器如果宕机，资源管理器就会一直阻塞，导致数据库无法使用。　同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。　数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li>\n<li>数据库优化</li>\n</ul>\n<p>查询优化：面对大规模数据量时，采取SELECT * FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 对分页查询进行优化，由于查询出id后，会遍历按照id 去外存区table数据　然后丢弃前面的，导致效率低下。<br><a href=\"http://www.nowamagic.net/librarys/veda/detail/1900\" target=\"_blank\" rel=\"noopener\">如何提高MySQL Limit查询的性能</a><br><a href=\"https://blog.csdn.net/u013628152/article/details/82184809\" target=\"_blank\" rel=\"noopener\">数据库优化方案整理</a></p>\n<p>参考链接：<br><a href=\"https://blog.csdn.net/qq_38238296/article/details/88362999#commentBox\" target=\"_blank\" rel=\"noopener\">MySQL的锁机制和加锁原理</a><br><a href=\"https://blog.csdn.net/mysteryhaohao/category_6270382.html\" target=\"_blank\" rel=\"noopener\">mysql学习</a><br><a href=\"https://thinkinjava.cn/2019/03/16/2019/2019-03-16-mysql/\" target=\"_blank\" rel=\"noopener\">MySql 三大知识点——索引、锁、事务</a><br><a href=\"https://blog.csdn.net/hcmony/article/details/80694560\" target=\"_blank\" rel=\"noopener\">为什么分布式一定要有redis，redis的一些优缺点q</a><br><a href=\"https://blog.csdn.net/qq360694660/article/details/88695365\" target=\"_blank\" rel=\"noopener\">数据库本地事务的实现原理</a><br><a href=\"https://blog.csdn.net/oracle_29/article/details/85717855\" target=\"_blank\" rel=\"noopener\">数据库 redo undo log</a><br><a href=\"https://www.cnblogs.com/CodeBear/p/10911177.html\" target=\"_blank\" rel=\"noopener\">大白话布隆过滤器</a><br><a href=\"https://www.cnblogs.com/CodeBear/p/12118050.html#4472208\" target=\"_blank\" rel=\"noopener\">谈谈数据库，缓存一致性</a><br><a href=\"https://www.cnblogs.com/xichji/p/11286443.html\" target=\"_blank\" rel=\"noopener\">REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案</a><br><a href=\"https://www.cnblogs.com/aspirant/p/9214485.html\" target=\"_blank\" rel=\"noopener\">一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)</a><br><a href=\"https://blog.csdn.net/yhl_jxy/article/details/91879874\" target=\"_blank\" rel=\"noopener\">Redis持久化(rdb、aof、混合)</a><br><a href=\"https://blog.csdn.net/qq_34337272/article/details/80012284\" target=\"_blank\" rel=\"noopener\">面试中关于Redis的问题看这篇就够了</a></p>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><ul>\n<li><p>tcp三次握手的本质：交换并确认双方的数据序号。</p>\n<pre><code>1.SYN-SENT --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt; --&gt; SYN-RECEIVED ​ \n2.ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt; &lt;-- SYN-RECEIVED ​ \n3.ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt; --&gt; ESTABLISHED\n四次挥手，每一端的关闭请求都需要被确认一次：2（client, server）*2(FIN, ACK)　服务器主动关闭链接的话会只有两次挥手　后续会回复客户端RST\n\nTIME_WAIT的产生条件：主动关闭方在发送四次挥手的最后一个ACK（第四次挥手后不会立刻关闭）会变为TIME_WAIT状态，保留次状态的时间为两个MSL（linux里一个MSL为30s，是不可配置的）\nTIME_WAIT两个MSL的作用：可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会对FIN开启TCP重传，发\n送多个FIN包，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其它服务产生影响。\nTIME_WAIT占用的资源：少量内存（查资料大概4K）和一个fd。\nTIME_WAIT关闭的危害：1、  网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被\n动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；2、  同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动\n方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。\nTIME_WAIT过多的解决办法： net.ipv4.tcp_tw_recycle=1  　表示开启TCP连接中TIME-WAIT sockets的快速回收</code></pre></li>\n<li><p>Reactor模式<br>  　一种比较流行的做法是服务端监听线程和 IO 线程分离，类似于 Reactor 的多线程模型。bossGrouＰ线程组实际就是 Acceptor 线程池，负责处理客户端的 TCP 连接请求，workerGroup 是真正负责 I/O 读写操作的线程组</p>\n</li>\n<li><p>TCP确保可靠性的机制　校验和　序列号　确认应答　超时重传　连接管理（三次握手　四次挥手）　<br>流量控制　在TCP协议的报头信息当中，有窗口大小，即接收端接收数据缓冲区的剩余大小。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。<br>拥塞控制　 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认<br>RST标志位表示强制断开链接<br>sack selective acknowledgment，也就是选择性确认，添加sack功能需要在TCP包头加两个选项，一个是开启选项（enabling optiocookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效,存放数据大小一般4K左右，而sessionStorage与localStorage大小在5兆左右，在客户端生成，localStorage除非被清除，否则会永久保存，sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除，cookie在与服务器端通信每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题,而sessionStorage与localStorage仅在客户端（即浏览器）中保存，不参与和服务器的通信。n），另一个是sack选项（sack option）本身。开启sack选项后，receiver会将自己收到了哪些包，没收到哪些包的信息记录在sack段中告诉给sender，这样sender便可以一次性重传所有的丢包。<br>MSS : Maximum Segment Size最大分段大小</p>\n</li>\n<li><p>状态码:<br>100（Continue）客户端应该继续它的请求。这个过渡的响应用于告知客户端，请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应。服务器必须在请求完成后发送一个最终的响应。<br>206状态码（Partial Content）服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<br>304 表明了客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题.<br>301 redirect: 301 代表永久性转移(Permanently Moved) 302 redirect: 302 代表暂时性转移(Temporarily Moved )</p>\n</li>\n<li><p>EPoll两种工作模式<br>  ET:当有事件发生时，系统只会通知你一次，即在调用epoll_wait返回fd后，不管这个事件你处理还是没处理，处理完没有处理完，当再次调用epoll_wait时，都不会再返回该fd　LT:使用LT模式意味着只要fd处于可读或者可写状态，每次epoll_wait都会返回该fd，这样的话会带来很大的系统开销，且处理时候每次都需要把这些fd轮询一遍，如果fd的数量巨大，不管有没有事件发生，epoll_wait都会触发这些fd的轮询判断。</p>\n</li>\n<li><p>TCP报文段是面向字节流的，UDP包是面向数据报的<br>  面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。在TCP建立连接前两次握手的SYN报文中选项字段的MSS值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口协议来控制通信双发的数据。<br>  tcp传输对准确性要求高速度相对可以慢，因此用于HTTP,FTP，邮件传输，远程连接；udp用于即时通讯延迟低，准确性低，网络电话，语音通信</p>\n</li>\n<li><p>netty的零拷贝<br>  将内存空间分段的字节数组在逻辑上整合为一个整体的字节数组（段式内存思想，将逻辑index变成分块编号和段内偏移）<br>参考链接：<br><a href=\"https://www.cnblogs.com/lvyahui/p/9030232.html\" target=\"_blank\" rel=\"noopener\">Reactor三种线程模型与Netty线程模型</a><br><a href=\"https://blog.csdn.net/zhang6223284/article/details/81414149\" target=\"_blank\" rel=\"noopener\">TCP 和 UDP 的区别</a><br><a href=\"https://blog.csdn.net/wdscq1234/article/details/52503315?locationNum=3\" target=\"_blank\" rel=\"noopener\">TCP-IP详解：SACK选项（Selective Acknowledgment）</a></p>\n<h3 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h3></li>\n<li><p>网络io发生时涉及的对象和步骤<br>  1）等待数据准备 (Waiting for the data to be ready)<br>  2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)<br><a href=\"https://blog.csdn.net/u011032846/article/details/81507216\" target=\"_blank\" rel=\"noopener\">web服务器和客户端完成并行处理请求三大方式</a><br><a href=\"https://www.cnblogs.com/cainingning/p/9556642.html\" target=\"_blank\" rel=\"noopener\">并发编程(IO多路复用)</a></p>\n<h3 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h3></li>\n<li><p>rpc<br><a href=\"https://www.jianshu.com/p/2accc2840a1b\" target=\"_blank\" rel=\"noopener\">如何给老婆解释什么是RPC</a><br><a href=\"https://www.jianshu.com/p/5b90a4e70783\" target=\"_blank\" rel=\"noopener\">如何实现一个简单的RPC</a></p>\n</li>\n<li><p>springCloud<br><a href=\"https://blog.csdn.net/jerryDzan/article/details/89137818\" target=\"_blank\" rel=\"noopener\">SpringCloud面试常见问题</a></p>\n<h3 id=\"场景问题\"><a href=\"#场景问题\" class=\"headerlink\" title=\"场景问题\"></a>场景问题</h3><p><a href=\"https://www.cnblogs.com/crazymakercircle/p/9833847.html\" target=\"_blank\" rel=\"noopener\">Reactor模式</a><br><a href=\"https://blog.csdn.net/qq_38601777/article/details/104092959\" target=\"_blank\" rel=\"noopener\">一个最简单的RPC实现及其原理</a><br><a href=\"https://www.jianshu.com/p/729f1f0f6e18\" target=\"_blank\" rel=\"noopener\">架构师手把手教你如何设计一个秒杀系统？</a><br><a href=\"https://blog.csdn.net/mulinsen77/article/details/89054063\" target=\"_blank\" rel=\"noopener\">如何设计一个秒杀系统</a><br><a href=\"https://kb.kutu66.com/algorithm/post_1011410\" target=\"_blank\" rel=\"noopener\">检查 1亿的手机号码以进行重复</a><br><a href=\"https://www.jianshu.com/p/b39eb55d4670\" target=\"_blank\" rel=\"noopener\">如何在有限的内存限制下实现数十亿级手机号码去重</a><br><a href=\"https://www.cnblogs.com/metoy/p/4470418.html\" target=\"_blank\" rel=\"noopener\">Java多线程读取大文件</a></p>\n</li>\n</ul>"},{"title":"数据库行级锁","date":"2020-01-06T12:28:31.000Z","_content":"\n\n今天写支付接口时，在客户端调用支付完成后，微信会调用微信支付通知接口\n，而且存在多次调用问题，此时需要是使用数据锁，解决并发访问问题。\n\n<!--more-->\n- redis锁\n\n首先考虑使用redis锁，将订单主键作为redis键值，使用redis setx方法，\n将锁粒度控制在单一订单上，也比较合适，但是使用的话需要引入redis、不算简单。\n好处是以后方便拓展\n\n- 数据库行级锁\n\n> 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。\n> 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n> 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般\n\n考虑直接使用数据库行级锁，使用起来比较简单，配合事务，一行sql就搞定了\n\n测试了一下，在查询的时候 相应字段普通索引不会是用行级锁，使用的还是表锁。\n于是将订单的流水号字段建立唯一索引，使用for update查询测试为是行级锁。\n\nspring具体使用方法为：业务方法上添加@Tranactional注解，可手写sql或者使用jpa @LOCK注解即可。\n","source":"_posts/数据库行级锁.md","raw":"---\ntitle: 数据库行级锁\ndate: 2020-01-06 20:28:31\ncategories: 数据库\ntags: mysql\n---\n\n\n今天写支付接口时，在客户端调用支付完成后，微信会调用微信支付通知接口\n，而且存在多次调用问题，此时需要是使用数据锁，解决并发访问问题。\n\n<!--more-->\n- redis锁\n\n首先考虑使用redis锁，将订单主键作为redis键值，使用redis setx方法，\n将锁粒度控制在单一订单上，也比较合适，但是使用的话需要引入redis、不算简单。\n好处是以后方便拓展\n\n- 数据库行级锁\n\n> 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。\n> 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n> 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般\n\n考虑直接使用数据库行级锁，使用起来比较简单，配合事务，一行sql就搞定了\n\n测试了一下，在查询的时候 相应字段普通索引不会是用行级锁，使用的还是表锁。\n于是将订单的流水号字段建立唯一索引，使用for update查询测试为是行级锁。\n\nspring具体使用方法为：业务方法上添加@Tranactional注解，可手写sql或者使用jpa @LOCK注解即可。\n","slug":"数据库行级锁","published":1,"updated":"2020-01-06T13:10:40.899Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz8100279oeteukha9uz","content":"<p>今天写支付接口时，在客户端调用支付完成后，微信会调用微信支付通知接口<br>，而且存在多次调用问题，此时需要是使用数据锁，解决并发访问问题。</p>\n<a id=\"more\"></a>\n<ul>\n<li>redis锁</li>\n</ul>\n<p>首先考虑使用redis锁，将订单主键作为redis键值，使用redis setx方法，<br>将锁粒度控制在单一订单上，也比较合适，但是使用的话需要引入redis、不算简单。<br>好处是以后方便拓展</p>\n<ul>\n<li>数据库行级锁</li>\n</ul>\n<blockquote>\n<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>\n</blockquote>\n<p>考虑直接使用数据库行级锁，使用起来比较简单，配合事务，一行sql就搞定了</p>\n<p>测试了一下，在查询的时候 相应字段普通索引不会是用行级锁，使用的还是表锁。<br>于是将订单的流水号字段建立唯一索引，使用for update查询测试为是行级锁。</p>\n<p>spring具体使用方法为：业务方法上添加@Tranactional注解，可手写sql或者使用jpa @LOCK注解即可。</p>\n","site":{"data":{}},"excerpt":"<p>今天写支付接口时，在客户端调用支付完成后，微信会调用微信支付通知接口<br>，而且存在多次调用问题，此时需要是使用数据锁，解决并发访问问题。</p>","more":"<ul>\n<li>redis锁</li>\n</ul>\n<p>首先考虑使用redis锁，将订单主键作为redis键值，使用redis setx方法，<br>将锁粒度控制在单一订单上，也比较合适，但是使用的话需要引入redis、不算简单。<br>好处是以后方便拓展</p>\n<ul>\n<li>数据库行级锁</li>\n</ul>\n<blockquote>\n<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>\n</blockquote>\n<p>考虑直接使用数据库行级锁，使用起来比较简单，配合事务，一行sql就搞定了</p>\n<p>测试了一下，在查询的时候 相应字段普通索引不会是用行级锁，使用的还是表锁。<br>于是将订单的流水号字段建立唯一索引，使用for update查询测试为是行级锁。</p>\n<p>spring具体使用方法为：业务方法上添加@Tranactional注解，可手写sql或者使用jpa @LOCK注解即可。</p>"},{"title":"阿里巴巴用户增长部提前批面经","date":"2020-02-24T14:50:47.000Z","_content":"\n- 用户增长部\n２月２０号做了笔试，三道题目<!--more-->\n    1、单向链表“双节”点逆转 ，比如：1->2 ->3 ->4 ->5    逆转后  4->5->2->3->1\n    ```java\n  public class solution{\n  \n    public class Node{\n     int value;\n      Node next;\n}\n    \n    public Node solution(node root){\n      if(root == null || root.next == null){\n        return root\n      }\nNode  index = root.next;\n      root.next = null;\n      Node last;\n      while(index != null && index.next != null) {\n        Node tem = index.next.next\n          index.next.next =root;\n        root = index;\n        index = tem;\n\n    }\nif(index != null){\n  index.next = root;\n  root = index;\n}\n      return root;\n  }\n  \n```\n<!--more-->\n    2、给定一棵二叉树，每个节点只包含数字0-9，从根节点到叶子节点的每条路径可以表示成一个数，请这些数的和。例如从根节点到叶子节点分别为1->2->3，那么这条路径代表数字123。求所有路径代表的数字的和\n    ```java\n      public class Solution{\n          public class Node{\n         int value;\n          Node left;\n            Node right;\n    }\n        \n        ArrayList<Integer> res = new ArrayList<>();\n        public Integer solution(Node node){\n        if(node == null){\n          return 0;\n        }\n          trace(node,0);\n          int sum = 0;\n          for(Integer value: res){\n          sum+=value;\n          }\n          return sum;\n        }\n        private void trace(Node node , int value){\n        if(node == null){\n          res.add(value);\n        }else{\n               int sum = value*10+node.value;\n          trace(node.left,sum);\n          trace(node.right,sum);\n        }\n      }\n      }\n```\n    3、微信群聊中,每个人都有未读消息和　已读消息,如何设计提供每个人显示多少未读消息且能快速找到具体的未读消息(假设是一周时间段,如果是群人数有限和群人数无限)? 请使用 最少的存储空间和最快速的查找算法 来解决\n    answer:  －　wechat类模拟群，wechat的ａｄｄ方法在将增加ｕｓｅｒｓ的messageNum数量（即未读消息数量）并且在数据表中写入消息（消息仅写入一次）、用户消息关联、用户未读消息数量，用户关联表ｓｔａｔｅ初始消息为未读；\n             －　根据这个可以将用户的所有未读消息查询出来，每个消息有时间戳字段（默认时间戳排序），根据时间二分法就可以查询；若根据内容查询，ｍｅｓｓａｇｅ有根据内容生成的ｈａｓｈ字段，可依此存入容器查询，或者使用快速查找均可；\n             \n             \n             public class Wechat{\n             \n              private List<User> users;\n               \n               \n               public void add(){\n               增加用户未读信息数量;\n               }\n             }\n             \n             public class User{\n              private Long userId;\n               private Integer messageNum;\n             }\n               \n               /**\n               可一条消息对应多个用户\n               BUseMessage为用户与消息关联表\n               */\n               public class  BUseMessage{\n               \n                 private Long UserId;\n                 private Long messageId;\n                 //是否已读\n                 private Integer state;\n               }\n               \n               public class Message{\n               private Long messageId;\n               private String content;\n                 private Long timeStamp;\n                 private Integar state;\n                 //　根据content生成ｈａｓｈ值\n                 private Long hash;\n                 public Long hashcod(){\n                 return hash;\n                 }\n               }\n- 商家成长部   \n２月２２号收到商家增长部提前批面试\n    - 个人介绍\n    - 喜欢干啥\n    - 阅读过哪些中间件源码，擅长的技术\n    - 获奖\n    - tcp udp区别\n    - 一个消息包从北京发送的广州的流程\n    - 说说arp协议\n    - 说说面向对象的几个原则\n    - 面向对象的优点\n    - 计算机内负数怎么表示，为什么\n    - 三次握手的过程 二次握手的问题\n    - 说说滑动窗口协议\n    - hashmap的get过程\n    - synchronized用法，方法添加static的区别\n    - 说说cap    ","source":"_posts/用户增长部提前批面经.md","raw":"---\ntitle: 阿里巴巴用户增长部提前批面经\ndate: 2020-02-24 22:50:47\ncategories: note\ntags: alibaba\n---\n\n- 用户增长部\n２月２０号做了笔试，三道题目<!--more-->\n    1、单向链表“双节”点逆转 ，比如：1->2 ->3 ->4 ->5    逆转后  4->5->2->3->1\n    ```java\n  public class solution{\n  \n    public class Node{\n     int value;\n      Node next;\n}\n    \n    public Node solution(node root){\n      if(root == null || root.next == null){\n        return root\n      }\nNode  index = root.next;\n      root.next = null;\n      Node last;\n      while(index != null && index.next != null) {\n        Node tem = index.next.next\n          index.next.next =root;\n        root = index;\n        index = tem;\n\n    }\nif(index != null){\n  index.next = root;\n  root = index;\n}\n      return root;\n  }\n  \n```\n<!--more-->\n    2、给定一棵二叉树，每个节点只包含数字0-9，从根节点到叶子节点的每条路径可以表示成一个数，请这些数的和。例如从根节点到叶子节点分别为1->2->3，那么这条路径代表数字123。求所有路径代表的数字的和\n    ```java\n      public class Solution{\n          public class Node{\n         int value;\n          Node left;\n            Node right;\n    }\n        \n        ArrayList<Integer> res = new ArrayList<>();\n        public Integer solution(Node node){\n        if(node == null){\n          return 0;\n        }\n          trace(node,0);\n          int sum = 0;\n          for(Integer value: res){\n          sum+=value;\n          }\n          return sum;\n        }\n        private void trace(Node node , int value){\n        if(node == null){\n          res.add(value);\n        }else{\n               int sum = value*10+node.value;\n          trace(node.left,sum);\n          trace(node.right,sum);\n        }\n      }\n      }\n```\n    3、微信群聊中,每个人都有未读消息和　已读消息,如何设计提供每个人显示多少未读消息且能快速找到具体的未读消息(假设是一周时间段,如果是群人数有限和群人数无限)? 请使用 最少的存储空间和最快速的查找算法 来解决\n    answer:  －　wechat类模拟群，wechat的ａｄｄ方法在将增加ｕｓｅｒｓ的messageNum数量（即未读消息数量）并且在数据表中写入消息（消息仅写入一次）、用户消息关联、用户未读消息数量，用户关联表ｓｔａｔｅ初始消息为未读；\n             －　根据这个可以将用户的所有未读消息查询出来，每个消息有时间戳字段（默认时间戳排序），根据时间二分法就可以查询；若根据内容查询，ｍｅｓｓａｇｅ有根据内容生成的ｈａｓｈ字段，可依此存入容器查询，或者使用快速查找均可；\n             \n             \n             public class Wechat{\n             \n              private List<User> users;\n               \n               \n               public void add(){\n               增加用户未读信息数量;\n               }\n             }\n             \n             public class User{\n              private Long userId;\n               private Integer messageNum;\n             }\n               \n               /**\n               可一条消息对应多个用户\n               BUseMessage为用户与消息关联表\n               */\n               public class  BUseMessage{\n               \n                 private Long UserId;\n                 private Long messageId;\n                 //是否已读\n                 private Integer state;\n               }\n               \n               public class Message{\n               private Long messageId;\n               private String content;\n                 private Long timeStamp;\n                 private Integar state;\n                 //　根据content生成ｈａｓｈ值\n                 private Long hash;\n                 public Long hashcod(){\n                 return hash;\n                 }\n               }\n- 商家成长部   \n２月２２号收到商家增长部提前批面试\n    - 个人介绍\n    - 喜欢干啥\n    - 阅读过哪些中间件源码，擅长的技术\n    - 获奖\n    - tcp udp区别\n    - 一个消息包从北京发送的广州的流程\n    - 说说arp协议\n    - 说说面向对象的几个原则\n    - 面向对象的优点\n    - 计算机内负数怎么表示，为什么\n    - 三次握手的过程 二次握手的问题\n    - 说说滑动窗口协议\n    - hashmap的get过程\n    - synchronized用法，方法添加static的区别\n    - 说说cap    ","slug":"用户增长部提前批面经","published":1,"updated":"2020-03-10T08:00:04.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz82002a9oet9ctobjei","content":"<ul>\n<li>用户增长部<br>２月２０号做了笔试，三道题目<a id=\"more\"></a><br>  1、单向链表“双节”点逆转 ，比如：1-&gt;2 -&gt;3 -&gt;4 -&gt;5    逆转后  4-&gt;5-&gt;2-&gt;3-&gt;1  <figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">solution</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">  </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"hljs-keyword\">int</span> value;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">      Node next;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">(node root)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"hljs-keyword\">if</span>(root == <span class=\"hljs-keyword\">null</span> || root.next == <span class=\"hljs-keyword\">null</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"hljs-keyword\">return</span> root</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">      &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">Node  index = root.next;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">      root.next = <span class=\"hljs-keyword\">null</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">      Node last;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"hljs-keyword\">while</span>(index != <span class=\"hljs-keyword\">null</span> &amp;&amp; index.next != <span class=\"hljs-keyword\">null</span>) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">        Node tem = index.next.next</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">          index.next.next =root;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">        root = index;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">        index = tem;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">if</span>(index != <span class=\"hljs-keyword\">null</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">  index.next = root;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">  root = index;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"hljs-keyword\">return</span> root;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr></table></figure>\n<!--more-->\n  2、给定一棵二叉树，每个节点只包含数字0-9，从根节点到叶子节点的每条路径可以表示成一个数，请这些数的和。例如从根节点到叶子节点分别为1-&gt;2-&gt;3，那么这条路径代表数字123。求所有路径代表的数字的和  <figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"hljs-keyword\">int</span> value;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">      Node left;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">        Node right;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">    ArrayList&lt;Integer&gt; res = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Integer <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">(Node node)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">if</span>(node == <span class=\"hljs-keyword\">null</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">      trace(node,<span class=\"hljs-number\">0</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"hljs-keyword\">for</span>(Integer value: res)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">      sum+=value;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">      &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"hljs-keyword\">return</span> sum;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">trace</span><span class=\"hljs-params\">(Node node , <span class=\"hljs-keyword\">int</span> value)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"hljs-keyword\">if</span>(node == <span class=\"hljs-keyword\">null</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">      res.add(value);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;<span class=\"hljs-keyword\">else</span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">           <span class=\"hljs-keyword\">int</span> sum = value*<span class=\"hljs-number\">10</span>+node.value;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">      trace(node.left,sum);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">      trace(node.right,sum);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">28</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">29</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr></table></figure>\n  3、微信群聊中,每个人都有未读消息和　已读消息,如何设计提供每个人显示多少未读消息且能快速找到具体的未读消息(假设是一周时间段,如果是群人数有限和群人数无限)? 请使用 最少的存储空间和最快速的查找算法 来解决<br>  answer:  －　wechat类模拟群，wechat的ａｄｄ方法在将增加ｕｓｅｒｓ的messageNum数量（即未读消息数量）并且在数据表中写入消息（消息仅写入一次）、用户消息关联、用户未读消息数量，用户关联表ｓｔａｔｅ初始消息为未读；<pre><code>－　根据这个可以将用户的所有未读消息查询出来，每个消息有时间戳字段（默认时间戳排序），根据时间二分法就可以查询；若根据内容查询，ｍｅｓｓａｇｅ有根据内容生成的ｈａｓｈ字段，可依此存入容器查询，或者使用快速查找均可；</code></pre></li>\n</ul>\n<pre><code>public class Wechat{\n\n private List&lt;User&gt; users;\n\n\n  public void add(){\n  增加用户未读信息数量;\n  }\n}\n\npublic class User{\n private Long userId;\n  private Integer messageNum;\n}\n\n  /**\n  可一条消息对应多个用户\n  BUseMessage为用户与消息关联表\n  */\n  public class  BUseMessage{\n\n    private Long UserId;\n    private Long messageId;\n    //是否已读\n    private Integer state;\n  }\n\n  public class Message{\n  private Long messageId;\n  private String content;\n    private Long timeStamp;\n    private Integar state;\n    //　根据content生成ｈａｓｈ值\n    private Long hash;\n    public Long hashcod(){\n    return hash;\n    }\n  }</code></pre><ul>\n<li>商家成长部<br>２月２２号收到商家增长部提前批面试<ul>\n<li>个人介绍</li>\n<li>喜欢干啥</li>\n<li>阅读过哪些中间件源码，擅长的技术</li>\n<li>获奖</li>\n<li>tcp udp区别</li>\n<li>一个消息包从北京发送的广州的流程</li>\n<li>说说arp协议</li>\n<li>说说面向对象的几个原则</li>\n<li>面向对象的优点</li>\n<li>计算机内负数怎么表示，为什么</li>\n<li>三次握手的过程 二次握手的问题</li>\n<li>说说滑动窗口协议</li>\n<li>hashmap的get过程</li>\n<li>synchronized用法，方法添加static的区别</li>\n<li>说说cap    </li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>用户增长部<br>２月２０号做了笔试，三道题目</li></ul>","more":"<br>  1、单向链表“双节”点逆转 ，比如：1-&gt;2 -&gt;3 -&gt;4 -&gt;5    逆转后  4-&gt;5-&gt;2-&gt;3-&gt;1  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">solution</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">  </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"keyword\">int</span> value;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">      Node next;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">solution</span><span class=\"params\">(node root)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> || root.next == <span class=\"keyword\">null</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">return</span> root</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">      &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">Node  index = root.next;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">      root.next = <span class=\"keyword\">null</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">      Node last;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">while</span>(index != <span class=\"keyword\">null</span> &amp;&amp; index.next != <span class=\"keyword\">null</span>) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">        Node tem = index.next.next</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">          index.next.next =root;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">        root = index;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">        index = tem;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(index != <span class=\"keyword\">null</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">  index.next = root;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">  root = index;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">return</span> root;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr></table></figure>\n<!--more-->\n  2、给定一棵二叉树，每个节点只包含数字0-9，从根节点到叶子节点的每条路径可以表示成一个数，请这些数的和。例如从根节点到叶子节点分别为1-&gt;2-&gt;3，那么这条路径代表数字123。求所有路径代表的数字的和  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"keyword\">int</span> value;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">      Node left;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">        Node right;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">    ArrayList&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">solution</span><span class=\"params\">(Node node)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">      trace(node,<span class=\"number\">0</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">for</span>(Integer value: res)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">      sum+=value;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">      &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">return</span> sum;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(Node node , <span class=\"keyword\">int</span> value)</span></span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>)&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">      res.add(value);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">           <span class=\"keyword\">int</span> sum = value*<span class=\"number\">10</span>+node.value;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">      trace(node.left,sum);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">      trace(node.right,sum);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">27</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">28</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">29</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr></table></figure>\n  3、微信群聊中,每个人都有未读消息和　已读消息,如何设计提供每个人显示多少未读消息且能快速找到具体的未读消息(假设是一周时间段,如果是群人数有限和群人数无限)? 请使用 最少的存储空间和最快速的查找算法 来解决<br>  answer:  －　wechat类模拟群，wechat的ａｄｄ方法在将增加ｕｓｅｒｓ的messageNum数量（即未读消息数量）并且在数据表中写入消息（消息仅写入一次）、用户消息关联、用户未读消息数量，用户关联表ｓｔａｔｅ初始消息为未读；<pre><code>－　根据这个可以将用户的所有未读消息查询出来，每个消息有时间戳字段（默认时间戳排序），根据时间二分法就可以查询；若根据内容查询，ｍｅｓｓａｇｅ有根据内容生成的ｈａｓｈ字段，可依此存入容器查询，或者使用快速查找均可；</code></pre></li>\n</ul>\n<pre><code>public class Wechat{\n\n private List&lt;User&gt; users;\n\n\n  public void add(){\n  增加用户未读信息数量;\n  }\n}\n\npublic class User{\n private Long userId;\n  private Integer messageNum;\n}\n\n  /**\n  可一条消息对应多个用户\n  BUseMessage为用户与消息关联表\n  */\n  public class  BUseMessage{\n\n    private Long UserId;\n    private Long messageId;\n    //是否已读\n    private Integer state;\n  }\n\n  public class Message{\n  private Long messageId;\n  private String content;\n    private Long timeStamp;\n    private Integar state;\n    //　根据content生成ｈａｓｈ值\n    private Long hash;\n    public Long hashcod(){\n    return hash;\n    }\n  }</code></pre><ul>\n<li>商家成长部<br>２月２２号收到商家增长部提前批面试<ul>\n<li>个人介绍</li>\n<li>喜欢干啥</li>\n<li>阅读过哪些中间件源码，擅长的技术</li>\n<li>获奖</li>\n<li>tcp udp区别</li>\n<li>一个消息包从北京发送的广州的流程</li>\n<li>说说arp协议</li>\n<li>说说面向对象的几个原则</li>\n<li>面向对象的优点</li>\n<li>计算机内负数怎么表示，为什么</li>\n<li>三次握手的过程 二次握手的问题</li>\n<li>说说滑动窗口协议</li>\n<li>hashmap的get过程</li>\n<li>synchronized用法，方法添加static的区别</li>\n<li>说说cap    </li>\n</ul>\n</li>\n</ul>"},{"title":"阿里巴巴ihome团队面试","date":"2020-03-03T12:33:18.000Z","_content":"#### 一面\n\n- 自我介绍\n- 中间件比赛、负载均衡算法　使用什么java组件，底层怎么实现的，业界有哪些负载均衡算法以及优缺点\n- springboot springcloud 了解和使用经验,使用到springcloud哪些模块\n- 让你自己实现rpc，讲解下思路\n    - 将注册中心分离开使用请求方式注册发现服务，使用spring resttemplate发送请求调用提供者服务\n<!--more-->\n- http协议是哪层协议，协议组成\n- 不使用现有http组件请求\n    socket serverSocket  \n- 异步非堵塞如何使用\n    换成socketChannel serverSocketChannnel可以完成非堵塞，异步还需要返回句柄\n- 为什么能完成非堵塞功能\n    selector 不用等待io写，到达请求后分配线程处理\n- 这一块是用操作系统还是jvm来完成\n    操作系统　fd epoll\n- 对jvm了解吗\n- 垃圾回收原理\n- springbean 放在内存哪块区域\n- springbean 一般是单例吗　可以是多例吗\n- bean会一直存在spring 容器里吗\n- spring在后台开发中作用\n- mysql索引有哪些\n- mysql实现join b+树索引和hash索引有什么区别\n    不清楚\n- 说说b+树，为什么使用B+树索引\n- mysql表上建的索引有哪些\n- 不是主键索引是什么索引，二级索引了解过吗\n    不清楚\n- 事务中了解过吗\n- 都完成都不完成属于数据库哪个特性，还有哪些特性\n- 数据隔离性都有哪些级别，都有什么问题\n- 数据库挂掉了如何恢复,什么机制\n- 实习中收获比较大的事情\n- 爱奇艺怎么样\n- ihome团队了解过，做的是和马生鲜业务，排斥来杭州吗\n- 有哪些要问我的吗？(你看我这边技术栈还有哪些要补充的,技术上需要再深入的地方，可否给些建议?)","source":"_posts/阿里巴巴ihome团队面试.md","raw":"---\ntitle: 阿里巴巴ihome团队面试\ndate: 2020-03-03 20:33:18\ncategories: note\ntags: alibaba\n---\n#### 一面\n\n- 自我介绍\n- 中间件比赛、负载均衡算法　使用什么java组件，底层怎么实现的，业界有哪些负载均衡算法以及优缺点\n- springboot springcloud 了解和使用经验,使用到springcloud哪些模块\n- 让你自己实现rpc，讲解下思路\n    - 将注册中心分离开使用请求方式注册发现服务，使用spring resttemplate发送请求调用提供者服务\n<!--more-->\n- http协议是哪层协议，协议组成\n- 不使用现有http组件请求\n    socket serverSocket  \n- 异步非堵塞如何使用\n    换成socketChannel serverSocketChannnel可以完成非堵塞，异步还需要返回句柄\n- 为什么能完成非堵塞功能\n    selector 不用等待io写，到达请求后分配线程处理\n- 这一块是用操作系统还是jvm来完成\n    操作系统　fd epoll\n- 对jvm了解吗\n- 垃圾回收原理\n- springbean 放在内存哪块区域\n- springbean 一般是单例吗　可以是多例吗\n- bean会一直存在spring 容器里吗\n- spring在后台开发中作用\n- mysql索引有哪些\n- mysql实现join b+树索引和hash索引有什么区别\n    不清楚\n- 说说b+树，为什么使用B+树索引\n- mysql表上建的索引有哪些\n- 不是主键索引是什么索引，二级索引了解过吗\n    不清楚\n- 事务中了解过吗\n- 都完成都不完成属于数据库哪个特性，还有哪些特性\n- 数据隔离性都有哪些级别，都有什么问题\n- 数据库挂掉了如何恢复,什么机制\n- 实习中收获比较大的事情\n- 爱奇艺怎么样\n- ihome团队了解过，做的是和马生鲜业务，排斥来杭州吗\n- 有哪些要问我的吗？(你看我这边技术栈还有哪些要补充的,技术上需要再深入的地方，可否给些建议?)","slug":"阿里巴巴ihome团队面试","published":1,"updated":"2020-03-10T08:00:04.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz85002e9oet9cvk8veq","content":"<h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><ul>\n<li>自我介绍</li>\n<li>中间件比赛、负载均衡算法　使用什么java组件，底层怎么实现的，业界有哪些负载均衡算法以及优缺点</li>\n<li>springboot springcloud 了解和使用经验,使用到springcloud哪些模块</li>\n<li>让你自己实现rpc，讲解下思路<ul>\n<li>将注册中心分离开使用请求方式注册发现服务，使用spring resttemplate发送请求调用提供者服务<a id=\"more\"></a></li>\n</ul>\n</li>\n<li>http协议是哪层协议，协议组成</li>\n<li>不使用现有http组件请求<br>  socket serverSocket  </li>\n<li>异步非堵塞如何使用<br>  换成socketChannel serverSocketChannnel可以完成非堵塞，异步还需要返回句柄</li>\n<li>为什么能完成非堵塞功能<br>  selector 不用等待io写，到达请求后分配线程处理</li>\n<li>这一块是用操作系统还是jvm来完成<br>  操作系统　fd epoll</li>\n<li>对jvm了解吗</li>\n<li>垃圾回收原理</li>\n<li>springbean 放在内存哪块区域</li>\n<li>springbean 一般是单例吗　可以是多例吗</li>\n<li>bean会一直存在spring 容器里吗</li>\n<li>spring在后台开发中作用</li>\n<li>mysql索引有哪些</li>\n<li>mysql实现join b+树索引和hash索引有什么区别<br>  不清楚</li>\n<li>说说b+树，为什么使用B+树索引</li>\n<li>mysql表上建的索引有哪些</li>\n<li>不是主键索引是什么索引，二级索引了解过吗<br>  不清楚</li>\n<li>事务中了解过吗</li>\n<li>都完成都不完成属于数据库哪个特性，还有哪些特性</li>\n<li>数据隔离性都有哪些级别，都有什么问题</li>\n<li>数据库挂掉了如何恢复,什么机制</li>\n<li>实习中收获比较大的事情</li>\n<li>爱奇艺怎么样</li>\n<li>ihome团队了解过，做的是和马生鲜业务，排斥来杭州吗</li>\n<li>有哪些要问我的吗？(你看我这边技术栈还有哪些要补充的,技术上需要再深入的地方，可否给些建议?)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><ul>\n<li>自我介绍</li>\n<li>中间件比赛、负载均衡算法　使用什么java组件，底层怎么实现的，业界有哪些负载均衡算法以及优缺点</li>\n<li>springboot springcloud 了解和使用经验,使用到springcloud哪些模块</li>\n<li>让你自己实现rpc，讲解下思路<ul>\n<li>将注册中心分离开使用请求方式注册发现服务，使用spring resttemplate发送请求调用提供者服务</li></ul></li></ul>","more":"</li>\n</ul>\n</li>\n<li>http协议是哪层协议，协议组成</li>\n<li>不使用现有http组件请求<br>  socket serverSocket  </li>\n<li>异步非堵塞如何使用<br>  换成socketChannel serverSocketChannnel可以完成非堵塞，异步还需要返回句柄</li>\n<li>为什么能完成非堵塞功能<br>  selector 不用等待io写，到达请求后分配线程处理</li>\n<li>这一块是用操作系统还是jvm来完成<br>  操作系统　fd epoll</li>\n<li>对jvm了解吗</li>\n<li>垃圾回收原理</li>\n<li>springbean 放在内存哪块区域</li>\n<li>springbean 一般是单例吗　可以是多例吗</li>\n<li>bean会一直存在spring 容器里吗</li>\n<li>spring在后台开发中作用</li>\n<li>mysql索引有哪些</li>\n<li>mysql实现join b+树索引和hash索引有什么区别<br>  不清楚</li>\n<li>说说b+树，为什么使用B+树索引</li>\n<li>mysql表上建的索引有哪些</li>\n<li>不是主键索引是什么索引，二级索引了解过吗<br>  不清楚</li>\n<li>事务中了解过吗</li>\n<li>都完成都不完成属于数据库哪个特性，还有哪些特性</li>\n<li>数据隔离性都有哪些级别，都有什么问题</li>\n<li>数据库挂掉了如何恢复,什么机制</li>\n<li>实习中收获比较大的事情</li>\n<li>爱奇艺怎么样</li>\n<li>ihome团队了解过，做的是和马生鲜业务，排斥来杭州吗</li>\n<li>有哪些要问我的吗？(你看我这边技术栈还有哪些要补充的,技术上需要再深入的地方，可否给些建议?)</li>\n</ul>"},{"title":"数据库事务","date":"2020-02-15T05:18:28.000Z","_content":"\n数据库事务级别依次由低到高有：\n- 读未提交\n- 读已提交\n- 可重复读\n- 序列化\nmysql默认隔离级别是可重复读\n\n不同事务级别带来的问题，主要是同一事务内多次读取的内容不一致问题\n<br>\n- 脏读：事务A中，读取到另一个事务B未提交的内容，然后事务B回滚，导致事务A读取的数据为脏数据。\n事务A读取了内容C，事务B更新了内容C但是未提交，事务A又一次读取内容C，但是内容C改变，两次读取内容不一致。\n- 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中，对数据进行了更新并提交，导致\n事务A多次读取同一数据，但结果不一致。\n- 幻读：事务A读取了表内所有行，事务B新增了一行，A再次读取时发现两次结果不一致，多了一行。\n\n小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表","source":"_posts/数据库事务.md","raw":"---\ntitle: 数据库事务\ndate: 2020-02-15 13:18:28\ncategories: 数据库\ntags: mysql\n---\n\n数据库事务级别依次由低到高有：\n- 读未提交\n- 读已提交\n- 可重复读\n- 序列化\nmysql默认隔离级别是可重复读\n\n不同事务级别带来的问题，主要是同一事务内多次读取的内容不一致问题\n<br>\n- 脏读：事务A中，读取到另一个事务B未提交的内容，然后事务B回滚，导致事务A读取的数据为脏数据。\n事务A读取了内容C，事务B更新了内容C但是未提交，事务A又一次读取内容C，但是内容C改变，两次读取内容不一致。\n- 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中，对数据进行了更新并提交，导致\n事务A多次读取同一数据，但结果不一致。\n- 幻读：事务A读取了表内所有行，事务B新增了一行，A再次读取时发现两次结果不一致，多了一行。\n\n小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表","slug":"数据库事务","published":1,"updated":"2020-02-15T05:31:22.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz86002i9oet7lejdkq4","content":"<p>数据库事务级别依次由低到高有：</p>\n<ul>\n<li>读未提交</li>\n<li>读已提交</li>\n<li>可重复读</li>\n<li>序列化<br>mysql默认隔离级别是可重复读</li>\n</ul>\n<p>不同事务级别带来的问题，主要是同一事务内多次读取的内容不一致问题<br><br></p>\n<ul>\n<li>脏读：事务A中，读取到另一个事务B未提交的内容，然后事务B回滚，导致事务A读取的数据为脏数据。<br>事务A读取了内容C，事务B更新了内容C但是未提交，事务A又一次读取内容C，但是内容C改变，两次读取内容不一致。</li>\n<li>不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中，对数据进行了更新并提交，导致<br>事务A多次读取同一数据，但结果不一致。</li>\n<li>幻读：事务A读取了表内所有行，事务B新增了一行，A再次读取时发现两次结果不一致，多了一行。</li>\n</ul>\n<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>\n","site":{"data":{}},"excerpt":"","more":"<p>数据库事务级别依次由低到高有：</p>\n<ul>\n<li>读未提交</li>\n<li>读已提交</li>\n<li>可重复读</li>\n<li>序列化<br>mysql默认隔离级别是可重复读</li>\n</ul>\n<p>不同事务级别带来的问题，主要是同一事务内多次读取的内容不一致问题<br><br></p>\n<ul>\n<li>脏读：事务A中，读取到另一个事务B未提交的内容，然后事务B回滚，导致事务A读取的数据为脏数据。<br>事务A读取了内容C，事务B更新了内容C但是未提交，事务A又一次读取内容C，但是内容C改变，两次读取内容不一致。</li>\n<li>不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中，对数据进行了更新并提交，导致<br>事务A多次读取同一数据，但结果不一致。</li>\n<li>幻读：事务A读取了表内所有行，事务B新增了一行，A再次读取时发现两次结果不一致，多了一行。</li>\n</ul>\n<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>\n"},{"title":"解决TIME_WAIT过多的问题","date":"2020-02-09T14:48:30.000Z","_content":"\n- TIME_WAIT产生原因\n一般在是TCP断开连接时，主动断开的一方会进入到TIME_WAIT的状态。此状态\n会保留2MSL时间（30s 1min 2min不等）\n<br>\n在web应用中，基于TCP的http短连接通常由Server端先断开连接，往往Server端会产生TIME_WAIT连接记录，\n在高并发的应用中，此状态的连接较多。\n\n- 解决办法\n配置文件中写入 net.ipv4.tcp_tw_recycle=1  　表示开启TCP连接中TIME-WAIT sockets的快速回收\n\n-参考连接\n[解决TIME_WAIT过多造成的问题](https://www.cnblogs.com/dadonggg/p/8778318.html)\n<br>\n[阿里ECS/Linux大量TIME_WAIT解决方案](https://blog.csdn.net/hemin1003/article/details/82963558)","source":"_posts/解决TIME-WAIT过多的问题.md","raw":"---\ntitle: 解决TIME_WAIT过多的问题\ndate: 2020-02-09 22:48:30\ncategories: 网络\ntags: TCP\n---\n\n- TIME_WAIT产生原因\n一般在是TCP断开连接时，主动断开的一方会进入到TIME_WAIT的状态。此状态\n会保留2MSL时间（30s 1min 2min不等）\n<br>\n在web应用中，基于TCP的http短连接通常由Server端先断开连接，往往Server端会产生TIME_WAIT连接记录，\n在高并发的应用中，此状态的连接较多。\n\n- 解决办法\n配置文件中写入 net.ipv4.tcp_tw_recycle=1  　表示开启TCP连接中TIME-WAIT sockets的快速回收\n\n-参考连接\n[解决TIME_WAIT过多造成的问题](https://www.cnblogs.com/dadonggg/p/8778318.html)\n<br>\n[阿里ECS/Linux大量TIME_WAIT解决方案](https://blog.csdn.net/hemin1003/article/details/82963558)","slug":"解决TIME-WAIT过多的问题","published":1,"updated":"2020-02-09T14:56:24.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz89002m9oet8bx6hc7b","content":"<ul>\n<li><p>TIME_WAIT产生原因<br>一般在是TCP断开连接时，主动断开的一方会进入到TIME_WAIT的状态。此状态<br>会保留2MSL时间（30s 1min 2min不等）</p>\n<br>\n在web应用中，基于TCP的http短连接通常由Server端先断开连接，往往Server端会产生TIME_WAIT连接记录，\n在高并发的应用中，此状态的连接较多。\n</li>\n<li><p>解决办法<br>配置文件中写入 net.ipv4.tcp_tw_recycle=1  　表示开启TCP连接中TIME-WAIT sockets的快速回收</p>\n</li>\n</ul>\n<p>-参考连接<br><a href=\"https://www.cnblogs.com/dadonggg/p/8778318.html\" target=\"_blank\" rel=\"noopener\">解决TIME_WAIT过多造成的问题</a><br><br><br><a href=\"https://blog.csdn.net/hemin1003/article/details/82963558\" target=\"_blank\" rel=\"noopener\">阿里ECS/Linux大量TIME_WAIT解决方案</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>TIME_WAIT产生原因<br>一般在是TCP断开连接时，主动断开的一方会进入到TIME_WAIT的状态。此状态<br>会保留2MSL时间（30s 1min 2min不等）</p>\n<br>\n在web应用中，基于TCP的http短连接通常由Server端先断开连接，往往Server端会产生TIME_WAIT连接记录，\n在高并发的应用中，此状态的连接较多。\n</li>\n<li><p>解决办法<br>配置文件中写入 net.ipv4.tcp_tw_recycle=1  　表示开启TCP连接中TIME-WAIT sockets的快速回收</p>\n</li>\n</ul>\n<p>-参考连接<br><a href=\"https://www.cnblogs.com/dadonggg/p/8778318.html\" target=\"_blank\" rel=\"noopener\">解决TIME_WAIT过多造成的问题</a><br><br><br><a href=\"https://blog.csdn.net/hemin1003/article/details/82963558\" target=\"_blank\" rel=\"noopener\">阿里ECS/Linux大量TIME_WAIT解决方案</a></p>\n"},{"title":"阿里巴巴淘宝互动平台实习生面试","date":"2020-03-11T03:08:41.000Z","_content":"- 一面(2020.3.9 11:10)\n    - 自我介绍\n    - 项目介绍\n    - 负载均衡 常用的负载均衡算法、有没有看过其他优秀的比赛代码\n    - tcp\n    <!--more-->\n    - StringBuilder StringBuffer\n    - jvm内存\n    后续记不得了\n    \n- 二面(2020.3.11 10:15)\n    - 为何去爱奇艺实习,其他同学去了吗　还是就你自己去了\n    - 实习经历描述\n    - 安卓和电视客户端包形式有何不同\n        一般来说都是apk形式的，就是功能上　安卓的更倾向于支持点、划等触屏操作，电视上则是遥控器上的相关操作\n    - 为何考虑转移到jenkins构建，还有其他的构建平台吗？jenkins如何做到构建的\n            CruiseControl 阿里云效　Hudson\n    - pipeline介绍下，ant gradle的区别和优缺点\n        于是jenkins2.x开始流行pipeline的写法，以代码的方式来进行job的构建。\n        ANT是最早的构建工具，基于idea,好象是2000年有的，当时是最流行java构建工具，不过它的XML脚本编写格式让XML文件特别大。对工程构建过程中的过程控制特别好。\n        Maven它是用来给Ant补坑的，Maven第一次支持了从网络上下载的功能，仍然采用xml作为配置文件格式，它的问题是不能很好的相同库文件的版本冲突。Maven专注的是依赖管理，构建神马的并不擅长。\n        Gradle是一个自动化的构建工具，Gradle属于结合以上两个的优点，它继承了Ant的灵活和Maven的生命周期管理，它最后被google作为了Android御用管理工具。它最大的*区别是不用XML作为配置文件格式，采用了DSL格式，使得脚本更加简洁。Gradle引入了基于Groovy语言的DSL语法来代替XML配置，因此它的配置文件是一个Groovy文件。\n    - 多节点无锁构建如何实现？和数据加锁有何区别?你这种实现方式缺点是什么？还有什么其他解决方案\n    - 使用redis如何使用加锁，为何redis是原子性的\n    - redis的hash表是如何实现的和java的hash表有什么区别\n    - redis的字符串如何是实现,search list如何实现\n    - mysql索引如何实现,mysql如何实现加锁\n    - 有没有其他的实现缓存的nosql数据库,redis和memcache的区别\n    - spring springboot springcloud\n    - springboot自动配置\n        [Spring Boot面试杀手锏————自动配置原理](https://blog.csdn.net/u014745069/article/details/83820511)\n    - java为何标了注解可以实现相应的功能\n    - spring bean初始化过程\n    - 解析xml的方法 \n        SAX DOM JAXB\n        [java xml解析工：dom4j , jdom , jaxb , stax, sax的具适用场景比较](https://blog.csdn.net/miniyuyu/article/details/80259952)\n    - jaxb和dom方式的区别\n        性能和解析复杂程度上\n    - http1 http2的区别\n        \n    - http 301 302区别\n        301永久性转移　302暂时性转移\n    - 如何验证负载均衡的效果\n    - rest和rpc有什么区别\n    - 有什么想问的","source":"_posts/阿里巴巴淘宝互动平台实习生面试.md","raw":"---\ntitle: 阿里巴巴淘宝互动平台实习生面试\ndate: 2020-03-11 11:08:41\ncategories: note\ntags: alibaba\n---\n- 一面(2020.3.9 11:10)\n    - 自我介绍\n    - 项目介绍\n    - 负载均衡 常用的负载均衡算法、有没有看过其他优秀的比赛代码\n    - tcp\n    <!--more-->\n    - StringBuilder StringBuffer\n    - jvm内存\n    后续记不得了\n    \n- 二面(2020.3.11 10:15)\n    - 为何去爱奇艺实习,其他同学去了吗　还是就你自己去了\n    - 实习经历描述\n    - 安卓和电视客户端包形式有何不同\n        一般来说都是apk形式的，就是功能上　安卓的更倾向于支持点、划等触屏操作，电视上则是遥控器上的相关操作\n    - 为何考虑转移到jenkins构建，还有其他的构建平台吗？jenkins如何做到构建的\n            CruiseControl 阿里云效　Hudson\n    - pipeline介绍下，ant gradle的区别和优缺点\n        于是jenkins2.x开始流行pipeline的写法，以代码的方式来进行job的构建。\n        ANT是最早的构建工具，基于idea,好象是2000年有的，当时是最流行java构建工具，不过它的XML脚本编写格式让XML文件特别大。对工程构建过程中的过程控制特别好。\n        Maven它是用来给Ant补坑的，Maven第一次支持了从网络上下载的功能，仍然采用xml作为配置文件格式，它的问题是不能很好的相同库文件的版本冲突。Maven专注的是依赖管理，构建神马的并不擅长。\n        Gradle是一个自动化的构建工具，Gradle属于结合以上两个的优点，它继承了Ant的灵活和Maven的生命周期管理，它最后被google作为了Android御用管理工具。它最大的*区别是不用XML作为配置文件格式，采用了DSL格式，使得脚本更加简洁。Gradle引入了基于Groovy语言的DSL语法来代替XML配置，因此它的配置文件是一个Groovy文件。\n    - 多节点无锁构建如何实现？和数据加锁有何区别?你这种实现方式缺点是什么？还有什么其他解决方案\n    - 使用redis如何使用加锁，为何redis是原子性的\n    - redis的hash表是如何实现的和java的hash表有什么区别\n    - redis的字符串如何是实现,search list如何实现\n    - mysql索引如何实现,mysql如何实现加锁\n    - 有没有其他的实现缓存的nosql数据库,redis和memcache的区别\n    - spring springboot springcloud\n    - springboot自动配置\n        [Spring Boot面试杀手锏————自动配置原理](https://blog.csdn.net/u014745069/article/details/83820511)\n    - java为何标了注解可以实现相应的功能\n    - spring bean初始化过程\n    - 解析xml的方法 \n        SAX DOM JAXB\n        [java xml解析工：dom4j , jdom , jaxb , stax, sax的具适用场景比较](https://blog.csdn.net/miniyuyu/article/details/80259952)\n    - jaxb和dom方式的区别\n        性能和解析复杂程度上\n    - http1 http2的区别\n        \n    - http 301 302区别\n        301永久性转移　302暂时性转移\n    - 如何验证负载均衡的效果\n    - rest和rpc有什么区别\n    - 有什么想问的","slug":"阿里巴巴淘宝互动平台实习生面试","published":1,"updated":"2020-03-15T15:53:09.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz8b002q9oetg8vmdgeu","content":"<ul>\n<li><p>一面(2020.3.9 11:10)</p>\n<ul>\n<li>自我介绍</li>\n<li>项目介绍</li>\n<li>负载均衡 常用的负载均衡算法、有没有看过其他优秀的比赛代码</li>\n<li>tcp<a id=\"more\"></a></li>\n<li>StringBuilder StringBuffer</li>\n<li>jvm内存<br>后续记不得了</li>\n</ul>\n</li>\n<li><p>二面(2020.3.11 10:15)</p>\n<ul>\n<li><p>为何去爱奇艺实习,其他同学去了吗　还是就你自己去了</p>\n</li>\n<li><p>实习经历描述</p>\n</li>\n<li><p>安卓和电视客户端包形式有何不同<br>  一般来说都是apk形式的，就是功能上　安卓的更倾向于支持点、划等触屏操作，电视上则是遥控器上的相关操作</p>\n</li>\n<li><p>为何考虑转移到jenkins构建，还有其他的构建平台吗？jenkins如何做到构建的</p>\n<pre><code>CruiseControl 阿里云效　Hudson</code></pre></li>\n<li><p>pipeline介绍下，ant gradle的区别和优缺点<br>  于是jenkins2.x开始流行pipeline的写法，以代码的方式来进行job的构建。<br>  ANT是最早的构建工具，基于idea,好象是2000年有的，当时是最流行java构建工具，不过它的XML脚本编写格式让XML文件特别大。对工程构建过程中的过程控制特别好。<br>  Maven它是用来给Ant补坑的，Maven第一次支持了从网络上下载的功能，仍然采用xml作为配置文件格式，它的问题是不能很好的相同库文件的版本冲突。Maven专注的是依赖管理，构建神马的并不擅长。<br>  Gradle是一个自动化的构建工具，Gradle属于结合以上两个的优点，它继承了Ant的灵活和Maven的生命周期管理，它最后被google作为了Android御用管理工具。它最大的*区别是不用XML作为配置文件格式，采用了DSL格式，使得脚本更加简洁。Gradle引入了基于Groovy语言的DSL语法来代替XML配置，因此它的配置文件是一个Groovy文件。</p>\n</li>\n<li><p>多节点无锁构建如何实现？和数据加锁有何区别?你这种实现方式缺点是什么？还有什么其他解决方案</p>\n</li>\n<li><p>使用redis如何使用加锁，为何redis是原子性的</p>\n</li>\n<li><p>redis的hash表是如何实现的和java的hash表有什么区别</p>\n</li>\n<li><p>redis的字符串如何是实现,search list如何实现</p>\n</li>\n<li><p>mysql索引如何实现,mysql如何实现加锁</p>\n</li>\n<li><p>有没有其他的实现缓存的nosql数据库,redis和memcache的区别</p>\n</li>\n<li><p>spring springboot springcloud</p>\n</li>\n<li><p>springboot自动配置<br>  <a href=\"https://blog.csdn.net/u014745069/article/details/83820511\" target=\"_blank\" rel=\"noopener\">Spring Boot面试杀手锏————自动配置原理</a></p>\n</li>\n<li><p>java为何标了注解可以实现相应的功能</p>\n</li>\n<li><p>spring bean初始化过程</p>\n</li>\n<li><p>解析xml的方法<br>  SAX DOM JAXB<br>  <a href=\"https://blog.csdn.net/miniyuyu/article/details/80259952\" target=\"_blank\" rel=\"noopener\">java xml解析工：dom4j , jdom , jaxb , stax, sax的具适用场景比较</a></p>\n</li>\n<li><p>jaxb和dom方式的区别<br>  性能和解析复杂程度上</p>\n</li>\n<li><p>http1 http2的区别</p>\n</li>\n<li><p>http 301 302区别<br>  301永久性转移　302暂时性转移</p>\n</li>\n<li><p>如何验证负载均衡的效果</p>\n</li>\n<li><p>rest和rpc有什么区别</p>\n</li>\n<li><p>有什么想问的</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>一面(2020.3.9 11:10)</p>\n<ul>\n<li>自我介绍</li>\n<li>项目介绍</li>\n<li>负载均衡 常用的负载均衡算法、有没有看过其他优秀的比赛代码</li>\n<li>tcp</li></ul></li></ul>","more":"</li>\n<li>StringBuilder StringBuffer</li>\n<li>jvm内存<br>后续记不得了</li>\n</ul>\n</li>\n<li><p>二面(2020.3.11 10:15)</p>\n<ul>\n<li><p>为何去爱奇艺实习,其他同学去了吗　还是就你自己去了</p>\n</li>\n<li><p>实习经历描述</p>\n</li>\n<li><p>安卓和电视客户端包形式有何不同<br>  一般来说都是apk形式的，就是功能上　安卓的更倾向于支持点、划等触屏操作，电视上则是遥控器上的相关操作</p>\n</li>\n<li><p>为何考虑转移到jenkins构建，还有其他的构建平台吗？jenkins如何做到构建的</p>\n<pre><code>CruiseControl 阿里云效　Hudson</code></pre></li>\n<li><p>pipeline介绍下，ant gradle的区别和优缺点<br>  于是jenkins2.x开始流行pipeline的写法，以代码的方式来进行job的构建。<br>  ANT是最早的构建工具，基于idea,好象是2000年有的，当时是最流行java构建工具，不过它的XML脚本编写格式让XML文件特别大。对工程构建过程中的过程控制特别好。<br>  Maven它是用来给Ant补坑的，Maven第一次支持了从网络上下载的功能，仍然采用xml作为配置文件格式，它的问题是不能很好的相同库文件的版本冲突。Maven专注的是依赖管理，构建神马的并不擅长。<br>  Gradle是一个自动化的构建工具，Gradle属于结合以上两个的优点，它继承了Ant的灵活和Maven的生命周期管理，它最后被google作为了Android御用管理工具。它最大的*区别是不用XML作为配置文件格式，采用了DSL格式，使得脚本更加简洁。Gradle引入了基于Groovy语言的DSL语法来代替XML配置，因此它的配置文件是一个Groovy文件。</p>\n</li>\n<li><p>多节点无锁构建如何实现？和数据加锁有何区别?你这种实现方式缺点是什么？还有什么其他解决方案</p>\n</li>\n<li><p>使用redis如何使用加锁，为何redis是原子性的</p>\n</li>\n<li><p>redis的hash表是如何实现的和java的hash表有什么区别</p>\n</li>\n<li><p>redis的字符串如何是实现,search list如何实现</p>\n</li>\n<li><p>mysql索引如何实现,mysql如何实现加锁</p>\n</li>\n<li><p>有没有其他的实现缓存的nosql数据库,redis和memcache的区别</p>\n</li>\n<li><p>spring springboot springcloud</p>\n</li>\n<li><p>springboot自动配置<br>  <a href=\"https://blog.csdn.net/u014745069/article/details/83820511\" target=\"_blank\" rel=\"noopener\">Spring Boot面试杀手锏————自动配置原理</a></p>\n</li>\n<li><p>java为何标了注解可以实现相应的功能</p>\n</li>\n<li><p>spring bean初始化过程</p>\n</li>\n<li><p>解析xml的方法<br>  SAX DOM JAXB<br>  <a href=\"https://blog.csdn.net/miniyuyu/article/details/80259952\" target=\"_blank\" rel=\"noopener\">java xml解析工：dom4j , jdom , jaxb , stax, sax的具适用场景比较</a></p>\n</li>\n<li><p>jaxb和dom方式的区别<br>  性能和解析复杂程度上</p>\n</li>\n<li><p>http1 http2的区别</p>\n</li>\n<li><p>http 301 302区别<br>  301永久性转移　302暂时性转移</p>\n</li>\n<li><p>如何验证负载均衡的效果</p>\n</li>\n<li><p>rest和rpc有什么区别</p>\n</li>\n<li><p>有什么想问的</p>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"阿里巴巴支付宝面试","date":"2020-03-06T08:15:10.000Z","_content":"- 一面\n    - String s = new String(\"abc);会生成几个对象\n    - final 在java中的作用\n    - hashMap原理<!--more-->\n    - hashMap是线程安全的吗？多线程操作hashMap会出现什么问题\n    - ConcurrentHashMap介绍下\n    - 创建线程有几种方法\n    - 线程堵塞的方法,join的形式如何用\n    - wait()和sleep()的区别\n    - 线程池有哪些参数；线程池运行原理；任务队列为空时，情况；\n    - java内存管理\n    - gc；cms初始标记和再次标记那个时间长；再次标记是如何标记；\n    - springBean生命周期\n    - @autowire原理\n    - 数组中找最大值和最小值,比较次数小于2n\n    - 说说红黑树\n    - 工厂模式？优点？哪几种？\n    - 事务隔离级别;解决什么问题;串行化问题;事务隔离如何实现\n    - mysql锁类型;gap锁如何使用\n    - 项目中做的比较有难度的，有亮点的问题\n        生成jenkins api xml文件，使用jaxb技术将对象映射程xml文件\n    - 你看我这边技术栈以及技术上有哪些需要深入的地方\n","source":"_posts/阿里巴巴支付宝面试.md","raw":"---\ntitle: 阿里巴巴支付宝面试\ndate: 2020-03-06 16:15:10\ncategories: note \ntags: alibaba\n---\n- 一面\n    - String s = new String(\"abc);会生成几个对象\n    - final 在java中的作用\n    - hashMap原理<!--more-->\n    - hashMap是线程安全的吗？多线程操作hashMap会出现什么问题\n    - ConcurrentHashMap介绍下\n    - 创建线程有几种方法\n    - 线程堵塞的方法,join的形式如何用\n    - wait()和sleep()的区别\n    - 线程池有哪些参数；线程池运行原理；任务队列为空时，情况；\n    - java内存管理\n    - gc；cms初始标记和再次标记那个时间长；再次标记是如何标记；\n    - springBean生命周期\n    - @autowire原理\n    - 数组中找最大值和最小值,比较次数小于2n\n    - 说说红黑树\n    - 工厂模式？优点？哪几种？\n    - 事务隔离级别;解决什么问题;串行化问题;事务隔离如何实现\n    - mysql锁类型;gap锁如何使用\n    - 项目中做的比较有难度的，有亮点的问题\n        生成jenkins api xml文件，使用jaxb技术将对象映射程xml文件\n    - 你看我这边技术栈以及技术上有哪些需要深入的地方\n","slug":"阿里巴巴支付宝面试","published":1,"updated":"2020-03-10T08:00:04.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz8d002u9oete1sd8cyi","content":"<ul>\n<li>一面<ul>\n<li>String s = new String(“abc);会生成几个对象</li>\n<li>final 在java中的作用</li>\n<li>hashMap原理<a id=\"more\"></a></li>\n<li>hashMap是线程安全的吗？多线程操作hashMap会出现什么问题</li>\n<li>ConcurrentHashMap介绍下</li>\n<li>创建线程有几种方法</li>\n<li>线程堵塞的方法,join的形式如何用</li>\n<li>wait()和sleep()的区别</li>\n<li>线程池有哪些参数；线程池运行原理；任务队列为空时，情况；</li>\n<li>java内存管理</li>\n<li>gc；cms初始标记和再次标记那个时间长；再次标记是如何标记；</li>\n<li>springBean生命周期</li>\n<li>@autowire原理</li>\n<li>数组中找最大值和最小值,比较次数小于2n</li>\n<li>说说红黑树</li>\n<li>工厂模式？优点？哪几种？</li>\n<li>事务隔离级别;解决什么问题;串行化问题;事务隔离如何实现</li>\n<li>mysql锁类型;gap锁如何使用</li>\n<li>项目中做的比较有难度的，有亮点的问题<br>  生成jenkins api xml文件，使用jaxb技术将对象映射程xml文件</li>\n<li>你看我这边技术栈以及技术上有哪些需要深入的地方</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>一面<ul>\n<li>String s = new String(“abc);会生成几个对象</li>\n<li>final 在java中的作用</li>\n<li>hashMap原理</li></ul></li></ul>","more":"</li>\n<li>hashMap是线程安全的吗？多线程操作hashMap会出现什么问题</li>\n<li>ConcurrentHashMap介绍下</li>\n<li>创建线程有几种方法</li>\n<li>线程堵塞的方法,join的形式如何用</li>\n<li>wait()和sleep()的区别</li>\n<li>线程池有哪些参数；线程池运行原理；任务队列为空时，情况；</li>\n<li>java内存管理</li>\n<li>gc；cms初始标记和再次标记那个时间长；再次标记是如何标记；</li>\n<li>springBean生命周期</li>\n<li>@autowire原理</li>\n<li>数组中找最大值和最小值,比较次数小于2n</li>\n<li>说说红黑树</li>\n<li>工厂模式？优点？哪几种？</li>\n<li>事务隔离级别;解决什么问题;串行化问题;事务隔离如何实现</li>\n<li>mysql锁类型;gap锁如何使用</li>\n<li>项目中做的比较有难度的，有亮点的问题<br>  生成jenkins api xml文件，使用jaxb技术将对象映射程xml文件</li>\n<li>你看我这边技术栈以及技术上有哪些需要深入的地方</li>\n</ul>\n</li>\n</ul>"},{"title":"腾讯pcg实习面试","date":"2020-03-13T08:45:43.000Z","_content":"- 一面\n    -自我介绍\n    - linux命令　cat awk top\n    - mysql 查询　多表查询　sql语句\n    - 联合索引查询 idx(a,b) select * from t where a = 1和select * from t where b = 1　走不走索引\n        https://www.cnblogs.com/xcsg/p/11109713.html\n    - 垃圾回收\n    - redis sds hash 扩容　增长因子还是二倍扩容\n    - 10TB数据找出最大值\n    - 负载均衡算法\n    - 1000个值里找最小值\n- 二面\n    - 中间件负载均衡比赛\n    - 多个负载节点如何处理\n    - 爱奇艺实习多久\n    - 是否想来深圳发展","source":"_posts/腾讯pcg实习面试.md","raw":"---\ntitle: 腾讯pcg实习面试\ndate: 2020-03-13 16:45:43\ncategories: note\ntags: 腾讯\n---\n- 一面\n    -自我介绍\n    - linux命令　cat awk top\n    - mysql 查询　多表查询　sql语句\n    - 联合索引查询 idx(a,b) select * from t where a = 1和select * from t where b = 1　走不走索引\n        https://www.cnblogs.com/xcsg/p/11109713.html\n    - 垃圾回收\n    - redis sds hash 扩容　增长因子还是二倍扩容\n    - 10TB数据找出最大值\n    - 负载均衡算法\n    - 1000个值里找最小值\n- 二面\n    - 中间件负载均衡比赛\n    - 多个负载节点如何处理\n    - 爱奇艺实习多久\n    - 是否想来深圳发展","slug":"腾讯pcg实习面试","published":1,"updated":"2020-03-16T11:13:51.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz8f002y9oet9zybery9","content":"<ul>\n<li>一面<br>  -自我介绍<ul>\n<li>linux命令　cat awk top</li>\n<li>mysql 查询　多表查询　sql语句</li>\n<li>联合索引查询 idx(a,b) select * from t where a = 1和select * from t where b = 1　走不走索引<br>  <a href=\"https://www.cnblogs.com/xcsg/p/11109713.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xcsg/p/11109713.html</a></li>\n<li>垃圾回收</li>\n<li>redis sds hash 扩容　增长因子还是二倍扩容</li>\n<li>10TB数据找出最大值</li>\n<li>负载均衡算法</li>\n<li>1000个值里找最小值</li>\n</ul>\n</li>\n<li>二面<ul>\n<li>中间件负载均衡比赛</li>\n<li>多个负载节点如何处理</li>\n<li>爱奇艺实习多久</li>\n<li>是否想来深圳发展</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>一面<br>  -自我介绍<ul>\n<li>linux命令　cat awk top</li>\n<li>mysql 查询　多表查询　sql语句</li>\n<li>联合索引查询 idx(a,b) select * from t where a = 1和select * from t where b = 1　走不走索引<br>  <a href=\"https://www.cnblogs.com/xcsg/p/11109713.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xcsg/p/11109713.html</a></li>\n<li>垃圾回收</li>\n<li>redis sds hash 扩容　增长因子还是二倍扩容</li>\n<li>10TB数据找出最大值</li>\n<li>负载均衡算法</li>\n<li>1000个值里找最小值</li>\n</ul>\n</li>\n<li>二面<ul>\n<li>中间件负载均衡比赛</li>\n<li>多个负载节点如何处理</li>\n<li>爱奇艺实习多久</li>\n<li>是否想来深圳发展</li>\n</ul>\n</li>\n</ul>\n"},{"title":"阿里巴巴钉钉面试","date":"2020-02-29T13:51:00.000Z","_content":"- 一面\n    - 个人介绍\n    - 项目介绍 亮点\n    - 多节点乐观锁实现\n    - 重复支付解决办法\n        [支付系统设计中，如何防止重复支付?](https://www.jianshu.com/p/6e9387218e12)\n    - rbac介绍 具体实现<!--more-->\n    - hashcode equal\n    - HashMap HashTable concurrentHashMap\n    - springboot配置Control步骤\n    - servlet\n    - 常见设计模式　观察者模式\n    - 出二维迷宫算法\n    - 快排算法\n    - 最长子序列和\n    - dp 01背包问题\n    - 二分查找在线编程\n    - 您看我的技术栈的补充以及技术水平有哪些需要深入的地方，可否给些建议？（问题）\n- 二面\n    - 个人介绍\n    - 项目中的挑战性问题　具体实现\n    - 负载均衡比赛中剩余能力算法的具体实现\n    - 比赛评估依据\n    - 项目技术选型　为何这么选，其他实现方式的优缺点\n        springboot+vue的好处\n        springboot简化编码，starter-web依赖spring springmvc tomcat多个包\n        简化配置　注解形式\n        简化部署　java -jar *.jar\n    - jvm内存管理\n    - full gc过程 stop the word时间降低原因\n    - rbac模型　其他技术选型比较\n    - 项目中　你做的优化的点\n    - 常用的数据结构以及使用场景 eg:hashmap\n    - redis的数据结构\n    - 为何使用redis　好处\n    - 项目中为何使用redis，分布式锁为何使用redis,其他分布式锁实现，zookeeper的了解\n        [Java分布式锁看这篇就够了](https://www.cnblogs.com/seesun2012/p/9214653.html)\n    - 常见的设计模式　项目中实际使用的的设计模式,具体实现\n    - tcp协议如何保证可靠连接的\n    - 快重传机制\n    - ioc　如何获取bean\n    - 项目中怎么使用的springcloud 用到的springcloud组件\n    - 职业规划\n    - 对钉钉的了解\n    - 对阿里的了解以及企业文化\n    - 您看我的技术栈的补充以及技术水平有哪些需要深入的地方，可否给些建议？（问题）\n    - 那您看我还有下次的机会吗?(问题)\n    - 有没有投其他公司的简历或者阿里其他部门\n    - 如果进阿里的话，你个人的优势\n    - 开源相关\n- hr面\n    - 自我介绍\n    - 说一下项目中的难点，你在里面承担了什么角色，如何和同学协作，如何解决\n    - 介绍了钉钉开放平台的业务\n    - 有什么问题","source":"_posts/阿里巴巴钉钉面试.md","raw":"---\ntitle: 阿里巴巴钉钉面试\ndate: 2020-02-29 21:51:00\ncategories: note\ntags: alibaba\n---\n- 一面\n    - 个人介绍\n    - 项目介绍 亮点\n    - 多节点乐观锁实现\n    - 重复支付解决办法\n        [支付系统设计中，如何防止重复支付?](https://www.jianshu.com/p/6e9387218e12)\n    - rbac介绍 具体实现<!--more-->\n    - hashcode equal\n    - HashMap HashTable concurrentHashMap\n    - springboot配置Control步骤\n    - servlet\n    - 常见设计模式　观察者模式\n    - 出二维迷宫算法\n    - 快排算法\n    - 最长子序列和\n    - dp 01背包问题\n    - 二分查找在线编程\n    - 您看我的技术栈的补充以及技术水平有哪些需要深入的地方，可否给些建议？（问题）\n- 二面\n    - 个人介绍\n    - 项目中的挑战性问题　具体实现\n    - 负载均衡比赛中剩余能力算法的具体实现\n    - 比赛评估依据\n    - 项目技术选型　为何这么选，其他实现方式的优缺点\n        springboot+vue的好处\n        springboot简化编码，starter-web依赖spring springmvc tomcat多个包\n        简化配置　注解形式\n        简化部署　java -jar *.jar\n    - jvm内存管理\n    - full gc过程 stop the word时间降低原因\n    - rbac模型　其他技术选型比较\n    - 项目中　你做的优化的点\n    - 常用的数据结构以及使用场景 eg:hashmap\n    - redis的数据结构\n    - 为何使用redis　好处\n    - 项目中为何使用redis，分布式锁为何使用redis,其他分布式锁实现，zookeeper的了解\n        [Java分布式锁看这篇就够了](https://www.cnblogs.com/seesun2012/p/9214653.html)\n    - 常见的设计模式　项目中实际使用的的设计模式,具体实现\n    - tcp协议如何保证可靠连接的\n    - 快重传机制\n    - ioc　如何获取bean\n    - 项目中怎么使用的springcloud 用到的springcloud组件\n    - 职业规划\n    - 对钉钉的了解\n    - 对阿里的了解以及企业文化\n    - 您看我的技术栈的补充以及技术水平有哪些需要深入的地方，可否给些建议？（问题）\n    - 那您看我还有下次的机会吗?(问题)\n    - 有没有投其他公司的简历或者阿里其他部门\n    - 如果进阿里的话，你个人的优势\n    - 开源相关\n- hr面\n    - 自我介绍\n    - 说一下项目中的难点，你在里面承担了什么角色，如何和同学协作，如何解决\n    - 介绍了钉钉开放平台的业务\n    - 有什么问题","slug":"阿里巴巴钉钉面试","published":1,"updated":"2020-03-14T07:27:42.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7yrhz8g00319oetgdvq5zcp","content":"<ul>\n<li>一面<ul>\n<li>个人介绍</li>\n<li>项目介绍 亮点</li>\n<li>多节点乐观锁实现</li>\n<li>重复支付解决办法<br>  <a href=\"https://www.jianshu.com/p/6e9387218e12\" target=\"_blank\" rel=\"noopener\">支付系统设计中，如何防止重复支付?</a></li>\n<li>rbac介绍 具体实现<a id=\"more\"></a></li>\n<li>hashcode equal</li>\n<li>HashMap HashTable concurrentHashMap</li>\n<li>springboot配置Control步骤</li>\n<li>servlet</li>\n<li>常见设计模式　观察者模式</li>\n<li>出二维迷宫算法</li>\n<li>快排算法</li>\n<li>最长子序列和</li>\n<li>dp 01背包问题</li>\n<li>二分查找在线编程</li>\n<li>您看我的技术栈的补充以及技术水平有哪些需要深入的地方，可否给些建议？（问题）</li>\n</ul>\n</li>\n<li>二面<ul>\n<li>个人介绍</li>\n<li>项目中的挑战性问题　具体实现</li>\n<li>负载均衡比赛中剩余能力算法的具体实现</li>\n<li>比赛评估依据</li>\n<li>项目技术选型　为何这么选，其他实现方式的优缺点<br>  springboot+vue的好处<br>  springboot简化编码，starter-web依赖spring springmvc tomcat多个包<br>  简化配置　注解形式<br>  简化部署　java -jar *.jar</li>\n<li>jvm内存管理</li>\n<li>full gc过程 stop the word时间降低原因</li>\n<li>rbac模型　其他技术选型比较</li>\n<li>项目中　你做的优化的点</li>\n<li>常用的数据结构以及使用场景 eg:hashmap</li>\n<li>redis的数据结构</li>\n<li>为何使用redis　好处</li>\n<li>项目中为何使用redis，分布式锁为何使用redis,其他分布式锁实现，zookeeper的了解<br>  <a href=\"https://www.cnblogs.com/seesun2012/p/9214653.html\" target=\"_blank\" rel=\"noopener\">Java分布式锁看这篇就够了</a></li>\n<li>常见的设计模式　项目中实际使用的的设计模式,具体实现</li>\n<li>tcp协议如何保证可靠连接的</li>\n<li>快重传机制</li>\n<li>ioc　如何获取bean</li>\n<li>项目中怎么使用的springcloud 用到的springcloud组件</li>\n<li>职业规划</li>\n<li>对钉钉的了解</li>\n<li>对阿里的了解以及企业文化</li>\n<li>您看我的技术栈的补充以及技术水平有哪些需要深入的地方，可否给些建议？（问题）</li>\n<li>那您看我还有下次的机会吗?(问题)</li>\n<li>有没有投其他公司的简历或者阿里其他部门</li>\n<li>如果进阿里的话，你个人的优势</li>\n<li>开源相关</li>\n</ul>\n</li>\n<li>hr面<ul>\n<li>自我介绍</li>\n<li>说一下项目中的难点，你在里面承担了什么角色，如何和同学协作，如何解决</li>\n<li>介绍了钉钉开放平台的业务</li>\n<li>有什么问题</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>一面<ul>\n<li>个人介绍</li>\n<li>项目介绍 亮点</li>\n<li>多节点乐观锁实现</li>\n<li>重复支付解决办法<br>  <a href=\"https://www.jianshu.com/p/6e9387218e12\" target=\"_blank\" rel=\"noopener\">支付系统设计中，如何防止重复支付?</a></li>\n<li>rbac介绍 具体实现</li></ul></li></ul>","more":"</li>\n<li>hashcode equal</li>\n<li>HashMap HashTable concurrentHashMap</li>\n<li>springboot配置Control步骤</li>\n<li>servlet</li>\n<li>常见设计模式　观察者模式</li>\n<li>出二维迷宫算法</li>\n<li>快排算法</li>\n<li>最长子序列和</li>\n<li>dp 01背包问题</li>\n<li>二分查找在线编程</li>\n<li>您看我的技术栈的补充以及技术水平有哪些需要深入的地方，可否给些建议？（问题）</li>\n</ul>\n</li>\n<li>二面<ul>\n<li>个人介绍</li>\n<li>项目中的挑战性问题　具体实现</li>\n<li>负载均衡比赛中剩余能力算法的具体实现</li>\n<li>比赛评估依据</li>\n<li>项目技术选型　为何这么选，其他实现方式的优缺点<br>  springboot+vue的好处<br>  springboot简化编码，starter-web依赖spring springmvc tomcat多个包<br>  简化配置　注解形式<br>  简化部署　java -jar *.jar</li>\n<li>jvm内存管理</li>\n<li>full gc过程 stop the word时间降低原因</li>\n<li>rbac模型　其他技术选型比较</li>\n<li>项目中　你做的优化的点</li>\n<li>常用的数据结构以及使用场景 eg:hashmap</li>\n<li>redis的数据结构</li>\n<li>为何使用redis　好处</li>\n<li>项目中为何使用redis，分布式锁为何使用redis,其他分布式锁实现，zookeeper的了解<br>  <a href=\"https://www.cnblogs.com/seesun2012/p/9214653.html\" target=\"_blank\" rel=\"noopener\">Java分布式锁看这篇就够了</a></li>\n<li>常见的设计模式　项目中实际使用的的设计模式,具体实现</li>\n<li>tcp协议如何保证可靠连接的</li>\n<li>快重传机制</li>\n<li>ioc　如何获取bean</li>\n<li>项目中怎么使用的springcloud 用到的springcloud组件</li>\n<li>职业规划</li>\n<li>对钉钉的了解</li>\n<li>对阿里的了解以及企业文化</li>\n<li>您看我的技术栈的补充以及技术水平有哪些需要深入的地方，可否给些建议？（问题）</li>\n<li>那您看我还有下次的机会吗?(问题)</li>\n<li>有没有投其他公司的简历或者阿里其他部门</li>\n<li>如果进阿里的话，你个人的优势</li>\n<li>开源相关</li>\n</ul>\n</li>\n<li>hr面<ul>\n<li>自我介绍</li>\n<li>说一下项目中的难点，你在里面承担了什么角色，如何和同学协作，如何解决</li>\n<li>介绍了钉钉开放平台的业务</li>\n<li>有什么问题</li>\n</ul>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck7yrhz5f00009oetgxh9cvjq","category_id":"ck7yrhz6400039oet2wab4zdt","_id":"ck7yrhz6g000e9oet1a453rdd"},{"post_id":"ck7yrhz6100029oetfu374bkr","category_id":"ck7yrhz6c00089oete16y18ne","_id":"ck7yrhz6p000m9oet13sfeoc6"},{"post_id":"ck7yrhz6j000h9oet0kj807ay","category_id":"ck7yrhz6c00089oete16y18ne","_id":"ck7yrhz6v000r9oet3bkxgeqq"},{"post_id":"ck7yrhz6800059oet8s1s7mst","category_id":"ck7yrhz6400039oet2wab4zdt","_id":"ck7yrhz70000w9oetbd9t2of2"},{"post_id":"ck7yrhz6q000o9oet3m0v8eqs","category_id":"ck7yrhz6c00089oete16y18ne","_id":"ck7yrhz73000z9oet5yzcdc9j"},{"post_id":"ck7yrhz6a00069oet0ps51e52","category_id":"ck7yrhz6c00089oete16y18ne","_id":"ck7yrhz7700149oet18s4affb"},{"post_id":"ck7yrhz6t000q9oetej0d90fq","category_id":"ck7yrhz6400039oet2wab4zdt","_id":"ck7yrhz7a00179oetax9k1htv"},{"post_id":"ck7yrhz6b00079oet5n5n9a1x","category_id":"ck7yrhz6c00089oete16y18ne","_id":"ck7yrhz7c001b9oetecu2e7ok"},{"post_id":"ck7yrhz7600139oet9tuu5urf","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz7e001f9oethcml1nlz"},{"post_id":"ck7yrhz6d000b9oet3gvo9x94","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz7g001j9oet4ogv8uwc"},{"post_id":"ck7yrhz6f000d9oetdghy3osg","category_id":"ck7yrhz7a00199oet4qx8an7y","_id":"ck7yrhz7i001o9oet48vpdw5y"},{"post_id":"ck7yrhz6l000j9oet37ca0zvs","category_id":"ck7yrhz7a00199oet4qx8an7y","_id":"ck7yrhz7t001u9oete17cc7g1"},{"post_id":"ck7yrhz6z000v9oet4xx8ec9f","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz7w00209oet5uxj54pm"},{"post_id":"ck7yrhz71000y9oet5ko9d3zm","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz8100259oet373r3vz9"},{"post_id":"ck7yrhz7w00219oet090yabe0","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz83002b9oet74c11e8n"},{"post_id":"ck7yrhz7z00239oet94uje4b8","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz86002f9oethdkkgdiz"},{"post_id":"ck7yrhz7800169oetadcrefnj","category_id":"ck7yrhz7w001z9oet2jhhfc6m","_id":"ck7yrhz88002j9oeta1zxbkh9"},{"post_id":"ck7yrhz82002a9oet9ctobjei","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz8a002n9oet9jer5khm"},{"post_id":"ck7yrhz7b001a9oetfese6stl","category_id":"ck7yrhz8200289oetbst4dk82","_id":"ck7yrhz8c002r9oet0hpz4pei"},{"post_id":"ck7yrhz85002e9oet9cvk8veq","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz8e002v9oet1wtqc6bp"},{"post_id":"ck7yrhz7d001e9oet7arlhpmn","category_id":"ck7yrhz86002g9oetafkc770r","_id":"ck7yrhz8g002z9oet1ido4gf8"},{"post_id":"ck7yrhz89002m9oet8bx6hc7b","category_id":"ck7yrhz7w001z9oet2jhhfc6m","_id":"ck7yrhz8i00329oet7dnybexf"},{"post_id":"ck7yrhz8b002q9oetg8vmdgeu","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz8k00369oethw1d6hl0"},{"post_id":"ck7yrhz7f001i9oet98vehwlc","category_id":"ck7yrhz8200289oetbst4dk82","_id":"ck7yrhz8l00389oet6ujr6tvw"},{"post_id":"ck7yrhz8d002u9oete1sd8cyi","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz8m003b9oet0ztdcjpj"},{"post_id":"ck7yrhz8f002y9oet9zybery9","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz8m003d9oet0jlygzmp"},{"post_id":"ck7yrhz7h001l9oet5jo4acrw","category_id":"ck7yrhz86002g9oetafkc770r","_id":"ck7yrhz8n003f9oetbfkuhv8t"},{"post_id":"ck7yrhz8g00319oetgdvq5zcp","category_id":"ck7yrhz7400119oetglorev8e","_id":"ck7yrhz8n003g9oetctzp0baa"},{"post_id":"ck7yrhz7o001p9oetc32y6066","category_id":"ck7yrhz86002g9oetafkc770r","_id":"ck7yrhz8n003i9oet65s109qe"},{"post_id":"ck7yrhz7r001r9oet1v1t25pz","category_id":"ck7yrhz86002g9oetafkc770r","_id":"ck7yrhz8o003j9oet6mgxawfh"},{"post_id":"ck7yrhz7t001v9oet17kr3hk9","category_id":"ck7yrhz86002g9oetafkc770r","_id":"ck7yrhz8o003l9oet7eoebm3t"},{"post_id":"ck7yrhz7u001x9oet2gzy37f9","category_id":"ck7yrhz8n003h9oetculbgp8z","_id":"ck7yrhz8o003m9oet5x6p6r5s"},{"post_id":"ck7yrhz8100279oeteukha9uz","category_id":"ck7yrhz8o003k9oetht1cbihh","_id":"ck7yrhz8p003o9oethzb556v1"},{"post_id":"ck7yrhz86002i9oet7lejdkq4","category_id":"ck7yrhz8o003k9oetht1cbihh","_id":"ck7yrhz8p003p9oet281ye1qy"}],"PostTag":[{"post_id":"ck7yrhz6a00069oet0ps51e52","tag_id":"ck7yrhz6600049oetd731dcud","_id":"ck7yrhz6d000a9oetaedia3y9"},{"post_id":"ck7yrhz5f00009oetgxh9cvjq","tag_id":"ck7yrhz6600049oetd731dcud","_id":"ck7yrhz6f000c9oet0oycea2r"},{"post_id":"ck7yrhz6100029oetfu374bkr","tag_id":"ck7yrhz6c00099oet292c59rw","_id":"ck7yrhz6k000i9oet6bpsepqa"},{"post_id":"ck7yrhz6f000d9oetdghy3osg","tag_id":"ck7yrhz6600049oetd731dcud","_id":"ck7yrhz6o000k9oetdh6q91dp"},{"post_id":"ck7yrhz6800059oet8s1s7mst","tag_id":"ck7yrhz6600049oetd731dcud","_id":"ck7yrhz6s000p9oetfdu39lmz"},{"post_id":"ck7yrhz6l000j9oet37ca0zvs","tag_id":"ck7yrhz6600049oetd731dcud","_id":"ck7yrhz6v000s9oet4c0850fl"},{"post_id":"ck7yrhz6q000o9oet3m0v8eqs","tag_id":"ck7yrhz6600049oetd731dcud","_id":"ck7yrhz71000x9oet7h0c8nzf"},{"post_id":"ck7yrhz6b00079oet5n5n9a1x","tag_id":"ck7yrhz6p000n9oet9h9kdakc","_id":"ck7yrhz7300109oetfxj6gvak"},{"post_id":"ck7yrhz6z000v9oet4xx8ec9f","tag_id":"ck7yrhz6y000u9oetd01eea8i","_id":"ck7yrhz7800159oetbraydwdw"},{"post_id":"ck7yrhz6d000b9oet3gvo9x94","tag_id":"ck7yrhz6y000u9oetd01eea8i","_id":"ck7yrhz7a00189oetbgd6h9aa"},{"post_id":"ck7yrhz71000y9oet5ko9d3zm","tag_id":"ck7yrhz6y000u9oetd01eea8i","_id":"ck7yrhz7d001d9oetd9ym0zob"},{"post_id":"ck7yrhz6j000h9oet0kj807ay","tag_id":"ck7yrhz7500129oetdz5uaqj1","_id":"ck7yrhz7e001g9oet56e1c39w"},{"post_id":"ck7yrhz6t000q9oetej0d90fq","tag_id":"ck7yrhz7c001c9oet0pifb39a","_id":"ck7yrhz7i001m9oet6uf5d9ab"},{"post_id":"ck7yrhz7600139oet9tuu5urf","tag_id":"ck7yrhz7g001k9oete2lc444b","_id":"ck7yrhz7s001s9oetdm8yh5k5"},{"post_id":"ck7yrhz7800169oetadcrefnj","tag_id":"ck7yrhz7q001q9oet7pdn7ozn","_id":"ck7yrhz7w001y9oet6e6d2i3u"},{"post_id":"ck7yrhz7u001x9oet2gzy37f9","tag_id":"ck7yrhz6600049oetd731dcud","_id":"ck7yrhz7y00229oetg583819z"},{"post_id":"ck7yrhz7d001e9oet7arlhpmn","tag_id":"ck7yrhz7u001w9oetauik4fn6","_id":"ck7yrhz8100269oet3x14cq5t"},{"post_id":"ck7yrhz7z00239oet94uje4b8","tag_id":"ck7yrhz6y000u9oetd01eea8i","_id":"ck7yrhz8200299oet34q7f70c"},{"post_id":"ck7yrhz7o001p9oetc32y6066","tag_id":"ck7yrhz7u001w9oetauik4fn6","_id":"ck7yrhz84002d9oetau8z4tm8"},{"post_id":"ck7yrhz82002a9oet9ctobjei","tag_id":"ck7yrhz7g001k9oete2lc444b","_id":"ck7yrhz86002h9oet1ed28fp1"},{"post_id":"ck7yrhz85002e9oet9cvk8veq","tag_id":"ck7yrhz7g001k9oete2lc444b","_id":"ck7yrhz89002l9oet68xmcsu8"},{"post_id":"ck7yrhz7w00219oet090yabe0","tag_id":"ck7yrhz84002c9oetatfc0u78","_id":"ck7yrhz8b002p9oetcdoicl0i"},{"post_id":"ck7yrhz89002m9oet8bx6hc7b","tag_id":"ck7yrhz7q001q9oet7pdn7ozn","_id":"ck7yrhz8d002t9oet5m938k4v"},{"post_id":"ck7yrhz8100279oeteukha9uz","tag_id":"ck7yrhz88002k9oetcng8d2nd","_id":"ck7yrhz8f002x9oet3jfz3m9o"},{"post_id":"ck7yrhz8b002q9oetg8vmdgeu","tag_id":"ck7yrhz7g001k9oete2lc444b","_id":"ck7yrhz8g00309oetccx4839z"},{"post_id":"ck7yrhz8d002u9oete1sd8cyi","tag_id":"ck7yrhz7g001k9oete2lc444b","_id":"ck7yrhz8k00359oet9p7c6t6y"},{"post_id":"ck7yrhz86002i9oet7lejdkq4","tag_id":"ck7yrhz88002k9oetcng8d2nd","_id":"ck7yrhz8l00379oet1zal5elj"},{"post_id":"ck7yrhz8g00319oetgdvq5zcp","tag_id":"ck7yrhz7g001k9oete2lc444b","_id":"ck7yrhz8l003a9oethr5ye1n5"},{"post_id":"ck7yrhz8f002y9oet9zybery9","tag_id":"ck7yrhz8j00349oetbc0e1591","_id":"ck7yrhz8m003c9oetcfpo4q9x"}],"Tag":[{"name":"learning","_id":"ck7yrhz6600049oetd731dcud"},{"name":"learning set","_id":"ck7yrhz6c00099oet292c59rw"},{"name":"learning Array","_id":"ck7yrhz6p000n9oet9h9kdakc"},{"name":"interview","_id":"ck7yrhz6y000u9oetd01eea8i"},{"name":"stack","_id":"ck7yrhz7500129oetdz5uaqj1"},{"name":"springboot","_id":"ck7yrhz7c001c9oet0pifb39a"},{"name":"alibaba","_id":"ck7yrhz7g001k9oete2lc444b"},{"name":"TCP","_id":"ck7yrhz7q001q9oet7pdn7ozn"},{"name":"Java","_id":"ck7yrhz7u001w9oetauik4fn6"},{"name":"美团","_id":"ck7yrhz84002c9oetatfc0u78"},{"name":"mysql","_id":"ck7yrhz88002k9oetcng8d2nd"},{"name":"腾讯","_id":"ck7yrhz8j00349oetbc0e1591"}]}}