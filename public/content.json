{"pages":[{"title":"刘云尚","text":"联系方式 Email：970090853@qq.com 个人信息 刘云尚/男/1996 Github：https://github.com/csxiaoshang 目前在北京，北京邮电大学","link":"/about/index.html"}],"posts":[{"title":"my first blog","text":"上网学习了一上午怎么用github搭建个人博客，找到了xudailong先生的博客，fork项目，拿来做了一下更改，算是初步完成了，表示感谢！","link":"/2018/05/16/2018-05-16-firstblog/"},{"title":"20.Valid Parentheses","text":"这是一道比较简单的堆栈题目，但是本人很少用java写程序做题，做题的过程中出了很多错误，也上网百度了下，算是完成了 1class Solution {2 public boolean isValid(String s) {3 Stack&lt;Character&gt; stack=new Stack&lt;Character&gt;();4 for(int i=0;i&lt;s.length();i++){5 char ch=s.charAt(i);6 switch (ch) {7 case '(':8 case '[':9 case '{':10 stack.push(ch);11 break;12 case ')':13 if((stack.isEmpty())||stack.peek()!='(')14 return false;15 else16 stack.pop();17 break;18 case ']':19 if((stack.isEmpty())||stack.peek()!='[')20 return false;21 else22 stack.pop();23 break;24 case '}':25 if((stack.isEmpty())||stack.peek()!='}')26 return false;27 else28 stack.pop();29 break;30 default:31 break;32 }33 }34 if(!stack.isEmpty())35 return false;36 return true;37 }38 }","link":"/2018/09/17/2018-09-17-ValidParentheses/"},{"title":"3.Longest Substring Without Repeating Characters","text":"Question: Given a string, find the length of the longest substring without repeating characters.这道题两个循环遍历找最大的子串也可以，但是那样会慢一些，这里借助set的性质处理的这道题，感觉还可以用KMP算法，等回头做了再贴上来 1class Solution {2 public int lengthOfLongestSubstring(String s) {3 int len=s.length();4 int ans=0;5 Set&lt;Character&gt; se=new HashSet&lt;Character&gt;();6 for(int i=0,j=0;j&lt;len;) {7 if(!se.contains(s.charAt(j))) {8 se.add(s.charAt(j));9 j++;10 ans=Math.max(ans, j-i);11 }12 else {13 se.remove(s.charAt(i));14 i++;15 }16 }17 return ans;18 }19}","link":"/2018/09/18/2018-09-18-LongestSubstringWithoutRepeatingCharacters/"},{"title":"搭一个自己的vpn","text":"寻思自己搭建一个VPN留着用来翻墙学习游戏，了解到可以使用shadowsocks，再租一个国外的服务器搭好环境基本就可以使用了 参考博客 参考博客2脚本搭建ss 服务器网址 当然现在还没有搭 &gt;_&lt;！","link":"/2018/05/18/2018-05-18-create-vpn/"},{"title":"4. Median of Two Sorted Arrays","text":"Question: There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.这道题比较简单，就是讲两个数组合并下然后排序，找中位数就可以了 1class Solution {2 public static double findMedianSortedArrays(int[] nums1,int[] nums2) {3 int[] shuzu=Arrays.copyOf(nums1,nums1.length+nums2.length);4 System.arraycopy(nums2, 0, shuzu, nums1.length, nums2.length);5 Arrays.sort(shuzu);6 int num=nums1.length+nums2.length;7 double count=0;8 if(num%2==0) {9 count=(double)(shuzu[num/2-1]+shuzu[num/2])/2;10 }else {11 count=(double)shuzu[(num-1)/2];12 }13 return count;14 }15 }","link":"/2018/09/20/2018-09-20-MedianofTwoSortedArrays/"},{"title":"面试搜狗实习","text":"面试搜狗的实习，估计凉了 之前没事投了几个简历，也记不清这次是 java 还是android的了，还有点不太想去。。 寻思了下还是过去吧，面试下还能增长下经验，了解下今后的学习方向。 过去后，先去了前台登记了下，等一会面试的人过来了，叫到一个屋子里面试。先给了我一份试题，一串代码关于继承和上转型的，有一些 activity的lanchmode啥的 sevice的生命周期啥的，不太会;后面是两道编程题，比较简单，一个是用链表实现堆栈的push pop peak，一个是查找字符串里第一个不重复的字符。自我介绍了下，聊了下项目，项目怎么实现的啥的，后来问了点java的多态啥的，有点忘了，面试中我想起来，这个投的应该是android，他说了一句话，看你做的东西应该是没有调用过一些android核心的api，应该是凉了。 算是个经验，不会的东西还有很多，没事多刷刷leetcode，把java研究精通些。","link":"/2018/09/21/2018-09-21-sougoumianshi/"},{"title":"232. Implement Queue using Stacks","text":"Question: Implement the following operations of a queue using stacks. 用两个栈就可以实现一个队列的操作，注意判断栈是否为空 1 class MyQueue {2 /** Initialize your data structure here. */3 Stack&lt;Integer&gt; stack1=new Stack&lt;&gt;();4 Stack&lt;Integer&gt; stack2=new Stack&lt;&gt;();5 public MyQueue() {6 7 }8 9 public void push(int x) {10 while(!stack2.isEmpty())11 stack1.push(stack2.pop());12 stack1.push(x);13 }14 public int pop() {15 while(!stack1.isEmpty())16 stack2.push(stack1.pop());17 int x=stack2.pop();18 return x;19 }20 public int peek() {21 while(!stack1.isEmpty())22 stack2.push(stack1.pop());23 return stack2.peek();24 }25 public boolean empty() {26 if(stack1.isEmpty()&amp;&amp;stack2.isEmpty())27 return true;28 else29 return false;30 }31}","link":"/2018/09/22/2018-09-22-ImplementQueueusinggStacks/"},{"title":"Java编程思想学习小结","text":"这段时间学习了下Java编程思想 之前做项目一些不懂的地方，通过这个看书找到很多答案，也知道不太会的问题应该去哪找了，感觉对自己很有帮助。 这本书看的时候并没有完完全全详细的看完，看了一些重点章节 仍有很多不会的地方，后续还要通过博客学习完善，甚至得再看看书。最后，感觉这本书对于java学习的进阶很有帮助。","link":"/2019/01/16/2019-01-16-ThinkInJava/"},{"title":"大话设计模式学习小结","text":"策略模式它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到算法的客户 单一职责原则就一个类而言，应该只有一个引起它变化的原因 开放封闭原则软件实体应该可以扩展，但是不可修改（增加新需求增加新代码） 依赖倒转原则针对接口编程，不要对实现编程 高层模块不应该依赖底层模块，两个都应该依赖抽象 抽象不应该依赖细节，细节应该依赖抽象里氏代换原则一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。即在软件里面，把父类都替换成它的子类，程序的行为没有变化。 子类型必须能够替换掉它们的父类型通俗来讲，就是高层模块依赖接口，具体实现则是继承了此接口的实现类 装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活 代理模式为其他对象提供一种代理以控制对这个对象的访问 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类 原型模式用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象","link":"/2019/01/26/2019-01-26-DesignPattern/"},{"title":"iqiyi实习总结","text":"在爱奇艺实习的经验总结 今年算是在7月到9月在爱奇艺实习了两个月，算是偷偷的跑了出去。说实话这两个月在爱奇艺学到的东西不多，接手的项目并不是一个线上使用的能够盈利的项目。而是一个公司内部使用的一个持续集成、持续部署的系统，给爱奇艺电视打包各种不同的软件。用的是ssh框架，比较老，给自己的活主要是一些curd，也包括修改前端页面jsp。唯一有点任务量的算是封装httpclient的api上传下载文件，另一个算是这个系统的核心业务了，编写使用jenkins api的通用工具类，自己写完后就将这个工具类开源了，还打包推到了maven中央仓库。。。 之前都是用springboot写项目，虽然大四的时候看了些javaweb的教程，学习了jsp、servlet，但是也不是太明白。通过做这个项目算是明白了spring项目的启动原理，ioc、aop的一些核心的东西， 当时在公司里明白了一个http请求到tomcat处理后分发到spring再处理后，再到业务处理完返回的整个流程的时候，特别兴奋，也模仿github上的一个项目编写了一个小的tomcat demo.在公司的时候 ，同时看了些左潇龙大佬的设计模式博客，受益颇多。对java的继承 泛型理解多了些，尝试编写通用型的代码，注意编码时的解耦。jvm这本书读了内存那块，看了并发实战的一部分内容。 这两个月一下子就过去了，学到了挺多东西，但是又感觉没有多少，技术水平还得继续增强。 掌握好基础，多实践多学习！","link":"/2019/11/26/2019-11-26-iqiyi/"},{"title":"leetcode练习汇总（持续更新）","text":"在个人github上新建了一个leetcode仓库，以后的练习将提交到此处 地址","link":"/2019/01/16/2019-01-16-leetcode/"},{"title":"使用springboot+ajax+bootstrap搭建的一个前后端耦合的个人博客项目","text":"搭建的比较简陋，只是完成了基本的用户和发表博客、展示博客等功能 项目地址 之后会继续学习springboot，了解前后端分离的使用。","link":"/2018/11/14/2018-11-14-springbootblog/"},{"title":"Java基础","text":"一、 数据类型基本类型 byte 8 short 16 char 16 int 32 float 32 long 64 double 64 boolean ~ boolean类型可以使用1bit来存储，但是具体大小没有明确规定。jvm会在编译时期将boolean类型转int，使用1 0 表示。 缓存池基本类型对应的缓存池如下： boolean true false short -128 and 127 int -128 and 127 char in the range \\u0000 to \\u007F 以Integer为例子， new Integer()将新增一个对象，而Integer.valueOf()则会首先在缓存池里选取。 二、 StringString Pool字符串常量池保存着所有的字符串字面量。一般来说，这些字面量编译期就确定。也可以使用String.intern()在运行时期将字符串添加到String Pool中。 三、 运算参数传递java中的参数传递是以值传递的方式，而不是引用传递。可以认为传递的参数是针对原有引用存储值的拷贝，并不是原来的引用。 四、 关键字final声明数据为常量 对于基本类型，final使数据不变 对于引用类型，final是引用不变，即不可引用其他对象，但被引用的对象可以修改 声明方法不能被子类重写private方法隐式地定义为final，如果子类中出现和基类的一个private方法名相同的方法，不是对基类方法的重写，而是新定义的一个方法 声明类不允许被继承 static静态方法必须有实现，不能还是抽象方法静态方法中不能有this super关键字，这两个关键字与具体对象关联 静态代码块在类初始化时运行一次 初始化顺序：静态变量和静态代码块优于实例变量和普通代码块，构造函数最后初始化 存在继承的情况下，初始化顺序为： 父类 （静态变量、静态代码块） 子类 （静态变量、静态代码块） 父类 （实例变量、普通代码块） 父类 （构造函数） 子类 （实例变量、普通代码块） 子类 （构造函数） 五、 Object通用方法equals()实现： 检查是否为同一个对象的引用，如果是直接返回true 检查是否为同一种类型，如果不是直接返回false 将Object对象进行转型 判断每个关键字段是否相等 1public class Example{2 int a;3 int b;4 5 @Override6 public boolean equals(Object o){7 if(this == o ) return true;8 if(o ==null || getClass() != o.getClass()) return false;9 Example that = (Example) o;10 if(this.a == that.a &amp;&amp; this.b == that.b)11 return true;12 else13 return false;14 }15} hashCode()等价的两个对象散列值一定相等在覆盖equals()方法时应当总是覆盖hashCode()方法，保证等价的两个对象哈希值也相等。 理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成R进制的某一位，然后组成一个R进制的整数。 1@Override2public int hashCode(){3 int result = 17;4 result = 31 * result + x;5 result = 31 * result + y;6 result = 31 * result + z;7 return result;8} clone()1.cloneable clone()是Object的project方法，一个类没有重写Clone()方法，其他类就不能直接去调用该类实例的Clone()方法。还需要实现Cloneable接口。 2.浅拷贝与深拷贝 浅拷贝：原始对象和拷贝对象引用指向同一个对象深拷贝：原始对象和拷贝对象引用指向不同的对象 上文中的clone()方法通常是对依照原始对象new一个新的拷贝对象，然后根据原始对象的每个域复制给拷贝对象。 3.clone()的替代方案使用clone()方法比较复杂，最好不要使用clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象 也可以使用序列化的方式拷贝 六、继承抽象类与接口1.抽象类如果一个类中包含抽象方法，那这个类必须声明为抽象类抽象类和普通类最大的区别是抽象类不能被实例化，只能被继承 2.接口 接口的成员(字段+方法)默认都是public的，并且不允许定义为private和protected接口的字段默认都是static和final的 3.比较 从设计层面看，抽象类提供一种is-a关系，需要满足里氏代换原则，即子类对象必须能够替换掉所有父类对象；接口更像是一种like-a关系 从使用上看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口字段只能是static和final类型的，抽象类没有限制 接口的成员只能是public的，抽象类成员可有多种访问权限 七、泛型使用泛型的好处：1.在集合中存储对象并在使用前进行类型转换不方便，泛型提供了编译期间的类型安全，确保能能够把正确类型的对象放入到集合中2.在写业务封装对象时，泛型可以提供限定某种类型 10道java泛型面试题","link":"/2019/12/30/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"考虑后不去参加头条实习面试","text":"昨天下午收到了头条HR的电话，让过去参加面试，本来挺高兴的，寻思就算去不上，过去面试吸取下经验也是好的。 今天正好大学同学一起聚餐，特别高兴聊了很多。也寻思去过去看看肯定是好的，回来后，打算看看头条JAVA后台的实习面经，看了几篇劝退了。 您好，诚意邀请您参加字节跳动的面试。【面试时间】：2018-09-26 16:00:00【面试地点】：知春路甲48号盈都大厦B座10层【面试流程】：笔试/初试-复试-终面【乘车路线】：地铁10号线或13号线（知春路站B口出），西行约100米左转，前方左手边的写字楼即到。 深深的感觉到自己水平能力还有很大欠缺，想要做好java后台开发还有很长的路要走。 同时也很高兴自己来到了北京，这里机会真的是多。自己投了3份简历，两个让我去面试。在这种大环境下，真的是海阔凭鱼跃，天高任鸟飞。","link":"/2018/09/22/2018-09-22-toutiaomianshibuqu/"},{"title":"命令模式","text":"命令模式 下图为命令模式类图简单的看，命令模式实现了命令发起者和命令执行者的解耦，中间增加了一层调用者。命令组合命令执行者，调用者中维护一个命令列表，并封装命令执行方法。命令发起者则将命令添加到命令调用者中。 1class Client{2 putCommand(Command command,Receiver receiver);3}45class Invoker{6 List&lt;Command&gt; commandList;7 executeCommand(){8 commandList.forEach(command-&gt;command.execute());9 }10}1112interface Command{13 execute();14}1516class CommandA implements Command{17 Receiver receiver;18 execute(){19 receiver.action();20 }21}2223class Receiver{24 action(){25 // 需要执行的业务逻辑26 }27}","link":"/2019/11/27/2019-11-27-CommandPattern/"},{"title":"TCP状态问题","text":"TCP三次握手建立连接 Client发送带有SYN和seq = x的包到Server;Client转为SYN_SENT Server返回SYN、ACK、ack = x +1和seq = y的包，Server从LISTEN切换到SYN_RCVD Client发送ACK、 ack = y +1和seq = x+1 的包，都转为ESTABLISHED 三次握手的主要目的是：信息对等和防止超时。防止超时导致脏连接。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 TCP四次挥手释放连接 Client发送带有FIN和seq = x的包到Server，Client从ESTABLISHED转为FIN_WAIT_1 Server发送带有Ack 、ack= x+1和seq = y的包到Client，Server进入到CLOSE_WAIT状态 Client收到确认请求后，进入FIN_WAIT_2，等待服务器发送释放报文 Server最后的数据发送完毕后，便发送释放报文，FIN = 1,ack = x+1 和 seq = w ,Server进入到LAST_ACK状态 Client收到释放报文后，发出ACK、ack = w+1和seq = x+1，进入到TIME_WAIT状态。这是TCP连接还没有释放，必须等待2MSL（最长报文段寿命）时间后，当Client撤销相应的TCB后，才进入CLOSED状态 Server只要收到了客户端发出的确认，立即进入CLOSED状态。Server结束TCP连接的时间要比客户端早一些。","link":"/2019/12/27/TCP%E7%8A%B6%E6%80%81%E9%97%AE%E9%A2%98/"},{"title":"2019年终总结","text":"2019年还剩下10天，马上就要2020年了 回想过去的这一年里，有收获、也有失落、五味杂陈。 感觉人成长变化都是由一件件事情驱动的，如果没有经过经历我还是我，很难有实质性的变化。 如果说过去的2018年是由毕业到读研的一个过渡，让我重新体会到那种高中步入到大学的那种感觉；这2019年感觉便是对新阶段人生的加深、熟悉、进步。 学习工作 spring实战 java编程思想 redis设计与实现 图解http 深入理解JVM 大型网站技术架构 程序员修炼之道 effect java maven实战 java8实战 阿里巴巴Java开发手册 netty实战（未看完） spring cloud微服务实战（未看完） 高效能人士的七个习惯（未看完） 亲密关系（未看完） 球状闪电 数不清的技术博客（自我感觉多数未消化） 这样一一列出来，发现也是读了不少书，其中以技术书籍为主。去年读研半年，课余时间算是刚刚入门，过年回来后，便开始疯狂补充知识，其中有个致命的问题就是理论走在了前面 实践没有跟上。这个问题在开了新项目路边停车、在实习后得到了一定程度的解决。 这一年编码能力、阅读代码的能力都得到了一定程度的提高，从最开始阅读java源码都有问题、速度慢、不是特别理解等，到现在阅读速度上、理解上都有很大的提高。 刷题： 刷题刷的有些敷衍，在牛客上刷完了剑指offer、程序员面试金典的题，暗示自我感觉效果不好。在碰到不太会的问题时就去看了解答，但是也没有回过头来 认真思考。接下来到到寒假结束有一个半月时间，承诺自己最少在leetcode刷100题。比赛： 1.参加了腾讯的微信小程序比赛，最后进了复赛但是也没有拿到名次， 2.阿里第五届中间件比赛，一开始直接懵逼了，各种不会。使劲搞了一番 616/4095,意料之内 等赛事结束后，又进行了一波复盘 照着大佬的代码思考一番，敲出一个版本，在自适应负载均衡比赛中 45/498，还算满意 还有一个消息队列的题目一直没吃透，抽时间再搞一稿参加比赛确实能学到很多东西，这次参加中间件比赛，接触到了很多之前不懂的东西，很有收获 实习： 在七月份的时候，偷偷出去实习了两个月。在爱奇艺做的是一个内部使用的系统，用的技术也比较老 ssh这一套技术框架。自己对待的比较认真，老大给的任务都 非常认真的完成，只不过有时候，完成了也不提交代码，磨一点时间自己学习。写些CURD、封装接口、OSS使用、jenkins使用、将设计模式用到代码中 也学到了很多东西，感觉最重要的是 通过做这个中老的框架的东西，让我对spring、tomcat有了更好的理解，梳理了从请求发出到返回的整个过程、细节。仿照开源项目，写demo tomcat、spring等，也给 开源项目贡献了一次代码，虽然只是文本翻译... 这次实习过程对自己很重要，也很感谢老大 生活 生活上还是自己一个人，孤单倒不孤独，可能是真的单身习惯了；有时候去参加联谊、想要找个女朋友，但是感觉找不找得到也无所谓。并不是多放在心上，宁愿更多一点时间待着实验室里…实习时候碰到一个女生，做了件好蠢的事情…最近 感情上有碰到些问题，有点不知道自己该不该接受，有点想逃避、有点想接受…不愿多想、感觉自己又会犯错误 深深的感觉到 父母因为文化问题有些愚昧，自己也成年好多年了，家里有些事情应该帮他们做主意；一转眼弟弟也上初中了，马上该上高中了，感觉跟当初的我一样，知道好好学习，但是也会特别想玩。有时想将自己遗憾没有做的事情，嘱咐他 想让他不要错过，但是往往事与愿违。姨姐今年也结婚了，最开始还考虑要不要回家…看到她结婚真好生活有条不紊，注意作息 健康饮食 方法论 这一年加深了对理论联系实践、从实践中来到实践中去的认知 在学习生活中，光学习理论知识不实践、光实践不增强理论知识都不行，只有两者不同程度的并进才能达到较好的效果。比如，实践碰到问题了，回过头来学习理论知识，而后再实践；从实践中学习，实践中验证学到的东西，不断重复这个过程 明年承诺 leetcode刷300题 拿到alibaba的offer 竹笛最少两首拿手曲子 英语达到能够听明白歌曲的程度 日语学习完新标准第一册 象棋稳定业二","link":"/2019/12/21/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"title":"gc","text":"判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。引用计数器：当引用计数器为零的时候，表明没用引用再指向该对象，但是引用计数器不能解决循环引用的情况；可达性分析： 当不能从GC Root寻找一条路径到达该对象时， 将进行第一次标记。 第一次标记后检查对象是否重写了finalize() 和是否已经被调用了finalize()方法。若没有重写finalize()方法或已经被调用，则进行回收。 在已经重写finalize()方法且未调用的情况下，将对象加入一个F-Queue 的队列中，稍后进行第二次检查。 在第二次标记之前，对象如果执行finalize()方法并完成自救，对象则不会被回收。否则完成第二次标记，进行回收。值得注意的是finalize()方法并不可靠。","link":"/2019/12/05/gc/"},{"title":"java内存分配","text":"java内存区域线程私有的：程序计数器、虚拟机栈、本地方法栈线程公有的：方法区、堆 程序计数器 和操作系统的程序计数器类似，用于控制程序执行步数，计算跳转内存地址 虚拟机栈 用来存储方法执行时的局部变量、动态链接、方法出口等。 本地方法栈 用来存储java JNI调用的native方法的相关信息，和虚拟机栈类似 方法区 用来存储常量、静态变量、类信息等信息，通俗来讲存储类的通用的模板数据 堆 存储几乎所有的实例化对象和数组，包括对象的实例变量。 Java7之后，String Pool被移到堆内，因为永久代空间有限，在大量使用字符串的场景下会出现OutOfMemoryError错误 直接内存 这不是虚拟机数据区的一部分，属于堆外内存。这样可以避免在java堆和native堆中来回复制数据。 java内存模型对于线程共享的静态变量、实例变量、和构成数组对象的元素是存储在堆中，算是常说的主内存。而每个线程使用这些变量的时候则需要将其读取复制到自身的工作内存，处理后再写会主内存。所以会有变量可见性问题，即不能及时看到变化。对于关键字volatile来说，其修饰的变量读写直接在主内存中，不涉及到工作内存的读写，所有是保证可见性的。","link":"/2019/12/04/java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"title":"双亲委派模型类加载器问题","text":"下图是关于类加载顺序的总结","link":"/2019/12/02/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"learning","slug":"learning","link":"/tags/learning/"},{"name":"learning set","slug":"learning-set","link":"/tags/learning-set/"},{"name":"learning Array","slug":"learning-Array","link":"/tags/learning-Array/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"}],"categories":[{"name":"learning","slug":"learning","link":"/categories/learning/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"note","slug":"note","link":"/categories/note/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"程序人生","slug":"程序人生","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}]}